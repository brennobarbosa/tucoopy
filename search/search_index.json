{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"tucoopy (Python)","text":"<p><code>tucoopy</code> is a Python library for TU (transferable utility) cooperative game theory. It provides:</p> <ul> <li>Classic game generators (glove, weighted voting, airport, bankruptcy, unanimity, ...)</li> <li>Classic solution concepts (Shapley, Banzhaf, least-core / nucleolus, kernel / prekernel, tau value, ...)</li> <li>Geometric helpers intended for visualization (core, epsilon-core, imputation set, Weber set, bargaining set)</li> <li>A JSON-friendly animation spec generator compatible with the <code>tucoopyjs</code> package</li> </ul>"},{"location":"#scope-and-design-goals","title":"Scope and design goals","text":"<ul> <li>Focus on TU cooperative games (characteristic function games).</li> <li>Keep a clean, well-structured API: a small top-level surface, with most functionality organized in subpackages.</li> <li>Prefer correctness and clear diagnostics over maximum performance; many routines are exponential and intended for small <code>n</code>.</li> <li>Optional heavy dependencies:</li> <li><code>tucoopy[lp]</code> enables LP-based methods via <code>SciPy</code> (least-core, nucleolus, balancedness, bargaining set, ...)</li> <li><code>tucoopy[lp_alt]</code> enables an alternative LP backend via <code>PuLP</code></li> <li><code>tucoopy[fast]</code> enables <code>NumPy</code>-based helpers (kernel / prekernel)</li> <li><code>tucoopy[viz]</code> enables simple 2-3 player visualization via <code>Matplotlib</code></li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"<p>If you are new to the package, start here:</p> <ul> <li>Quickstart: installation + minimal examples</li> <li>API reference: public API map (stable top-level vs. subpackages)</li> <li>Theory overview: core concepts and solution ideas</li> <li>Geometry: geometric objects for visualization (core, epsilon-core, imputation, Weber, bargaining, ...)</li> <li>Animation spec: generating JSON specs consumed by the JS renderer</li> <li>Roadmap: implementation checklist / next steps</li> <li>Contributing: how to contribute</li> </ul>"},{"location":"#minimal-example","title":"Minimal example","text":"<pre><code>from tucoopy import Game\nfrom tucoopy.solutions import shapley_value\n\ng = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\nprint(shapley_value(g))  # [1.0, 1.0, 1.0]\n</code></pre>"},{"location":"guides/analysis_contract/","title":"<code>analysis</code> contract (Python -&gt; JSON)","text":"<p>This page documents the meaning of the fields in <code>AnimationSpec.analysis</code> and the limits/guarantees of each one.</p>"},{"location":"guides/analysis_contract/#principles","title":"Principles","text":"<ul> <li><code>analysis</code> is optional and intended for caching/explainability on the frontend.</li> <li>For n&lt;=4, Python can export geometries (vertices) for drawing.</li> <li>For n&gt;4, we prefer exporting tables/lists (a bundle) rather than geometric objects.</li> </ul>"},{"location":"guides/analysis_contract/#analysismeta","title":"<code>analysis.meta</code>","text":"<p>Provenance and parameters used to generate <code>analysis</code>:</p> <ul> <li><code>analysis.meta.computed_by</code></li> <li><code>analysis.meta.build_analysis</code> (flags + <code>max_players</code>, <code>tol</code>, <code>diagnostics_top_k</code>)</li> <li><code>analysis.meta.computed</code> (which sections were included)</li> <li><code>analysis.meta.skipped</code> (reasons for skipping sections)</li> <li><code>analysis.meta.limits</code> (applied limits/truncations, e.g. <code>diagnostics_max_list</code>)</li> <li><code>analysis.meta.contract_version</code> (<code>analysis</code> contract version)</li> </ul>"},{"location":"guides/analysis_contract/#analysissolutions","title":"<code>analysis.solutions</code>","text":"<p>Named points (allocations):</p> <ul> <li>E.g. <code>shapley</code>, <code>normalized_banzhaf</code></li> <li>Each entry contains <code>{ \"allocation\": [x1, ..., xn] }</code></li> </ul> <p>Limits:</p> <ul> <li>May be exponential in <code>n</code>. By default, <code>build_analysis</code> only computes this for <code>n&lt;=max_players</code>.</li> <li><code>analysis.solutions.*.meta</code> records <code>computed_by</code> and <code>method</code>.</li> </ul>"},{"location":"guides/analysis_contract/#analysissets","title":"<code>analysis.sets</code>","text":"<p>Representations for visualization (small <code>n</code>):</p> <ul> <li><code>imputation.vertices</code>: vertices of the imputation set</li> <li><code>core.vertices</code>: vertices of the core</li> <li><code>reasonable.vertices</code>: vertices of the reasonable set (imputation + upper bounds <code>M</code>)</li> <li><code>core_cover.vertices</code>: vertices of the core cover (<code>m &lt;= x &lt;= M</code>)</li> <li><code>weber.points</code> (optional)</li> </ul> <p>Limits:</p> <ul> <li>Generated only for <code>n&lt;=max_players</code>.</li> <li>Each entry may include <code>meta</code> with provenance.</li> <li>Large lists (<code>vertices</code> / <code>points</code>) may be truncated by <code>max_points</code> and flagged in <code>meta.truncated</code>.</li> </ul>"},{"location":"guides/analysis_contract/#analysisblocking_regions","title":"<code>analysis.blocking_regions</code>","text":"<p>Cache of blocking regions (currently for <code>n=3</code>):</p> <ul> <li><code>coordinate_system</code></li> <li><code>regions[]</code>: polygons with an associated <code>coalition_mask</code></li> </ul>"},{"location":"guides/analysis_contract/#analysisdiagnostics","title":"<code>analysis.diagnostics</code>","text":"<p>Diagnostics for the UI (tooltips/tables):</p> <ul> <li><code>analysis.diagnostics.input</code>: game checks (e.g. <code>vN</code>, <code>sum_singletons</code>, <code>essential</code>)</li> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core</code>: why a point is/is not in the core</li> </ul> <p>Truncations:</p> <ul> <li>Potentially large lists in <code>analysis.diagnostics.input</code> may be truncated (e.g. <code>missing_coalition_masks</code>).   The field <code>missing_coalition_masks_truncated</code> indicates whether truncation happened and <code>missing_coalition_mask_count</code> reports the total.</li> </ul> <p>Consistency checks (when applicable, small <code>n</code>):</p> <ul> <li><code>simple_game</code>: whether all values are in <code>{0,1}</code></li> <li><code>monotone_simple_game</code>: whether the simple game is monotone (<code>v(S) &lt;= v(S U {i})</code>)</li> <li><code>monotone_counterexample</code>: a counterexample when <code>monotone_simple_game=false</code></li> </ul>"},{"location":"guides/analysis_contract/#lp-based-explanations-optional","title":"LP-based explanations (optional)","text":"<p>When <code>include_lp_explanations=true</code> and <code>n&lt;=lp_explanations_max_players</code>, <code>build_analysis</code> may include:</p> <ul> <li><code>analysis.diagnostics.lp.balancedness_check</code> (Bondareva-Shapley: certificate for an empty core)</li> <li><code>analysis.diagnostics.lp.least_core</code> (least-core \\(\\epsilon\\), tight coalitions, and solver diagnostics)</li> </ul>"},{"location":"guides/analysis_contract/#analysisbundle-n4","title":"<code>analysis.bundle</code> (n&gt;4)","text":"<p>For <code>n&gt;max_players</code>, <code>build_analysis</code> includes a lightweight bundle with summaries:</p> <ul> <li><code>analysis.bundle.game_summary</code> (e.g. <code>n_players</code>, <code>vN</code>, <code>essential</code>, <code>provided_coalitions</code>)</li> <li><code>analysis.bundle.notes</code> (how to interpret limits)</li> <li><code>analysis.bundle.meta</code> records provenance</li> </ul> <p>When <code>n&lt;=bundle_max_players</code> and the game is complete (has all <code>v(S)</code>), the bundle may also include tables:</p> <ul> <li><code>analysis.bundle.tables.players</code> (per-player scalars)</li> <li><code>analysis.bundle.tables.power_indices</code> (only for complete simple games)</li> <li><code>analysis.bundle.tables.tau_vectors</code> (utopia payoff and minimal rights; requires a complete game)</li> <li><code>analysis.bundle.tables.approx_solutions.shapley</code> (approximate Shapley via sampling; includes <code>stderr</code>)</li> </ul>"},{"location":"guides/animation_spec/","title":"Animation spec (Python -&gt; JS contract)","text":"<p><code>tucoopy</code> can emit a JSON \"animation spec\" that a renderer can consume to draw allocations over time.</p> <p>Schema files (in this repo):</p> <ul> <li><code>src/tucoopy/io/schemas/tucoop-animation.schema.json</code></li> <li><code>src/tucoopy/io/schemas/tucoop-game.schema.json</code></li> </ul>"},{"location":"guides/animation_spec/#dataclasses","title":"Dataclasses","text":"<p>The Python-side data model lives in <code>tucoopy.io.animation_spec</code>:</p> <ul> <li><code>AnimationSpec</code></li> <li><code>GameSpec</code> / <code>CharacteristicEntry</code></li> <li><code>SeriesSpec</code> / <code>FrameSpec</code></li> </ul> <p>Helper functions:</p> <ul> <li><code>game_to_spec(game)</code> converts a <code>Game</code> into a <code>GameSpec</code> (JSON-friendly).</li> <li><code>series_from_allocations(...)</code> builds a <code>SeriesSpec</code> from a sequence of allocations.</li> <li><code>build_animation_spec(...)</code> builds a \"full\" <code>AnimationSpec</code> (game + analysis + series), with optional highlights.</li> </ul>"},{"location":"guides/animation_spec/#minimal-example","title":"Minimal example","text":"<pre><code>from tucoopy import Game, shapley_value\nfrom tucoopy.io import build_animation_spec\n\ng = Game.from_coalitions(\n    n_players=3,\n    values={\n        (): 0.0,\n        (0,): 1.0,\n        (1,): 1.2,\n        (2,): 0.8,\n        (0, 1): 2.8,\n        (0, 2): 2.2,\n        (1, 2): 2.0,\n        (0, 1, 2): 4.0,\n    },\n)\n\nphi = shapley_value(g)\nspec = build_animation_spec(\n    g,\n    schema_version=\"0.1.0\",\n    series_id=\"shapley\",\n    allocations=[phi] * 60,\n    dt=1 / 30,\n)\nprint(spec.to_json())\n</code></pre> <p>Notes:</p> <ul> <li><code>analysis</code> is intentionally flexible, but it is worth keeping it aligned with the JSON schema.</li> <li>For visualization, the JS package can only render up to 4 players (simplex up to the 3-simplex).</li> </ul>"},{"location":"guides/animation_spec/#per-frame-highlights-seriesframeshighlights","title":"Per-frame highlights (<code>series[].frames[].highlights</code>)","text":"<p>Each frame can carry a <code>highlights</code> object with extra UI information (e.g. a tooltip that follows the mouse).</p> <p>Current (optional) convention used by the examples:</p> <ul> <li><code>frame.highlights.diagnostics.core</code>: contains a small payload with <code>max_excess</code> and <code>blocking_coalition_mask</code>.</li> </ul>"},{"location":"guides/animation_spec/#provenance-analysismeta","title":"Provenance (<code>analysis.meta</code>)","text":"<p><code>tucoopy.io.build_analysis(...)</code> fills an <code>analysis.meta</code> block to record:</p> <ul> <li><code>analysis.meta.computed_by</code>: who generated it (e.g. <code>tucoopy</code>)</li> <li><code>analysis.meta.build_analysis</code>: flags and parameters (e.g. <code>max_players</code>, <code>tol</code>, <code>diagnostics_top_k</code>)</li> <li><code>analysis.meta.computed</code>: which sections were actually included (<code>solutions</code>, <code>sets</code>, <code>diagnostics</code>, <code>blocking_regions</code>)</li> </ul>"},{"location":"guides/animation_spec/#diagnostics-analysisdiagnostics","title":"Diagnostics (<code>analysis.diagnostics</code>)","text":"<p>To support the UI (tooltips/tables) without a backend, Python can attach compact diagnostics in <code>analysis.diagnostics</code>.</p> <p>Example: for each point in <code>analysis.solutions</code>, <code>tucoopy.io.build_analysis(...)</code> can include a summary of core membership:</p> <ul> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.in_core</code></li> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.max_excess</code></li> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.tight_coalitions</code> (coalitions attaining <code>max_excess</code>)</li> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.violations</code> (top-k blocking coalitions)</li> </ul> <p>There is also <code>analysis.diagnostics.input</code> for game-level checks (e.g. <code>vN</code>, <code>sum_singletons</code>, <code>essential</code>, and whether the characteristic function is complete for small <code>n</code>).</p>"},{"location":"guides/diagnostics/","title":"Debugging core/epsilon-core via <code>analysis.diagnostics</code>","text":"<p>The goal of <code>analysis.diagnostics</code> is to let the frontend explain \"why\" a point fails (or passes) without backend calls.</p>"},{"location":"guides/diagnostics/#why-is-a-point-not-in-the-core","title":"Why is a point not in the core?","text":"<p>For a point \\(x\\), the main diagnostic is:</p> <ul> <li>\\(\\text{maxexcess} = \\max_S (v(S) - x(S))\\)</li> <li>If \\(\\text{maxexcess} &gt; 0\\), there exists a blocking coalition.</li> </ul> <p>In JSON, this appears as:</p> <ul> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.max_excess</code></li> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.tight_coalitions</code></li> <li><code>analysis.diagnostics.solutions.&lt;id&gt;.core.violations</code> (top-k with <code>vS</code>, <code>xS</code>, <code>excess</code>)</li> </ul>"},{"location":"guides/diagnostics/#per-frame-diagnostics-tooltip","title":"Per-frame diagnostics (tooltip)","text":"<p>The examples also include a small payload in each frame:</p> <ul> <li><code>series[].frames[].highlights.diagnostics.core.blocking_coalition_mask</code></li> <li><code>series[].frames[].highlights.diagnostics.core.blocking_players</code></li> </ul> <p>This is useful for a tooltip that follows the mouse: when hovering a point/segment, show the blocking coalition and coordinates.</p>"},{"location":"guides/examples/","title":"Examples","text":"<p>Runnable examples live in <code>examples/</code>.</p> <p>From the repo root:</p>"},{"location":"guides/examples/#basics-no-optional-deps","title":"Basics (no optional deps)","text":"<pre><code>python examples/01_shapley_and_core.py\npython examples/02_classic_games.py\npython examples/07_weighted_values.py\npython examples/08_power_indices_weighted_voting.py\npython examples/15_transforms_mobius_and_harsanyi.py\npython examples/16_io_roundtrip_animation_spec.py\npython examples/17_diagnostics_core_checks.py\npython examples/18_blocking_regions_ternary.py\npython examples/19_power_indices_more.py\n</code></pre>"},{"location":"guides/examples/#io-json-contract","title":"IO / JSON contract","text":"<pre><code>python examples/05_animation_spec_to_file.py\npython examples/06_generate_specs_for_js_demo.py\npython examples/16_io_roundtrip_animation_spec.py\n</code></pre>"},{"location":"guides/examples/#examples-with-optional-dependencies","title":"Examples with optional dependencies","text":"<p>Warning</p> <p>Some examples require extras at runtime.</p> <ul> <li>LP (SciPy): <code>pip install \"tucoopy[lp]\"</code></li> <li>Fast (NumPy): <code>pip install \"tucoopy[fast]\"</code></li> <li>Viz (Matplotlib): <code>pip install \"tucoopy[viz]\"</code></li> </ul> <pre><code>python examples/03_least_core_and_nucleolus.py        # requires: tucoopy[lp]\npython examples/04_kernel_and_prekernel.py            # requires: tucoopy[fast]\npython examples/09_modiclus.py                        # requires: tucoopy[lp]\npython examples/10_kernel_set_and_bargaining_set.py   # partly requires: tucoopy[lp]\npython examples/11_static_viz_from_spec.py            # requires: tucoopy[viz]\npython examples/12_static_viz_direct.py               # requires: tucoopy[viz]\npython examples/13_mpl2_segment.py                    # requires: tucoopy[viz]\npython examples/14_mpl3_ternary.py                    # requires: tucoopy[viz]\npython examples/20_geometry_sets_with_lp_backend.py   # requires: tucoopy[lp]\n</code></pre>"},{"location":"guides/examples/#flags","title":"Flags","text":"<p>Some examples accept <code>--out DIR</code> (and in some cases <code>--spec-dir DIR</code>) to control where files are written/read.</p>"},{"location":"guides/large_games/","title":"How-to: n&gt;4 (bundle instead of geometry)","text":"<p>For \\(n&gt;4\\), the UI does not draw a full simplex; the recommended strategy is:</p> <ul> <li>Python exports an <code>analysis.bundle</code> with tables/lists/summaries.</li> <li>The frontend only presents the data (tables, lists, tooltips), without needing a backend to \"draw\".</li> </ul>"},{"location":"guides/large_games/#example-python","title":"Example (Python)","text":"<pre><code>from tucoopy import Game\nfrom tucoopy.io import build_analysis\n\ng = Game.from_coalitions(\n    n_players=6,\n    values={(): 0.0, (0,1,2,3,4,5): 10.0},\n    player_labels=[f\"P{i+1}\" for i in range(6)],\n)\n\nanalysis = build_analysis(g, max_players=4, include_bundle=True)\nprint(analysis[\"bundle\"][\"game_summary\"])\n</code></pre>"},{"location":"guides/large_games/#what-to-expect-in-json","title":"What to expect in JSON","text":"<ul> <li><code>analysis.sets</code> / <code>analysis.solutions</code> may be omitted when <code>n&gt;max_players</code>.</li> <li><code>analysis.meta.skipped</code> explains why (e.g. <code>n=6 &gt; max_players=4</code>).</li> <li><code>analysis.bundle</code> contains a lightweight summary and notes to guide the UI.</li> </ul> <p>When <code>n&lt;=bundle_max_players</code> and the game is complete, the bundle may include extra tables:</p> <ul> <li><code>analysis.bundle.tables.players</code> (per-player scalars)</li> <li><code>analysis.bundle.tables.power_indices</code> (if it is a complete simple game)</li> <li><code>analysis.bundle.tables.tau_vectors</code> (auxiliary vectors for the \\(\\tau\\) value)</li> <li><code>analysis.bundle.tables.approx_solutions.shapley</code> (approximate Shapley via sampling, with <code>stderr</code>)</li> </ul>"},{"location":"guides/lp_backends/","title":"LP backends (SciPy vs PuLP)","text":"<p>Some <code>tucoopy</code> algorithms need to solve Linear Programming (LP) problems, for example:</p> <ul> <li>least-core / nucleolus / modiclus</li> <li>balancedness checks (Bondareva-Shapley)</li> </ul> <p>These methods use a single adapter: <code>tucoopy.backends.lp.linprog_solve</code>.</p>"},{"location":"guides/lp_backends/#options","title":"Options","text":""},{"location":"guides/lp_backends/#scipy-recommended","title":"SciPy (recommended)","text":"<ul> <li>Extra: <code>pip install \"tucoopy[lp]\"</code></li> <li>Implementation: <code>scipy.optimize.linprog</code> (HiGHS)</li> <li>Best when you already have constraints in matrix form (<code>A_ub</code>, <code>A_eq</code>, ...), which is how <code>tucoopy</code> solvers are written.</li> </ul>"},{"location":"guides/lp_backends/#pulp-alternative-fallback","title":"PuLP (alternative / fallback)","text":"<ul> <li>Extra: <code>pip install \"tucoopy[lp_alt]\"</code></li> <li>Implementation: a PuLP model solved by CBC (default)</li> <li>Useful if you cannot install SciPy, or if you later need MILP (integer/binary).</li> </ul>"},{"location":"guides/lp_backends/#how-to-choose","title":"How to choose","text":"<ul> <li>Prefer SciPy for performance/robustness in continuous LP.</li> <li>Use PuLP when SciPy is not available or you need MILP (tucoopy does not use MILP today).</li> </ul>"},{"location":"guides/lp_backends/#example","title":"Example","text":"<pre><code>from tucoopy.backends.lp import linprog_solve\n\nres = linprog_solve(\n    [1.0, 0.0],               # minimize x\n    A_eq=[[1.0, 1.0]],         # x + y = 1\n    b_eq=[1.0],\n    bounds=[(None, None), (None, None)],\n    backend=\"scipy\",           # or \"pulp\"\n)\nprint(res.x.tolist())\n</code></pre>"},{"location":"guides/performance/","title":"Performance, limits, and computational costs","text":"<p>This page summarizes the main asymptotic costs in <code>tucoopy</code> and how to choose practical limits for larger games.</p>"},{"location":"guides/performance/#rule-of-thumb","title":"Rule of thumb","text":"<ul> <li>Almost everything that \"scans coalitions\" is at least \\(O(2^n)\\).</li> <li>Almost everything that \"scans permutations\" is \\(O(n!)\\).</li> <li>Almost everything that \"enumerates polytope vertices\" blows up with the number of constraints and the dimension.</li> </ul> <p>As \\(n\\) grows, the recommended strategy is:</p> <ul> <li>prefer sampling (points and/or permutations),</li> <li>generate <code>analysis.bundle</code> (tables and summaries) instead of trying to \"draw the whole simplex\",</li> <li>keep exact geometry to small \\(n\\).</li> </ul>"},{"location":"guides/performance/#quick-table-order-of-magnitude","title":"Quick table (order of magnitude)","text":"Object / routine Typical cost Notes Coalition scans (e.g. excesses) \\(O(2^n)\\) depends on having <code>v(S)</code> accessible / cached Shapley (exact, tabular) \\(O(n 2^n)\\) sum over subcoalitions / DP Banzhaf (exact, tabular) \\(O(n 2^n)\\) similar cost to Shapley Nucleolus / least-core / balancedness many LPs each LP may have many constraints (coalitions) Weber set (exact) \\(O(n!)\\) only feasible for small \\(n\\) Polyhedra (vertices) exponential vertex enumeration does not scale to large \\(n\\) Hit-and-run (sampling) many steps requires a bounded set and an initial point (LP)"},{"location":"guides/performance/#practical-recommendations-by-family","title":"Practical recommendations by family","text":""},{"location":"guides/performance/#point-solutions","title":"Point solutions","text":"<ul> <li>For small \\(n\\) (~10-12): <code>shapley_value</code>, <code>normalized_banzhaf_value</code>, and similar can be used exactly, as long as the game is \"complete\" (tabular).</li> <li>For larger \\(n\\):</li> <li>prefer approximating Shapley by sampling permutations (when available),</li> <li>avoid routines with many LPs (nucleolus/modiclus) without clear limits.</li> </ul>"},{"location":"guides/performance/#geometry-sets-polytopes","title":"Geometry (sets / polytopes)","text":"<ul> <li><code>PolyhedralSet.extreme_points(...)</code> is for visualization in low dimensions.</li> <li>For projections as \\(n\\) grows, prefer <code>project(..., approx_n_points=...)</code> (sampling + point projection).</li> </ul>"},{"location":"guides/performance/#simple-games-power-indices","title":"Simple games / power indices","text":"<ul> <li>If you can represent the simple game compactly (e.g. weighted voting), indices like Banzhaf/SSI tend to scale better than blindly scanning all subsets.</li> <li>For tabular simple games, there is still an \\(O(2^n)\\) cost for many operations.</li> </ul>"},{"location":"guides/performance/#weber-set","title":"Weber set","text":"<p>The Weber set is the convex hull of marginal vectors. The exact generator has size \\(n!\\), so:</p> <ul> <li>for small \\(n\\): use <code>WeberSet.points()</code> and <code>WeberSet.poly</code> (when <code>n in {2,3}</code>),</li> <li>for larger \\(n\\): use <code>WeberSet.sample_points(...)</code> and treat the result as a point cloud (not an exact polytope).</li> </ul>"},{"location":"guides/performance/#backends-and-dependencies","title":"Backends and dependencies","text":"<ul> <li>LP routines depend on a backend (recommended: SciPy/HiGHS). See <code>guides/lp_backends.md</code>.</li> <li>Some performance-sensitive routines use NumPy when available (extra <code>tucoopy[fast]</code>).</li> </ul>"},{"location":"guides/performance/#checklist-what-to-do-when-things-get-slow","title":"Checklist: what to do when things get slow","text":"<ol> <li>Check whether the game is complete/tabular (when the routine assumes it).</li> <li>Reduce <code>max_players</code> / <code>max_dim</code> / <code>max_points</code>.</li> <li>Replace vertices with sampling (<code>sample_points_*</code>) and approximate projection.</li> <li>If there is LP, confirm SciPy is installed and being used.</li> </ol>"},{"location":"guides/quickstart/","title":"Quickstart","text":""},{"location":"guides/quickstart/#installation","title":"Installation","text":"<p>Basic install (without optional heavy dependencies):</p> <pre><code>pip install tucoopy\n</code></pre> <p>Optional extras:</p> <ul> <li>LP-based methods (least-core / nucleolus / balancedness / bargaining set):   <pre><code>pip install \"tucoopy[lp]\"\n</code></pre></li> <li>Alternative LP backend (PuLP):   <pre><code>pip install \"tucoopy[lp_alt]\"\n</code></pre></li> <li>NumPy-based speedups (kernel / prekernel and some utilities):   <pre><code>pip install \"tucoopy[fast]\"\n</code></pre></li> <li>Simple 2-3 player Matplotlib visualizations:   <pre><code>pip install \"tucoopy[viz]\"\n</code></pre></li> </ul>"},{"location":"guides/quickstart/#building-a-tu-game","title":"Building a TU game","text":"<p>Coalitions are stored internally as bitmasks, but you can define games using \"Pythonic\" coalition keys:</p> <pre><code>from tucoopy import Game\n\ng = Game.from_coalitions(\n    n_players=3,\n    values={\n        (): 0.0,\n        (0,): 1.0,\n        (1,): 1.2,\n        (2,): 0.8,\n        (0, 1): 2.8,\n        (0, 2): 2.2,\n        (1, 2): 2.0,\n        (0, 1, 2): 4.0,\n    },\n)\n</code></pre>"},{"location":"guides/quickstart/#computing-a-solution","title":"Computing a solution","text":"<pre><code>from tucoopy.solutions import shapley_value\n\nphi = shapley_value(g)\nprint(phi)\n</code></pre>"},{"location":"guides/quickstart/#generating-an-animation-spec-python-js-contract","title":"Generating an animation spec (Python -&gt; JS contract)","text":"<pre><code>from tucoopy.io.animation_spec import build_animation_spec\n\nspec = build_animation_spec(\n    g,\n    series_id=\"shapley\",\n    allocations=[phi] * 60,\n    dt=1 / 30,\n    series_description=\"Shapley value (static).\",\n    include_analysis=True,\n)\nprint(spec.to_json())\n</code></pre> <p>More runnable scripts live in <code>packages/tucoopy/examples/</code>.</p>"},{"location":"guides/vizualization/","title":"Visualization (Matplotlib)","text":"<p><code>tucoopy</code> includes a small static visualization helper in <code>tucoopy.viz</code> (optional dependency: <code>tucoopy[viz]</code>).</p> <ul> <li>For \\(n=2\\): segments in the \\((x_1, x_2)\\) plane</li> <li>For \\(n=3\\): ternary diagram (simplex)</li> </ul> <p>See <code>../library/viz.md</code> and the API reference under <code>../reference/viz/mpl2.md</code> and <code>../reference/viz/mpl3.md</code>.</p>"},{"location":"library/api/","title":"API map","text":"<p>The public API is intentionally restricted:</p> <ul> <li><code>import tucoopy</code> is a small, stable convenience surface.</li> <li>Most functionality lives in the canonical subpackages:</li> <li><code>tucoopy.base</code></li> <li><code>tucoopy.games</code></li> <li><code>tucoopy.solutions</code></li> <li><code>tucoopy.geometry</code></li> <li><code>tucoopy.transforms</code></li> <li><code>tucoopy.properties</code></li> <li><code>tucoopy.power</code></li> <li><code>tucoopy.io</code></li> <li><code>tucoopy.backends</code></li> <li><code>tucoopy.viz</code></li> </ul>"},{"location":"library/api/#stable-top-level-tucoopy","title":"Stable top-level (<code>tucoopy</code>)","text":"<pre><code>from tucoopy import Game, glove_game, mask_from_players, nucleolus, shapley_value, weighted_voting_game\n</code></pre> <p>Notes:</p> <ul> <li><code>nucleolus()</code> is optional (it requires SciPy at runtime when called).</li> <li>Core vertices are intended for small <code>n</code> (for visualization use).</li> </ul>"},{"location":"library/api/#canonical-subpackages","title":"Canonical subpackages","text":""},{"location":"library/api/#tucoopybase","title":"<code>tucoopy.base</code>","text":"<p>Game representations + IO-friendly helpers:</p> <ul> <li>Coalition helpers: <code>all_coalitions</code>, <code>subcoalitions</code>, <code>players</code>, <code>size</code>, <code>grand_coalition</code>, <code>mask_from_players</code></li> <li>Games: <code>Game</code>, <code>TabularGame</code>, <code>ValueFunctionGame</code></li> </ul>"},{"location":"library/api/#tucoopyproperties","title":"<code>tucoopy.properties</code>","text":"<p>Properties / recognizers:</p> <ul> <li><code>is_convex</code>, <code>is_concave</code></li> <li><code>is_essential</code>, <code>is_monotone</code>, <code>is_normalized</code>, <code>is_superadditive</code></li> <li><code>is_simple_game</code>, <code>validate_simple_game</code>, <code>is_weighted_voting_game</code></li> <li><code>balancedness_check</code> (LP)</li> </ul>"},{"location":"library/api/#tucoopyio","title":"<code>tucoopy.io</code>","text":"<p>JSON helpers + animation spec:</p> <ul> <li>Dataclasses: <code>AnimationSpec</code>, <code>GameSpec</code>, <code>SeriesSpec</code>, <code>FrameSpec</code></li> <li>Helpers: <code>game_to_spec</code>, <code>series_from_allocations</code>, <code>build_animation_spec</code></li> <li>JSON (games): <code>game_to_dict</code>, <code>game_from_dict</code></li> </ul>"},{"location":"library/api/#tucoopybackends","title":"<code>tucoopy.backends</code>","text":"<p>Adapters for optional dependencies:</p> <ul> <li>LP adapter: <code>tucoopy.backends.lp.linprog_solve</code></li> <li>NumPy helper: <code>tucoopy.backends.numpy_fast.require_numpy</code></li> </ul>"},{"location":"library/api/#tucoopygames","title":"<code>tucoopy.games</code>","text":"<p>Classic games / generators:</p> <ul> <li><code>glove_game</code></li> <li><code>weighted_voting_game</code></li> <li><code>airport_game</code></li> <li><code>bankruptcy_game</code></li> <li><code>savings_game</code></li> <li><code>unanimity_game</code></li> <li><code>apex_game</code></li> </ul>"},{"location":"library/api/#tucoopysolutions","title":"<code>tucoopy.solutions</code>","text":"<p>Solution concepts:</p> <ul> <li>Values: <code>shapley_value</code>, <code>banzhaf_value</code>, <code>normalized_banzhaf_value</code></li> <li>Nucleolus family (SciPy): <code>least_core</code>, <code>nucleolus</code>, <code>prenucleolus</code> (+ result dataclasses)</li> <li>Kernel family (NumPy): <code>kernel</code>, <code>prekernel</code> (+ result dataclasses)</li> <li>\\(\\tau\\) value helpers: <code>tau_value</code>, <code>utopia_payoff</code>, <code>minimal_rights</code></li> </ul>"},{"location":"library/api/#tucoopygeometry","title":"<code>tucoopy.geometry</code>","text":"<p>Geometry for visualization:</p> <ul> <li>Core: <code>Core(game).vertices()</code> (small <code>n</code>)</li> <li>Excess / checks: <code>excesses</code>, <code>max_excess</code>, <code>tight_coalitions</code>, <code>is_in_core</code>, <code>is_in_epsilon_core</code>, <code>is_imputation</code>, <code>is_efficient</code></li> <li>Imputation set: <code>imputation_lower_bounds</code>, <code>is_in_imputation_set</code>, <code>project_to_imputation</code>, <code>ImputationSet(game).vertices()</code></li> <li>\\(\\epsilon\\)-core: <code>EpsilonCore(game, eps).poly</code>, <code>EpsilonCore(game, eps).vertices()</code>, <code>least_core_polytope</code></li> <li>Weber set: <code>marginal_vector</code>, <code>weber_marginal_vectors</code>, <code>weber_sample</code></li> <li>Bargaining set (SciPy): <code>bargaining_set_check</code>, <code>bargaining_set_sample</code>, <code>is_in_bargaining_set</code></li> <li>Balancedness (SciPy): <code>balancedness_check</code> (+ result dataclass)</li> </ul>"},{"location":"library/api/#tucoopypower","title":"<code>tucoopy.power</code>","text":"<ul> <li>Voting indices: <code>shapley_shubik_index</code>, <code>banzhaf_index</code></li> <li>DP-based indices (integer weights): <code>shapley_shubik_index_weighted_voting</code>, <code>banzhaf_index_weighted_voting</code></li> </ul>"},{"location":"library/api/#tucoopytransforms","title":"<code>tucoopy.transforms</code>","text":"<p>Transforms / representations:</p> <ul> <li><code>to_dense_values</code></li> <li><code>mobius_transform</code>, <code>inverse_mobius_transform</code></li> <li><code>harsanyi_dividends</code></li> </ul>"},{"location":"library/games/","title":"Geretating Games","text":""},{"location":"library/games/#game-generators","title":"Game generators","text":"<p>This page lists the generators in <code>tucoopy.games</code>.</p>"},{"location":"library/games/#see-also","title":"See also","text":"<ul> <li>API Reference -&gt; games: <code>../reference/index.md</code></li> </ul>"},{"location":"library/games/#tu-generators-selected","title":"TU generators (selected)","text":"<ul> <li>Glove game: <code>../reference/games/glove.md</code></li> <li>Weighted voting: <code>../reference/games/weighted_voting.md</code></li> <li>Unanimity: <code>../reference/games/unanimity.md</code></li> <li>Airport: <code>../reference/games/airport.md</code></li> <li>Bankruptcy: <code>../reference/games/bankruptcy.md</code></li> <li>Savings: <code>../reference/games/savings.md</code></li> <li>Apex: <code>../reference/games/apex.md</code></li> </ul>"},{"location":"library/games/#optimization-games-cost-allocation","title":"Optimization games (cost / allocation)","text":"<ul> <li>Assignment: <code>../reference/games/assignment.md</code></li> <li>Flow: <code>../reference/games/flow.md</code></li> <li>MST: <code>../reference/games/mst.md</code></li> </ul>"},{"location":"library/games/#other","title":"Other","text":"<ul> <li>Additive (basic): <code>../reference/games/additive.md</code></li> </ul>"},{"location":"library/geometry/","title":"Geometry","text":""},{"location":"library/geometry/#geometry-set-valued","title":"Geometry (set-valued)","text":"<p>This page is a map of the <code>tucoopy.geometry</code> subpackage.</p> <p>The focus here is orientation: what each set represents and where to find the API docs, without rewriting docstrings.</p>"},{"location":"library/geometry/#see-also","title":"See also","text":"<ul> <li>API Reference -&gt; geometry: <code>../reference/index.md</code></li> <li><code>PolyhedralSet</code> (base): <code>../reference/geometry/polyhedron.md</code></li> </ul>"},{"location":"library/geometry/#main-sets","title":"Main sets","text":""},{"location":"library/geometry/#imputationset","title":"ImputationSet","text":"<ul> <li>Class: <code>../reference/geometry/imputation_set.md</code></li> </ul>"},{"location":"library/geometry/#core-epsiloncore-leastcore","title":"Core / EpsilonCore / LeastCore","text":"<ul> <li>Core: <code>../reference/geometry/core_set.md</code></li> <li>Epsilon-core: <code>../reference/geometry/epsilon_core_set.md</code></li> <li>Least-core (as a set): <code>../reference/geometry/least_core_set.md</code></li> </ul>"},{"location":"library/geometry/#corecover-reasonableset","title":"CoreCover / ReasonableSet","text":"<ul> <li>Core cover: <code>../reference/geometry/core_cover_set.md</code></li> <li>Reasonable set: <code>../reference/geometry/reasonable_set.md</code></li> </ul>"},{"location":"library/geometry/#kernelset-bargainingset-sampling","title":"KernelSet / BargainingSet (sampling)","text":"<ul> <li>Kernel set: <code>../reference/geometry/kernel_set.md</code></li> <li>Bargaining set: <code>../reference/geometry/bargaining_set.md</code></li> </ul>"},{"location":"library/geometry/#weberset","title":"WeberSet","text":"<p>The Weber set is the convex hull of marginal vectors (V-rep). For visualization, the API may provide vertices/points for small <code>n</code>.</p> <ul> <li>Weber set: <code>../reference/geometry/weber_set.md</code></li> </ul>"},{"location":"library/geometry/#utilities","title":"Utilities","text":"<ul> <li>Sampling: <code>../reference/geometry/sampling.md</code></li> <li>Projection: <code>../reference/geometry/projection.md</code></li> </ul>"},{"location":"library/power/","title":"Power Index","text":""},{"location":"library/power/#power-indices-simple-games-voting","title":"Power indices (simple games / voting)","text":"<p>This subpackage contains classic power indices for simple games, especially voting games.</p>"},{"location":"library/power/#see-also","title":"See also","text":"<ul> <li>API Reference -&gt; power: <code>../reference/index.md</code></li> </ul>"},{"location":"library/power/#main-indices","title":"Main indices","text":"<ul> <li>Shapley-Shubik index: <code>../reference/power/shapley_shubik.md</code></li> <li>Banzhaf index: <code>../reference/power/banzhaf.md</code></li> <li>Rae index: <code>../reference/power/rae.md</code></li> <li>Holler (public good) index: <code>../reference/power/holler.md</code></li> <li>Deegan-Packel index: <code>../reference/power/deegan_packel.md</code></li> <li>Johnston index: <code>../reference/power/johnston.md</code></li> <li>Coleman indices: <code>../reference/power/coleman.md</code></li> </ul>"},{"location":"library/power/#variants-when-applicable","title":"Variants (when applicable)","text":"<ul> <li>Egalitarian Shapley: <code>../reference/power/egalitarian_shapley.md</code></li> <li>Solidarity: <code>../reference/power/solidarity.md</code></li> <li>Koenig-Brauninger: <code>../reference/power/koenig_brauninger.md</code></li> </ul>"},{"location":"library/solutions/","title":"Solutions","text":""},{"location":"library/solutions/#solutions-point-valued","title":"Solutions (point-valued)","text":"<p>This page is a map of the <code>tucoopy.solutions</code> package.</p> <p>Goal: explain where to look for each concept, without duplicating the API docstrings. For full details (signatures, examples, parameters), use the API Reference section.</p>"},{"location":"library/solutions/#see-also","title":"See also","text":"<ul> <li>API Reference -&gt; solutions: <code>../reference/index.md</code></li> <li><code>tucoopy.solutions</code> (API): <code>../reference/solutions/shapley.md</code></li> </ul>"},{"location":"library/solutions/#contents","title":"Contents","text":""},{"location":"library/solutions/#axiomatic-marginal-values","title":"Axiomatic / marginal values","text":"<ul> <li>Shapley: <code>../reference/solutions/shapley.md</code></li> <li>Banzhaf (value): <code>../reference/solutions/banzhaf.md</code></li> </ul>"},{"location":"library/solutions/#lp-based-solutions-optional-deps","title":"LP-based solutions (optional deps)","text":"<p>Warning Modules like <code>nucleolus</code> / <code>modiclus</code> require an LP backend at runtime (recommended: <code>pip install \"tucoopy[lp]\"</code>).</p> <ul> <li>Least-core (set): <code>../reference/geometry/least_core_set.md</code></li> <li>Nucleolus: <code>../reference/solutions/nucleolus.md</code></li> <li>Modiclus: <code>../reference/solutions/modiclus.md</code></li> </ul>"},{"location":"library/solutions/#other","title":"Other","text":"<ul> <li>Tau value: <code>../reference/solutions/tau.md</code></li> <li>Gately point: <code>../reference/solutions/gately.md</code></li> <li>Dispatch (solve): <code>../reference/solutions/solve.md</code></li> </ul>"},{"location":"library/structure/","title":"tucoopy structure","text":"<p>This package is organized to keep the public API explicit, small, and easy to navigate.</p>"},{"location":"library/structure/#canonical-modules","title":"Canonical modules","text":"<ul> <li><code>tucoopy.base</code></li> <li> <p>fundamental structures (<code>Coalition</code> bitmask, <code>Game</code>)</p> </li> <li> <p><code>tucoopy.properties</code></p> </li> <li> <p>properties / recognizers</p> </li> <li> <p><code>tucoopy.io</code></p> </li> <li> <p>JSON IO + animation spec helpers (shared contract with the JS package)</p> </li> <li> <p><code>tucoopy.backends</code></p> </li> <li> <p>adapters for optional dependencies (LP, NumPy, ...)</p> </li> <li> <p><code>tucoopy.power</code></p> </li> <li> <p>power indices (voting / simple games)</p> </li> <li> <p><code>tucoopy.solutions</code></p> </li> <li> <p>solution concepts (Shapley, Banzhaf, ...)</p> </li> <li> <p><code>tucoopy.transforms</code></p> </li> <li> <p>representations / transforms (e.g. Harsanyi dividends)</p> </li> <li> <p><code>tucoopy.geometry</code></p> </li> <li>geometric objects/operations used for visualization (e.g. core vertices)</li> </ul>"},{"location":"library/structure/#import-rules-restricted","title":"Import rules (restricted)","text":"<ul> <li>Internal code should import from the canonical modules above.</li> <li>Public re-exports live in:</li> <li>each subpackage's <code>__init__.py</code> (e.g. <code>tucoopy.geometry.__init__</code>)</li> <li>the top-level <code>tucoopy/__init__.py</code>, for convenience</li> </ul> <p>Avoid introducing extra module \"shims\"/shortcuts like <code>tucoopy/core.py</code>: that makes the package harder to navigate.</p>"},{"location":"library/transforms/","title":"Transformations","text":""},{"location":"library/transforms/#transforms","title":"Transforms","text":"<p><code>tucoopy.transforms</code> contains transforms that change the game representation or derive new games from a base game.</p>"},{"location":"library/transforms/#see-also","title":"See also","text":"<ul> <li>API Reference -&gt; transforms: <code>../reference/index.md</code></li> </ul>"},{"location":"library/transforms/#bases-and-decompositions","title":"Bases and decompositions","text":"<ul> <li>Mobius transform: <code>../reference/transforms/mobius.md</code></li> <li>Harsanyi dividends: <code>../reference/transforms/harsanyi.md</code></li> </ul>"},{"location":"library/transforms/#algebra-combination","title":"Algebra / combination","text":"<ul> <li>Algebra (scale/shift/normalize): <code>../reference/transforms/algebra.md</code></li> <li>Combine (sum/subtract): <code>../reference/transforms/combine.md</code></li> </ul>"},{"location":"library/transforms/#derived-restrictions","title":"Derived / restrictions","text":"<ul> <li>Derived games (dual/subgame/etc): <code>../reference/transforms/derived.md</code></li> <li>Communication restriction (Myerson): <code>../reference/transforms/communication.md</code></li> </ul>"},{"location":"library/viz/","title":"Visualization","text":""},{"location":"library/viz/#visualization","title":"Visualization","text":"<p>The <code>tucoopy.viz</code> subpackage provides static visualization (Matplotlib) for:</p> <ul> <li>\\(n=2\\): line segments in the plane \\((x_1, x_2)\\)</li> <li>\\(n=3\\): ternary diagram (simplex)</li> </ul>"},{"location":"library/viz/#see-also","title":"See also","text":"<ul> <li>Guide: <code>../guides/vizualization.md</code></li> <li>API Reference -&gt; viz: <code>../reference/index.md</code></li> </ul> <p>Warning Matplotlib is an optional dependency. Install with <code>pip install \"tucoopy[viz]\"</code>.</p>"},{"location":"library/viz/#api","title":"API","text":"<ul> <li><code>mpl2</code> (segments): <code>../reference/viz/mpl2.md</code></li> <li><code>mpl3</code> (ternary): <code>../reference/viz/mpl3.md</code></li> </ul>"},{"location":"project/contributions/","title":"Contributing","text":""},{"location":"project/contributions/#contributing","title":"Contributing","text":"<p>This document describes a simple workflow for contributing to <code>tucoopy</code>.</p>"},{"location":"project/contributions/#setup-dev","title":"Setup (dev)","text":"<p>Recommended: create a virtual environment at the repo root and install the package in editable mode.</p> <pre><code>python -m venv .venv\n</code></pre> <p>Activate the environment and install with dev/docs extras:</p> <pre><code>pip install -e \".[dev,docs]\"\n</code></pre> <p>Optional extras:</p> <ul> <li><code>lp</code>: <code>pip install -e \".[lp]\"</code> (SciPy; enables LP-based methods)</li> <li><code>lp_alt</code>: <code>pip install -e \".[lp_alt]\"</code> (PuLP; fallback)</li> <li><code>fast</code>: <code>pip install -e \".[fast]\"</code> (NumPy; speedups)</li> <li><code>viz</code>: <code>pip install -e \".[viz]\"</code> (Matplotlib; static visualization)</li> </ul>"},{"location":"project/contributions/#running-local-checks","title":"Running local checks","text":""},{"location":"project/contributions/#tests","title":"Tests","text":"<pre><code>pytest -q\n</code></pre>"},{"location":"project/contributions/#type-checking","title":"Type checking","text":"<pre><code>mypy src/tucoopy\n</code></pre>"},{"location":"project/contributions/#docs-mkdocs","title":"Docs (MkDocs)","text":"<p>Build the Portuguese docs:</p> <pre><code>mkdocs build -f mkdocs.pt.yml --dirty\n</code></pre> <p>Build the English docs:</p> <pre><code>mkdocs build -f mkdocs.yml --dirty\n</code></pre>"},{"location":"project/contributions/#quality-rules-project","title":"Quality rules (project)","text":"<ul> <li>Avoid duplication: keep one source of truth per concept/module.</li> <li>Avoid shims/aliases for \"compatibility\": prefer canonical imports.</li> <li>Prefer docstrings in NumPy style (as configured in mkdocstrings).</li> </ul>"},{"location":"project/contributions/#windowsonedrive","title":"Windows/OneDrive","text":"<p>If you are developing inside OneDrive, see:</p> <ul> <li><code>../guides/dev_windows_onedrive.md</code></li> </ul>"},{"location":"project/contributions/#pull-requests","title":"Pull requests","text":"<p>Before opening a PR:</p> <ul> <li>run <code>pytest</code> and <code>mypy</code>;</li> <li>validate <code>mkdocs build</code> (EN/PT) if you touched docs/docstrings;</li> <li>describe API impact and changes to optional extras/dependencies when applicable.</li> </ul>"},{"location":"project/deprecation/","title":"Deprecation policy","text":"<p>This document defines how <code>tucoopy</code> (Python) handles API changes.</p>"},{"location":"project/deprecation/#goal","title":"Goal","text":"<ul> <li>Avoid drift and repeated refactors.</li> <li>Provide predictability for users and for the documentation.</li> </ul>"},{"location":"project/deprecation/#versions-0x","title":"Versions <code>0.x</code>","text":"<p>The project is in an alpha phase (<code>0.x</code>):</p> <ul> <li>Breaking API changes may still happen.</li> <li>Still, we try to deprecate before removing when it does not add too much cost.</li> </ul>"},{"location":"project/deprecation/#recommended-process-when-possible","title":"Recommended process (when possible)","text":"<ol> <li>Mark as deprecated</li> <li>Document in the changelog.</li> <li>Update docs (reference page, examples).</li> <li>Emit a warning</li> <li>Use <code>DeprecationWarning</code> (or a specific exception) only when it makes sense.</li> <li>Remove</li> <li>Prefer removing in the next \"minor\" (e.g. <code>0.2.0</code>), or at most in <code>+2</code> releases.</li> </ol>"},{"location":"project/deprecation/#ghost-files-and-duplicates","title":"\"Ghost files\" and duplicates","text":"<p>Empty files (or files with <code># delete</code>) should not remain:</p> <ul> <li>Prefer actually removing them.</li> <li>If removal is not possible (environment constraints), keep a module that:</li> <li>fails on import with an explicit error, and</li> <li>explains the replacement (new path / new source-of-truth layer).</li> </ul>"},{"location":"project/deprecation/#json-contract-compatibility","title":"JSON contract compatibility","text":"<p>Compatibility should be maintained at the JSON contract level (<code>tucoopy.io.schema</code>), not via module shims/aliases.</p>"},{"location":"project/js_vs_python/","title":"JS vs Python (renderer vs library)","text":"<p>Historically, this project used a \"Python produces JSON, JS renders it\" split.</p> <p>In this repository you will find the Python library (<code>tucoopy</code>) and the JSON schemas used by <code>tucoopy.io</code>:</p> <ul> <li><code>src/tucoopy/io/schemas/tucoop-animation.schema.json</code></li> <li><code>src/tucoopy/io/schemas/tucoop-game.schema.json</code></li> </ul> <p>The main compatibility boundary is the JSON contract (schemas), not internal architecture.</p>"},{"location":"project/js_vs_python/#what-the-browser-side-renderer-typically-does","title":"What the browser-side renderer typically does","text":"<p>A (separate) JS/TS renderer can:</p> <ul> <li>validate specs against the schema;</li> <li>render allocations/sets/diagnostics (Canvas/SVG);</li> <li>optionally derive \"cheap\" analysis for very small <code>n</code> (when feasible).</li> </ul>"},{"location":"project/js_vs_python/#what-should-stay-in-python","title":"What should stay in Python","text":"<p>Rule of thumb: anything that depends on LP or is numerically delicate should be computed in Python.</p> <p>Typical examples:</p> <ul> <li>least-core, nucleolus, modiclus (LP)</li> <li>balancedness (Bondareva-Shapley via LP)</li> <li>bargaining set (expensive; sampling/LP)</li> <li>kernel/pre-kernel (iterative; numerically sensitive)</li> <li>vertex enumeration and higher-dimensional projections</li> </ul> <p>A reasonable pipeline is:</p> <ol> <li>Run Python to compute <code>analysis</code> (solutions, sets, diagnostics).</li> <li>Export the JSON spec.</li> <li>The renderer only renders and optionally fills in missing cheap pieces for very small <code>n</code>.</li> </ol>"},{"location":"project/js_vs_python/#see-also","title":"See also","text":"<ul> <li><code>../guides/animation_spec.md</code> (how to generate specs in Python)</li> <li><code>../guides/analysis_contract.md</code> (what goes into <code>analysis</code>)</li> </ul>"},{"location":"project/public_api/","title":"Public API (minimal contract)","text":"<p>This document defines the minimal public contract of <code>tucoopy</code> (Python). It exists to reduce churn: the imports listed here should remain stable.</p>"},{"location":"project/public_api/#general-rule","title":"General rule","text":"<ul> <li>The top-level <code>tucoopy</code> is small and serves as an entry point.</li> <li>The full surface lives in subpackages (<code>tucoopy.geometry</code>, <code>tucoopy.solutions</code>, etc.).</li> <li>If something is not documented here, it may change more freely (especially in <code>0.x</code>).</li> </ul>"},{"location":"project/public_api/#canonical-imports-stable","title":"Canonical imports (stable)","text":"<p>Recommended for users:</p> <pre><code>from tucoopy import Game\nfrom tucoopy.games import weighted_voting_game\nfrom tucoopy.solutions import shapley_value, nucleolus\nfrom tucoopy.geometry import Core, EpsilonCore, LeastCore\nfrom tucoopy.power import banzhaf_index, shapley_shubik_index\n</code></pre>"},{"location":"project/public_api/#top-level-tucoopy","title":"Top-level (<code>tucoopy</code>)","text":"<p>The top-level should expose only a few high-level items (convenience). Everything else should be imported from subpackages.</p> <p>Currently exposed:</p> <ul> <li><code>Game</code></li> <li><code>mask_from_players</code></li> <li><code>glove_game</code>, <code>weighted_voting_game</code></li> <li><code>Core</code></li> <li><code>shapley_value</code></li> <li><code>nucleolus</code> (requires an LP backend at runtime when called)</li> </ul>"},{"location":"project/public_api/#subpackages-source-of-truth","title":"Subpackages (source of truth)","text":"<ul> <li><code>tucoopy.base</code>: primitives (coalitions, games, config, types/exceptions)</li> <li><code>tucoopy.games</code>: classic game generators</li> <li><code>tucoopy.solutions</code>: point solutions (payoff vectors)</li> <li><code>tucoopy.geometry</code>: sets/polyhedra (core, least-core, etc.)</li> <li><code>tucoopy.diagnostics</code>: checks and explanations (per set / per allocation)</li> <li><code>tucoopy.power</code>: power indices for simple games/voting</li> <li><code>tucoopy.transforms</code>: transforms and representations</li> <li><code>tucoopy.io</code>: JSON specs and schemas</li> <li><code>tucoopy.backends</code>: adapters for optional dependencies</li> </ul>"},{"location":"project/public_api/#what-is-experimental","title":"What is experimental?","text":"<p>While the project is in <code>0.x</code>, we consider the following more subject to change:</p> <ul> <li>diagnostic details (additional fields, internal structures);</li> <li>LP implementations and detailed solver explanations;</li> <li>some visualization and sampling utilities.</li> </ul> <p>When a feature moves from \"experimental\" to \"stable\", it should:</p> <ul> <li>have a complete docstring (NumPy style),</li> <li>have unit tests,</li> <li>be added to this document.</li> </ul>"},{"location":"project/references/","title":"References","text":"<p>These are the main references this project aligns with (notation/definitions vary by source).</p>"},{"location":"project/references/#books-core-references","title":"Books (core references)","text":"<ul> <li>Moulin, H. Axioms of Cooperative Decision Making.</li> <li>Peleg, Bezalel, and Peter Sudholter. 2007. Introduction to the Theory of Cooperative Games. 2nd ed. Springer. DOI: https://doi.org/10.1007/978-3-540-72945-7</li> <li>Broad coverage of cooperative games with and without transferable utility (TU/NTU).</li> <li>Chakravarty, Satya R., Manipushpak Mitra, and Palash Sarkar. 2014. A Course on Cooperative Game Theory. Cambridge University Press. DOI: https://doi.org/10.1017/CBO9781107415997</li> <li>A comprehensive introduction with many examples and exercises.</li> <li>Branzei, Rodica; Tijs, Stef; Dimitrov, Dinko. 2008. Models in Cooperative Game Theory. 2nd ed. Springer.</li> <li>Mathematical models for TU and NTU games, with applications in economics and social sciences.</li> <li>Driessen, Theo. 1988. Cooperative Games, Solutions and Applications. Springer. DOI: https://doi.org/10.1007/978-94-015-7787-8</li> <li>Classic text on solution concepts (core, nucleolus, \\(\\tau\\) value, etc.).</li> <li>Aumann, Robert J., &amp; Hart, Sergiu (eds.). Handbook of Game Theory with Economic Applications.</li> <li>Volumes 1-2 contain extensive chapters on cooperative game theory; volumes 3-4 also contain relevant sections.</li> <li>Chalkiadakis, Georgios; Elkind, Edith; Wooldridge, Michael J. 2012. Computational Aspects of Cooperative Game Theory. Morgan &amp; Claypool.</li> <li>Focus on computational aspects, complexity, representations, and algorithms.</li> </ul>"},{"location":"project/references/#classic-papers-concepts","title":"Classic papers / concepts","text":"<ul> <li>Shapley value (1953): original axiomatization.</li> <li>Bondareva-Shapley theorem (balancedness / non-emptiness of the core).</li> <li>Schmeidler's nucleolus (1969).</li> </ul> <p>Notes:</p> <ul> <li>In the docs, we cite these sources at the point of use and keep this page as a central bibliography.</li> </ul>"},{"location":"project/roadmap/","title":"Roadmap (reset)","text":"<p>This roadmap was reset to start a new phase of the project (product release). Use the checkboxes to track progress.</p>"},{"location":"project/roadmap/#legend","title":"Legend","text":"<ul> <li><code>[x]</code> done</li> <li><code>[ ]</code> pending</li> <li><code>(*)</code> optional / later</li> </ul>"},{"location":"project/roadmap/#1-mvp-minimal-theory-stability","title":"1) MVP (minimal theory + stability)","text":"<ul> <li> Define MVP scope (what's in / what's out)</li> <li> Lock down a \"minimal public API\" and canonical imports</li> <li> Review numerics / tolerances (document <code>tol</code> and limits)</li> <li> Review error messages (baseline + optional extras)</li> <li> Review the JSON contract (schemas + examples)</li> </ul>"},{"location":"project/roadmap/#2-docs-release","title":"2) Docs (release)","text":"<ul> <li> Review theory pages (minimal theory)</li> <li> Review guides (quickstart, diagnostics, large games, performance)</li> <li> Review the examples page (more short, canonical examples)</li> <li> Review API reference (mkdocstrings): docstrings with examples where it makes sense</li> <li> Check MkDocs navigation (complete nav, no orphan pages)</li> </ul>"},{"location":"project/roadmap/#3-quality-ci-tests","title":"3) Quality (CI + tests)","text":"<ul> <li> Run <code>pytest</code> on Windows and Linux (CI)</li> <li> Run <code>mypy</code> on Windows and Linux (CI)</li> <li> Run <code>mkdocs build</code> (EN + PT) as part of CI</li> <li> Increase coverage in higher-risk areas (LP/geometry/diagnostics)</li> <li> Evaluate parallelization (hotspots in coalition loops, sampling, excess scans)</li> </ul>"},{"location":"project/roadmap/#4-product-packaging","title":"4) Product (packaging)","text":"<ul> <li> Review <code>pyproject.toml</code> (extras, classifiers, python_requires)</li> <li> Review Python package README (short, with a \"feature -&gt; extra\" table)</li> <li> Review <code>CHANGELOG.md</code> (minimal for release)</li> <li> Prepare release checklist (tag, build, publish)</li> </ul>"},{"location":"project/roadmap/#5-later-do-not-block-the-release","title":"5) Later (do not block the release)","text":"<ul> <li> (*) Translate docs to EN</li> <li> (*) Optional integration with a polyhedron backend (cddlib/polymake) for <code>n&gt;3</code></li> <li> (*) More solutions/sets (as needed)</li> <li> (*) Parallelization: implement via <code>concurrent.futures</code> (process) for naturally independent tasks (permutations, coalitions, sampling), controlled by <code>max_workers</code></li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>API reference pages generated from docstrings via <code>mkdocstrings</code>.</p> <p>Tip: use the sidebar to navigate by module.</p>"},{"location":"reference/base/coalition/","title":"<code>tucoopy.base.coalition</code>","text":""},{"location":"reference/base/coalition/#tucoopy.base.coalition--coalition-bitmask-utilities","title":"Coalition (bitmask) utilities.","text":"<p>In <code>tucoopy</code>, a coalition is represented as a non-negative integer bitmask:</p> <ul> <li>Player \\(i\\) corresponds to bit <code>(1 &lt;&lt; i)</code>.</li> <li>The empty coalition \\(\\varnothing\\) is <code>0</code>.</li> <li>The grand coalition \\(N\\) is <code>(1 &lt;&lt; n_players) - 1</code>.</li> </ul> <p>This convention is used across the package (games, solutions, geometry, and diagnostics) because it is compact and fast.</p> <p>The helpers in this module implement the basic iteration patterns needed by cooperative game algorithms:</p> <ul> <li>Iterate all coalitions: <code>all_coalitions</code></li> <li>Iterate subcoalitions (submasks): <code>subcoalitions</code></li> <li>Convert between bitmasks and player lists: <code>players</code>, <code>mask_from_players</code></li> <li>Efficiently compute coalition sums: <code>coalition_sum</code>, <code>coalition_sums</code></li> </ul> Notes <p>All functions assume 0-indexed players.</p> <p>Examples:</p> <p>Basic coalition encoding:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.coalition import mask_from_players, players\n&gt;&gt;&gt; S = mask_from_players([0, 2])  # players {0,2}\n&gt;&gt;&gt; S\n5\n&gt;&gt;&gt; players(S)\n[0, 2]\n</code></pre>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.all_coalitions","title":"all_coalitions","text":"<pre><code>all_coalitions(n_players)\n</code></pre> <p>Iterate over all coalitions of <code>n_players</code> as integer bitmasks.</p> <p>Coalitions are represented as bitmasks in the range</p> \\[ 0, 1, \\dots, 2^n - 1, \\] <p>where bit <code>i</code> indicates whether player \\(i\\) is in the coalition.</p> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players <code>n</code> (must be &gt;= 0).</p> required <p>Yields:</p> Type Description <code>Coalition</code> <p>Coalition bitmask (an <code>int</code>).</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>n_players &lt; 0</code>.</p> <p>Examples:</p> <p>All coalitions for <code>n=2</code>::</p> <pre><code>&gt;&gt;&gt; list(all_coalitions(2))\n[0, 1, 2, 3]\n</code></pre> Notes <p>The number of yielded masks is <code>2**n_players</code>.</p>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.coalition_sum","title":"coalition_sum","text":"<pre><code>coalition_sum(coalition, x, *, n_players)\n</code></pre> <p>Sum an allocation vector over a coalition.</p> <p>Computes:</p> \\[ x(S) = \\sum_{i \\in S} x_i. \\] <p>Parameters:</p> Name Type Description Default <code>coalition</code> <code>Coalition</code> <p>Coalition bitmask <code>S</code>.</p> required <code>x</code> <code>Iterable[float]</code> <p>Allocation vector (iterable of length <code>n_players</code>).</p> required <code>n_players</code> <code>int</code> <p>Number of players <code>n</code>. Used to validate the length of <code>x</code> and to decide which bits are considered.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The coalition sum <code>x(S)</code>.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>x</code> has length different from <code>n_players</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coalition_sum(0b101, [1.0, 2.0, 3.0], n_players=3)\n4.0\n&gt;&gt;&gt; coalition_sum(0, [1.0, 2.0], n_players=2)\n0.0\n</code></pre>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.coalition_sums","title":"coalition_sums","text":"<pre><code>coalition_sums(x, *, n_players)\n</code></pre> <p>Precompute coalition sums \\(x(S)\\) for all coalitions \\(S\\).</p> <p>Returns an array <code>out</code> of length <code>2**n_players</code> such that:</p> \\[ \\text{out}[S] = x(S) = \\sum_{i \\in S} x_i. \\] Implementation <p>Uses an \\(O(2^n)\\) dynamic program based on the least-significant bit:</p> \\[ x(S) = x(S \\setminus \\{i\\}) + x_i, \\] <p>where \\(i\\) is the index of the least-significant set bit of \\(S\\).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Iterable[float]</code> <p>Allocation vector (iterable of length <code>n_players</code>).</p> required <code>n_players</code> <code>int</code> <p>Number of players <code>n</code>.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>List <code>out</code> with <code>out[mask] = x(mask)</code> for all masks in <code>0..(1&lt;&lt;n_players)-1</code>.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>x</code> has length different from <code>n_players</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; out = coalition_sums([1.0, 2.0, 3.0], n_players=3)\n&gt;&gt;&gt; out[0]          # empty coalition\n0.0\n&gt;&gt;&gt; out[0b101]      # players {0,2}\n4.0\n&gt;&gt;&gt; out[0b111]      # grand coalition\n6.0\n</code></pre> Notes <p>This is a building block for excess/surplus computations, where many coalition sums are needed repeatedly.</p>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.grand_coalition","title":"grand_coalition","text":"<pre><code>grand_coalition(n_players)\n</code></pre> <p>Return the grand coalition mask <code>(1&lt;&lt;n) - 1</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players <code>n</code> (must be &gt;= 0).</p> required <p>Returns:</p> Type Description <code>Coalition</code> <p>Bitmask for the grand coalition (all players included).</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>n_players &lt; 0</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; grand_coalition(3)\n7\n&gt;&gt;&gt; bin(grand_coalition(4))\n'0b1111'\n</code></pre>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.mask_from_players","title":"mask_from_players","text":"<pre><code>mask_from_players(ps)\n</code></pre> <p>Build a coalition mask from an iterable of player indices.</p> <p>Parameters:</p> Name Type Description Default <code>ps</code> <code>Iterable[int]</code> <p>Iterable of player indices (each must be &gt;= 0).</p> required <p>Returns:</p> Type Description <code>Coalition</code> <p>Coalition bitmask.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If any player index is negative.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; mask_from_players([0, 2])\n5\n&gt;&gt;&gt; mask_from_players([])\n0\n</code></pre> Notes <p>Duplicate indices are harmless (bitwise OR).</p>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.players","title":"players","text":"<pre><code>players(coalition, *, n_players)\n</code></pre> <p>Convert a coalition mask to the sorted list of player indices.</p> <p>Parameters:</p> Name Type Description Default <code>coalition</code> <code>Coalition</code> <p>Coalition bitmask (must be &gt;= 0).</p> required <code>n_players</code> <code>int</code> <p>Number of players <code>n</code> (must be &gt;= 0). Bits above <code>n-1</code> are ignored.</p> required <p>Returns:</p> Type Description <code>list[int]</code> <p>Sorted list of player indices included in the coalition.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>coalition &lt; 0</code> or <code>n_players &lt; 0</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; players(0b101, n_players=3)\n[0, 2]\n&gt;&gt;&gt; players(0b101, n_players=2)  # ignores bit 2 because n_players=2\n[0]\n</code></pre>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.size","title":"size","text":"<pre><code>size(coalition)\n</code></pre> <p>Return the number of players in a coalition (popcount).</p> <p>Parameters:</p> Name Type Description Default <code>coalition</code> <code>Coalition</code> <p>Coalition bitmask (must be &gt;= 0).</p> required <p>Returns:</p> Type Description <code>int</code> <p>The coalition cardinality <code>|S|</code>.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>coalition &lt; 0</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; size(0b101)\n2\n&gt;&gt;&gt; size(0)\n0\n</code></pre>"},{"location":"reference/base/coalition/#tucoopy.base.coalition.subcoalitions","title":"subcoalitions","text":"<pre><code>subcoalitions(coalition)\n</code></pre> <p>Iterate over all subcoalitions \\(T \\subseteq S\\) of a coalition \\(S\\) (as submasks).</p> <p>This yields all submasks of \\(S\\) (including \\(S\\) itself and the empty coalition \\(\\varnothing\\)) using the classic bit-trick:</p> <pre><code>T = S\nwhile True:\n    yield T\n    if T == 0: break\n    T = (T - 1) &amp; S\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>coalition</code> <code>Coalition</code> <p>Coalition bitmask <code>S</code> (must be &gt;= 0).</p> required <p>Yields:</p> Type Description <code>Coalition</code> <p>Subcoalition bitmask <code>T</code>.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>coalition &lt; 0</code>.</p> <p>Examples:</p> <p>Subcoalitions of <code>S = 0b101</code> (players {0,2})::</p> <pre><code>&gt;&gt;&gt; list(subcoalitions(0b101))\n[5, 4, 1, 0]\n</code></pre> Notes <ul> <li>The order is descending by construction (starting at <code>S</code> down to <code>0</code>).</li> <li>Number of yielded masks is <code>2**k</code> where <code>k = popcount(S)</code>.</li> </ul>"},{"location":"reference/base/config/","title":"<code>tucoopy.base.config</code>","text":""},{"location":"reference/base/config/#tucoopy.base.config--default-configurations-and-constants-for-the-tucoopy-package","title":"Default configurations and constants for the tucoopy package.","text":"<p>This module centralizes default values used throughout the library, such as tolerances and conservative limits for potentially expensive computations.</p> <p>Attributes:</p> Name Type Description <code>DEFAULT_TOL</code> <code>float</code> <p>Default tolerance for numerical checks.</p> <code>DEFAULT_MAX_PLAYERS</code> <code>int</code> <p>Default maximum number of players for some operations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.config import DEFAULT_TOL\n&gt;&gt;&gt; DEFAULT_TOL\n1e-9\n</code></pre>"},{"location":"reference/base/exceptions/","title":"<code>tucoopy.base.exceptions</code>","text":""},{"location":"reference/base/exceptions/#tucoopy.base.exceptions--shared-exception-types-for-tucoopy","title":"Shared exception types for <code>tucoopy</code>.","text":"<p>The project aims to raise a small set of well-named exceptions from core layers instead of leaking <code>ValueError</code>/<code>RuntimeError</code> everywhere. This makes it easier for users to catch and handle errors consistently.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import InvalidGameError\n&gt;&gt;&gt; try:\n...     raise InvalidGameError(\"bad game\")\n... except InvalidGameError as e:\n...     str(e)\n'bad game'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.BackendError","title":"BackendError","text":"<p>               Bases: <code>tucoopyError</code>, <code>RuntimeError</code></p> <p>Raised when a backend fails or violates its contract.</p> <p>This is typically used for failures in optional backends (LP, NumPy helpers), or when a backend returns an incomplete/invalid result structure.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import BackendError\n&gt;&gt;&gt; try:\n...     raise BackendError(\"backend failed\")\n... except BackendError as e:\n...     str(e)\n'backend failed'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.ConvergenceError","title":"ConvergenceError","text":"<p>               Bases: <code>tucoopyError</code>, <code>RuntimeError</code></p> <p>Raised when an iterative algorithm fails to converge within limits.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import ConvergenceError\n&gt;&gt;&gt; try:\n...     raise ConvergenceError(\"did not converge\")\n... except ConvergenceError as e:\n...     str(e)\n'did not converge'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.InvalidCoalitionError","title":"InvalidCoalitionError","text":"<p>               Bases: <code>tucoopyError</code>, <code>ValueError</code></p> <p>Raised when coalition inputs (bitmasks, player indices) are invalid.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import InvalidCoalitionError\n&gt;&gt;&gt; try:\n...     raise InvalidCoalitionError(\"invalid coalition mask\")\n... except InvalidCoalitionError as e:\n...     str(e)\n'invalid coalition mask'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.InvalidGameError","title":"InvalidGameError","text":"<p>               Bases: <code>tucoopyError</code>, <code>ValueError</code></p> <p>Raised when a game object is invalid or inconsistent.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; try:\n...     raise InvalidGameError(\"Invalid game\")\n... except InvalidGameError as e:\n...     print(type(e))\n&lt;class 'tucoopy.base.exceptions.InvalidGameError'&gt;\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.InvalidParameterError","title":"InvalidParameterError","text":"<p>               Bases: <code>tucoopyError</code>, <code>ValueError</code></p> <p>Raised when an API parameter is invalid (wrong value/range/shape).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import InvalidParameterError\n&gt;&gt;&gt; try:\n...     raise InvalidParameterError(\"bad parameter\")\n... except InvalidParameterError as e:\n...     str(e)\n'bad parameter'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.InvalidSpecError","title":"InvalidSpecError","text":"<p>               Bases: <code>tucoopyError</code>, <code>ValueError</code></p> <p>Raised when a JSON/spec-like object is invalid or inconsistent.</p> <p>This is typically raised by :mod:<code>tucoopy.io</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import InvalidSpecError\n&gt;&gt;&gt; try:\n...     raise InvalidSpecError(\"invalid spec\")\n... except InvalidSpecError as e:\n...     str(e)\n'invalid spec'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.MissingOptionalDependencyError","title":"MissingOptionalDependencyError","text":"<p>               Bases: <code>tucoopyError</code>, <code>ImportError</code></p> <p>Raised when an optional dependency is required but not installed.</p> <p>The error message should typically include the corresponding extra, e.g. <code>pip install \"tucoopy[lp]\"</code> or <code>pip install \"tucoopy[viz]\"</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import MissingOptionalDependencyError\n&gt;&gt;&gt; try:\n...     raise MissingOptionalDependencyError(\"install tucoopy[lp]\")\n... except MissingOptionalDependencyError as e:\n...     str(e)\n'install tucoopy[lp]'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.NotSupportedError","title":"NotSupportedError","text":"<p>               Bases: <code>tucoopyError</code>, <code>ValueError</code>, <code>NotImplementedError</code></p> <p>Raised when a requested operation is not supported by the implementation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.exceptions import NotSupportedError\n&gt;&gt;&gt; try:\n...     raise NotSupportedError(\"not implemented\")\n... except NotSupportedError as e:\n...     str(e)\n'not implemented'\n</code></pre>"},{"location":"reference/base/exceptions/#tucoopy.base.exceptions.tucoopyError","title":"tucoopyError","text":"<p>               Bases: <code>Exception</code></p> <p>Base error for tucoopy.</p> <p>This is the root exception for all errors raised by the tucoopy package.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; try:\n...     raise tucoopyError(\"Generic Error\")\n... except tucoopyError as e:\n...     print(type(e))\n&lt;class 'tucoopy.base.exceptions.tucoopyError'&gt;\n</code></pre>"},{"location":"reference/base/game/","title":"<code>tucoopy.base.game</code>","text":"<p>TU cooperative game defined by its characteristic function \\(v(S)\\).</p> <p>Coalitions are encoded as bitmasks over players \\(0 \\ldots n-1\\).</p> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players <code>n</code>.</p> required <code>v</code> <code>dict[int, float]</code> <p>Mapping from coalition masks (ints) or iterables of player indices to coalition values. Missing coalitions are treated as value 0.0 by :meth:<code>value</code>.</p> required <code>player_labels</code> <code>list[str] | None</code> <p>Optional display labels for players (length must match <code>n_players</code>).</p> <code>None</code> Notes <ul> <li>TU convention: \\(v( \\varnothing) = 0\\) is enforced.</li> <li>The grand coalition mask is <code>(1 &lt;&lt; n_players) - 1</code>.</li> </ul> <p>Examples:</p> <p>Author with Pythonic coalition keys:</p> <pre><code>&gt;&gt;&gt; g = Game.from_coalitions(\n...     n_players=3,\n...     values={(): 0.0, (0,): 1.0, (1,): 1.0, (2,): 1.0, (0, 1, 2): 4.0},\n... )\n&gt;&gt;&gt; g.value(g.grand_coalition)\n4.0\n</code></pre>"},{"location":"reference/base/game/#tucoopy.base.game.Game.grand_coalition","title":"grand_coalition  <code>property</code>","text":"<pre><code>grand_coalition\n</code></pre> <p>Return the grand coalition mask (all players).</p> <p>Returns:</p> Type Description <code>int</code> <p>Mask <code>(1 &lt;&lt; n_players) - 1</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; Game.from_coalitions(n_players=3, values={0:0, 7:1}).grand_coalition\n7\n</code></pre>"},{"location":"reference/base/game/#tucoopy.base.game.Game.value","title":"value","text":"<pre><code>value(coalition_mask)\n</code></pre> <p>Return the coalition worth \\(v(S)\\).</p> <p>Parameters:</p> Name Type Description Default <code>coalition_mask</code> <code>int</code> <p>Coalition mask (bitmask).</p> required <p>Returns:</p> Type Description <code>float</code> <p>Coalition value <code>v(S)</code>.</p> Notes <p>Missing coalitions in <code>self.v</code> are treated as value <code>0.0</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 3:1})\n&gt;&gt;&gt; g.value(0b01)  # missing singleton defaults to 0.0\n0.0\n&gt;&gt;&gt; g.value(0b11)\n1.0\n</code></pre>"},{"location":"reference/base/game/#tucoopy.base.game.Game.with_values","title":"with_values","text":"<pre><code>with_values(v)\n</code></pre> <p>Return a copy of the game with a replaced value table.</p> <p>Parameters:</p> Name Type Description Default <code>v</code> <code>dict[int, float]</code> <p>New characteristic function values (by coalition mask).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>A new game with the same <code>n_players</code> and (if present) the same <code>player_labels</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; g1 = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; g2 = g1.with_values({0: 0, 3: 2})\n&gt;&gt;&gt; g1.value(0b11), g2.value(0b11)\n(1.0, 2.0)\n</code></pre>"},{"location":"reference/base/game/#tucoopy.base.game.Game.from_coalitions","title":"from_coalitions  <code>staticmethod</code>","text":"<pre><code>from_coalitions(\n    *,\n    n_players: int,\n    values: Mapping[int, float],\n    player_labels: list[str] | None = None,\n    require_complete: bool = False,\n) -&gt; \"Game\"\n</code></pre><pre><code>from_coalitions(\n    *,\n    n_players: int,\n    values: Mapping[Iterable[int], float],\n    player_labels: list[str] | None = None,\n    require_complete: bool = False,\n) -&gt; \"Game\"\n</code></pre> <pre><code>from_coalitions(\n    *,\n    n_players,\n    values,\n    player_labels=None,\n    require_complete=False,\n)\n</code></pre> <p>Convenience constructor for a TU game from coalition values.</p> <p>Accepts coalition keys as either:</p> <ul> <li>int bitmasks, or</li> <li>iterables of player indices (e.g. <code>(0, 2)</code> or <code>frozenset({1})</code>).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players.</p> required <code>values</code> <code>Mapping[int, float] or Mapping[Iterable[int], float]</code> <p>Coalition values, indexed by bitmask or iterable of player indices.</p> required <code>player_labels</code> <code>list of str</code> <p>Optional display labels for players.</p> <code>None</code> <code>require_complete</code> <code>bool</code> <p>If True, require all \\(2^n\\) coalitions to be specified.</p> <code>False</code> <p>Returns:</p> Type Description <code>Game</code> <p>Instantiated game object.</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If a coalition key uses invalid player indices.</p> <code>InvalidGameError</code> <p>If parameters are invalid or required coalitions are missing.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Game.from_coalitions(n_players=2, values={(): 0, (0,): 1, (1,): 2, (0, 1): 3})\nGame(n_players=2, v={0: 0.0, 1: 1.0, 2: 2.0, 3: 3.0})\n</code></pre>"},{"location":"reference/base/game/#tucoopy.base.game.Game.from_value_function","title":"from_value_function  <code>staticmethod</code>","text":"<pre><code>from_value_function(\n    *,\n    n_players,\n    value_fn,\n    player_labels=None,\n    include_empty=True,\n)\n</code></pre> <p>Build a tabular TU game from a Python function defined on coalitions.</p> <p>This helper enumerates all coalitions and calls <code>value_fn(players(S))</code>.</p> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players.</p> required <code>value_fn</code> <code>Callable[[Sequence[int]], float]</code> <p>Function that receives a list of player indices and returns the coalition value.</p> required <code>player_labels</code> <code>list[str] | None</code> <p>Optional display labels for players.</p> <code>None</code> <code>include_empty</code> <code>bool</code> <p>If False, do not call <code>value_fn</code> on the empty coalition (the value is still normalized to <code>v(0)=0</code>).</p> <code>True</code> <p>Returns:</p> Type Description <code>Game</code> <p>A tabular game storing all coalition values.</p> Notes <p>This is an <code>O(2^n)</code> constructor. Prefer :class:<code>ValueFunctionGame</code> when you do not want to materialize all coalitions.</p> <p>Examples:</p> <p>A \"size\" game (value equals coalition size):</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\n&gt;&gt;&gt; g.value(0b101)\n2.0\n</code></pre>"},{"location":"reference/base/types/","title":"<code>tucoopy.base.types</code>","text":""},{"location":"reference/base/types/#tucoopy.base.types--shared-typing-contracts-protocols","title":"Shared typing contracts (Protocols).","text":"<p>This module contains small :class:<code>typing.Protocol</code> definitions that describe the minimum interface expected by parts of the library (e.g. LP backends). Keeping them here avoids circular imports and makes the intended \u201ccontract\u201d explicit.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.types import GameProtocol\n&gt;&gt;&gt; class MyGame:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, coalition_mask: int) -&gt; float:\n...         return float(coalition_mask)\n&gt;&gt;&gt; g: GameProtocol = MyGame()\n&gt;&gt;&gt; g.value(3)\n3.0\n</code></pre>"},{"location":"reference/base/types/#tucoopy.base.types.GameProtocol","title":"GameProtocol","text":"<p>               Bases: <code>Protocol</code></p> <p>Minimal protocol for a TU game defined over coalition bitmasks.</p> <p>Attributes:</p> Name Type Description <code>n_players</code> <code>int</code> <p>Number of players in the game.</p> <p>Methods:</p> Name Description <code>value</code> <p>Returns the value of the coalition specified by the bitmask.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class MyGame:\n...     n_players = 3\n...     def value(self, coalition_mask: int) -&gt; float:\n...         return float(coalition_mask)\n&gt;&gt;&gt; g = MyGame()\n&gt;&gt;&gt; g.value(0b011)\n3.0\n</code></pre>"},{"location":"reference/base/types/#tucoopy.base.types.LPBackend","title":"LPBackend","text":"<p>               Bases: <code>Protocol</code></p> <p>Protocol for LP backends (intentionally minimal).</p> <p>Methods:</p> Name Description <code>solve</code> <p>Solves a linear program with given coefficients and options.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; class DummyLP:\n...     def solve(self, c, **kwargs):\n...         return 'solved'\n&gt;&gt;&gt; backend = DummyLP()\n&gt;&gt;&gt; backend.solve([1, 2, 3])\n'solved'\n</code></pre>"},{"location":"reference/base/types/#tucoopy.base.types.TabularGameProtocol","title":"TabularGameProtocol","text":"<p>               Bases: <code>GameProtocol</code>, <code>Protocol</code></p> <p>Protocol for games that expose a concrete mapping of coalition values.</p> <p>This is required by algorithms that need to check completeness (i.e. whether all <code>2^n</code> coalition values are explicitly present).</p>"},{"location":"reference/base/types/#tucoopy.base.types.is_tabular_game","title":"is_tabular_game","text":"<pre><code>is_tabular_game(game)\n</code></pre> <p>Return True if <code>game</code> appears to provide a <code>.v</code> mapping.</p> Notes <p>This is a structural (duck-typing) check; it does not validate completeness.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.types import is_tabular_game\n&gt;&gt;&gt; class MyTabular:\n...     n_players = 2\n...     grand_coalition = 3\n...     v = {0: 0.0, 3: 1.0}\n...     def value(self, coalition_mask: int) -&gt; float:\n...         return float(self.v.get(coalition_mask, 0.0))\n&gt;&gt;&gt; is_tabular_game(MyTabular())\nTrue\n</code></pre>"},{"location":"reference/base/types/#tucoopy.base.types.require_tabular_game","title":"require_tabular_game","text":"<pre><code>require_tabular_game(game, *, context)\n</code></pre> <p>Require that <code>game</code> exposes <code>.v</code> (tabular characteristic function mapping).</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the object does not provide a <code>.v</code> mapping.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.types import require_tabular_game\n&gt;&gt;&gt; class MyGame:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, coalition_mask: int) -&gt; float:\n...         return 0.0\n&gt;&gt;&gt; require_tabular_game(MyGame(), context=\"demo\")\nTraceback (most recent call last):\n...\ntucoopy.base.exceptions.InvalidGameError: demo requires a tabular game with a `.v` mapping\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/","title":"<code>tucoopy.diagnostics.allocation_diagnostics</code>","text":""},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics--allocation-level-diagnostics","title":"Allocation-level diagnostics.","text":"<p>This module contains small checks for payoff vectors \\(x\\) such as:</p> <ul> <li>efficiency (\\(\\sum_{i=1}^n x_i = v(N)\\)),</li> <li>individual rationality (\\(x_i \\geq v(\\{i\\})\\)),</li> <li>and convenience wrappers used by core-family diagnostics.</li> </ul> <p>The functions here are lightweight and intended to be stable and serialization-friendly.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import is_imputation\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0, 2: 0, 3: 1})\n&gt;&gt;&gt; is_imputation(g, [0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics.AllocationChecks","title":"AllocationChecks  <code>dataclass</code>","text":"<p>Small set of boolean checks + core explanation for a candidate allocation.</p> <p>This is intended for UI/debug usage and for JSON export.</p> <p>Parameters:</p> Name Type Description Default <code>efficient</code> <code>bool</code> <p>Whether the allocation is efficient (sum equals grand coalition value).</p> required <code>imputation</code> <code>bool</code> <p>Whether the allocation is an imputation (efficient and individually rational).</p> required <code>core</code> <code>CoreDiagnostics</code> <p>Diagnostics for core membership.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import check_allocation\n&gt;&gt;&gt; g = Game([0, 0, 0, 1, 1, 1, 2])\n&gt;&gt;&gt; x = [1, 1]\n&gt;&gt;&gt; result = check_allocation(g, x)\n&gt;&gt;&gt; result.efficient\nTrue\n&gt;&gt;&gt; result.imputation\nTrue\n&gt;&gt;&gt; isinstance(result.core, object)\nTrue\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics.AllocationChecks.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert the checks to a dictionary for serialization.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the checks.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import check_allocation\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; d = check_allocation(g, [0.5, 0.5])\n&gt;&gt;&gt; d.to_dict()[\"efficient\"]\nTrue\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics.check_allocation","title":"check_allocation","text":"<pre><code>check_allocation(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL, core_top_k=8\n)\n</code></pre> <p>Check common conditions for an allocation \\(x\\): - efficiency - imputation membership - core membership diagnostics</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game (game-like object).</p> required <code>x</code> <code>list of float</code> <p>The candidate allocation vector.</p> required <code>tol</code> <code>float</code> <p>Tolerance for numerical checks (default 1e-9).</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>core_top_k</code> <code>int</code> <p>Number of top core violations to include in diagnostics (default 8).</p> <code>8</code> <p>Returns:</p> Type Description <code>AllocationChecks</code> <p>Object containing boolean checks and core diagnostics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import check_allocation\n&gt;&gt;&gt; g = Game([0, 0, 0, 1, 1, 1, 2])\n&gt;&gt;&gt; x = [1, 1]\n&gt;&gt;&gt; result = check_allocation(g, x)\n&gt;&gt;&gt; result.efficient\nTrue\n&gt;&gt;&gt; result.imputation\nTrue\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics.is_efficient","title":"is_efficient","text":"<pre><code>is_efficient(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check efficiency: \\(\\sum_{i=1}^n x_i = v(N)\\) within tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if efficient.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import is_efficient\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; is_efficient(g, [0.2, 0.8])\nTrue\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics.is_imputation","title":"is_imputation","text":"<pre><code>is_imputation(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check imputation membership: efficiency + individual rationality.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import is_imputation\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0.2, 2: 0.0, 3: 1.0})\n&gt;&gt;&gt; is_imputation(g, [0.2, 0.8])\nTrue\n&gt;&gt;&gt; is_imputation(g, [0.2, 0.9])  # not efficient\nFalse\n</code></pre>"},{"location":"reference/diagnostics/allocation_diagnostics/#tucoopy.diagnostics.allocation_diagnostics.is_individually_rational","title":"is_individually_rational","text":"<pre><code>is_individually_rational(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL\n)\n</code></pre> <p>Check individual rationality: \\(x_i \\geq v(\\{i\\})\\) for all \\(i\\) (within tolerance).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.allocation_diagnostics import is_individually_rational\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0.2, 2: 0.0, 3: 1.0})\n&gt;&gt;&gt; is_individually_rational(g, [0.2, 0.8])\nTrue\n&gt;&gt;&gt; is_individually_rational(g, [0.1, 0.9])\nFalse\n</code></pre>"},{"location":"reference/diagnostics/blocking_regions/","title":"<code>tucoopy.diagnostics.blocking_regions</code>","text":""},{"location":"reference/diagnostics/blocking_regions/#tucoopy.diagnostics.blocking_regions--blocking-regions-diagnostics-n3","title":"Blocking regions diagnostics (n=3).","text":"<p>This module computes max-excess blocking regions inside the imputation simplex. It is intended for visualization and explanation: regions can be rendered as polygons in barycentric coordinates.</p> Notes <p>The polygon clipping routine is implemented for <code>n=3</code> only (triangle simplex). For other <code>n</code> this module returns an empty set of regions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.blocking_regions import blocking_regions\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={0: 0, 7: 1})\n&gt;&gt;&gt; br = blocking_regions(g)\n&gt;&gt;&gt; br.coordinate_system\n'barycentric_imputation'\n</code></pre>"},{"location":"reference/diagnostics/blocking_regions/#tucoopy.diagnostics.blocking_regions.BlockingRegion","title":"BlockingRegion  <code>dataclass</code>","text":"<p>A single blocking region in barycentric coordinates.</p> <p>Attributes:</p> Name Type Description <code>coalition_mask</code> <code>int</code> <p>Coalition mask S that is the (one of the) max-excess blockers in this region. For n=2, the only proper non-empty coalitions are {0} and {1} (masks {1,2}). For n=3, proper non-empty coalitions are masks in {1,2,3,4,5,6}.</p> <code>vertices</code> <code>list[list[float]]</code> <p>Region vertices in barycentric coordinates b of the imputation simplex. Each vertex is a length-n vector b with:   - b_i &gt;= 0   - sum_i b_i = 1</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; r = BlockingRegion(coalition_mask=3, vertices=[[1.0, 0.0, 0.0]])\n&gt;&gt;&gt; r.coalition_mask\n3\n</code></pre>"},{"location":"reference/diagnostics/blocking_regions/#tucoopy.diagnostics.blocking_regions.BlockingRegions","title":"BlockingRegions  <code>dataclass</code>","text":"<p>Blocking regions in the imputation simplex (implemented for \\(n=3\\)).</p> Concept <p>For an allocation \\(x\\), the excess of a coalition \\(S\\) is:</p> \\[ e(S, x) = v(S) - x(S). \\] <p>A coalition \\(S\\) is said to be a (max-excess) blocker at \\(x\\). In our sign convention, blocking corresponds to positive excess (the coalition can improve upon \\(x\\)):</p> <ol> <li>It can block: \\(e(S, x) &gt; 0\\)</li> <li>It attains the maximum excess among proper non-empty coalitions:      \\(e(S, x) \\geq e(T, x)\\) for all proper non-empty \\(T \\neq N\\).</li> </ol> <p>This routine partitions (parts of) the imputation simplex into regions where the identity of the max-excess blocker is constant.</p> Coordinate system <p>The computation is performed in barycentric coordinates \\(b\\) over the imputation simplex. Let:</p> <ul> <li>\\(l_i = v(\\{i\\})\\) (individual rationality lower bounds)</li> <li>\\(r   = v(N) - \\sum_{i=1}^n l_i\\) (simplex \"radius\")</li> </ul> <p>Any imputation can be written as:</p> \\[ x = l + r b, \\] <p>where \\(b\\) is barycentric:</p> \\[ b_i \\geq 0, \\;  \\sum_i b_i = 1. \\] <p>Internally, we represent \\(b\\) in 2D using \\((b_0, b_1)\\), with:</p> \\[     b_2 = 1 - b_0 - b_1, \\] <p>and the simplex is the triangle with vertices \\((b_0, b_1)\\) in:</p> \\[ (1,0), (0,1), (0,0). \\] Notes <ul> <li>This is currently implemented only for \\(n=3\\) because it uses planar polygon   clipping (half-plane intersection).</li> <li>If the imputation set is empty or degenerates to a point (\\(r \\leq tol\\)),   the result is empty.</li> <li>Regions are computed by intersecting the simplex triangle with linear   half-planes derived from comparisons:</li> </ul> \\[e (S, x) \\geq e(T, x) \\] <p>and the blocking condition:</p> \\[ e(S, x) &gt;= 0. \\] <p>Attributes:</p> Name Type Description <code>coordinate_system</code> <code>str</code> <p>Always \"barycentric_imputation\".</p> <code>regions</code> <code>list[BlockingRegion]</code> <p>List of <code>BlockingRegion</code> polygons.</p> See also <p>tucoopy.geometry.imputation.ImputationSet     The imputation simplex representation used here.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; br = BlockingRegions(coordinate_system=\"barycentric_imputation\", regions=[])\n&gt;&gt;&gt; br.regions\n[]\n</code></pre>"},{"location":"reference/diagnostics/blocking_regions/#tucoopy.diagnostics.blocking_regions.blocking_regions","title":"blocking_regions","text":"<pre><code>blocking_regions(game, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Compute max-excess blocking regions in the imputation simplex (\\(n=3\\)).</p> Definition <p>For an allocation \\(x\\), define the coalition excess:</p> \\[ e(S, x) = v(S) - x(S),\\\\ x(S) = \\sum_{i \\in S} x_i. \\] <p>A coalition S is a max-excess blocker at x if:</p> <ol> <li>\\(e(S, x) \\geq 0\\)</li> <li>\\(e(S, x) \\geq e(T, x)\\) for all proper non-empty coalitions \\(T \\neq S\\).</li> </ol> <p>This routine returns polygonal regions in the imputation simplex where a fixed coalition S satisfies the two conditions above.</p> Coordinate system <p>For \\(n=3\\), every imputation can be written as:</p> \\[ x = l + r b, \\] <p>where:</p> <ul> <li>\\(l_i = v(\\{i\\})\\)</li> <li>\\(r = v(N) - \\sum_i l_i\\)</li> <li>\\(b\\) is barycentric: \\(b_i \\geq 0\\) and \\(\\sum_i b_i = 1\\)</li> </ul> <p>The returned polygons use \\(b\\) as coordinates (stored explicitly as length-3 vectors), but internally the clipping is done in the 2D chart \\((b_0, b_1)\\), with \\(b_2 = 1 - b_0 - b_1\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used to: - detect degenerate imputation simplex (r &lt;= tol), - soften half-plane comparisons, - de-duplicate nearly-identical polygon vertices.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>BlockingRegions</code> <p>A container with <code>regions</code>, each giving a coalition mask S and a polygon (list of barycentric vertices) describing where S is the max-excess blocker.</p> Notes <ul> <li>Implemented for n=3. For n != 3 this returns no regions.</li> <li>If the imputation set is empty or a singleton (r &lt;= tol), returns no regions.</li> <li>Ties between coalitions (multiple maximizers) are not explicitly merged;   you may see overlapping/adjacent regions due to numerical tolerances.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.blocking_regions import blocking_regions\n&gt;&gt;&gt; g = Game.from_value_function(3, lambda S: float(len(S)))  # additive\n&gt;&gt;&gt; br = blocking_regions(g)\n&gt;&gt;&gt; br.regions\n[]\n</code></pre>"},{"location":"reference/diagnostics/core_cover_diagnostics/","title":"<code>tucoopy.diagnostics.core_cover_diagnostics</code>","text":""},{"location":"reference/diagnostics/core_cover_diagnostics/#tucoopy.diagnostics.core_cover_diagnostics--core-cover-diagnostics","title":"Core cover diagnostics.","text":"<p>This module provides membership-style diagnostics for the core cover (a polytopal superset of the core defined via minimal rights and utopia payoffs).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_cover_diagnostics import core_cover_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0, 2: 0, 3: 1})\n&gt;&gt;&gt; d = core_cover_diagnostics(g, [0.5, 0.5])\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/core_cover_diagnostics/#tucoopy.diagnostics.core_cover_diagnostics.core_cover_diagnostics","title":"core_cover_diagnostics","text":"<pre><code>core_cover_diagnostics(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL\n)\n</code></pre> <p>Membership diagnostics for the core cover.</p> <p>$\\(\\text{CoreCover}(v) = \\{ x : \\sum_{i=1}^n x_i = v(N), m_i \\leq x_i \\leq M_i \\}\\)$.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector of length <code>game.n_players</code>.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used for the efficiency check and bound comparisons.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>BoxBoundSetDiagnostics</code> <p>Diagnostics object including the bounds and any bound violations.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>x</code> does not have length <code>game.n_players</code>.</p> Notes <p>The core cover is defined via:</p> <ul> <li>utopia payoff <code>M</code> (upper bounds), and</li> <li>minimal rights <code>m</code> (lower bounds),</li> </ul> <p>combined with efficiency.</p> <p>Examples:</p> <p>A minimal 3-player example (only the grand coalition has value 1):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_cover_diagnostics import core_cover_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0:0, 1:0, 2:0, 4:0,\n...     3:0, 5:0, 6:0,\n...     7:1,\n... })\n&gt;&gt;&gt; d = core_cover_diagnostics(g, [1/3, 1/3, 1/3])\n&gt;&gt;&gt; d.efficient\nTrue\n&gt;&gt;&gt; isinstance(d.violations, list)\nTrue\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/","title":"<code>tucoopy.diagnostics.core_diagnostics</code>","text":""},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics--core-family-diagnostics-core-and-epsilon-core-membership","title":"Core-family diagnostics (core and epsilon-core membership).","text":"<p>This module provides computations around the coalition excess function \\(e(S, x) = v(S) - x(S)\\) and uses it to:</p> <ul> <li>test whether an allocation is in the core (<code>max_excess &lt;= tol</code>),</li> <li>compute max-excess coalitions (ties),</li> <li>list the most violated coalitions for explanation/debug.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import core_diagnostics, explain_core_membership\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0, 2: 0, 3: 1})\n&gt;&gt;&gt; d = core_diagnostics(g, [0.5, 0.5])\n&gt;&gt;&gt; d.in_core\nTrue\n&gt;&gt;&gt; explain_core_membership(g, [0.25, 0.75])[0].startswith(\"In the core\")\nTrue\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.CoreDiagnostics","title":"CoreDiagnostics  <code>dataclass</code>","text":"<p>Diagnostics for core membership at an allocation \\(x\\).</p> <ul> <li><code>max_excess</code> is the maximum excess over all non-empty proper coalitions.</li> <li><code>violations</code> is the list of the most violated coalitions (sorted by excess desc).</li> <li><code>tight_coalitions</code> are coalitions achieving <code>max_excess</code> (within tol used in computation).</li> </ul> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players in the game.</p> required <code>vN</code> <code>float</code> <p>Value of the grand coalition.</p> required <code>sum_x</code> <code>float</code> <p>Sum of the allocation vector.</p> required <code>efficient</code> <code>bool</code> <p>Whether the allocation is efficient.</p> required <code>in_core</code> <code>bool</code> <p>Whether the allocation is in the core.</p> required <code>max_excess</code> <code>float</code> <p>Maximum excess over all coalitions.</p> required <code>tight_coalitions</code> <code>list of int</code> <p>Coalitions achieving the maximum excess.</p> required <code>violations</code> <code>list of CoreViolation</code> <p>List of most violated coalitions.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.diagnostics import core_diagnostics\n&gt;&gt;&gt; g = Game([0, 0, 0, 1, 1, 1, 2])\n&gt;&gt;&gt; x = [1, 1]\n&gt;&gt;&gt; cd = core_diagnostics(g, x)\n&gt;&gt;&gt; cd.in_core\nTrue\n&gt;&gt;&gt; cd.max_excess\n0.0\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.CoreDiagnostics.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert diagnostics to a dictionary for serialization.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of diagnostics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; cd.to_dict()\n{...}\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.CoreViolation","title":"CoreViolation  <code>dataclass</code>","text":"<p>One coalition constraint evaluation at allocation x.</p> <p>Excess: \\(e(S, x) = v(S) - x(S)\\). A positive excess means coalition \\(S\\) can improve by deviating (\\(x\\) violates the core constraint).</p> <p>Parameters:</p> Name Type Description Default <code>coalition_mask</code> <code>int</code> <p>Bitmask representing the coalition.</p> required <code>players</code> <code>list of int</code> <p>List of player indices in the coalition.</p> required <code>vS</code> <code>float</code> <p>Value of the coalition.</p> required <code>xS</code> <code>float</code> <p>Sum of allocation to coalition members.</p> required <code>excess</code> <code>float</code> <p>Excess value for the coalition.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; cv = CoreViolation(3, [0, 1], 1.0, 0.8, 0.2)\n&gt;&gt;&gt; cv.excess\n0.2\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.TightCoalitions","title":"TightCoalitions  <code>dataclass</code>","text":"<p>Coalitions achieving the maximum excess (within tolerance).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; TightCoalitions(max_excess=0.0, coalitions=[1, 2]).coalitions\n[1, 2]\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.core_diagnostics","title":"core_diagnostics","text":"<pre><code>core_diagnostics(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=8\n)\n</code></pre> <p>Compute a compact explanation of why \\(x\\) is (not) in the core.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector (length n_players).</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance. <code>x</code> is considered in the core if max_excess &lt;= tol and efficient.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>top_k</code> <code>int</code> <p>Return up to this many most violated coalitions.</p> <code>8</code> <p>Returns:</p> Type Description <code>CoreDiagnostics</code> <p>Diagnostics object for core membership.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import core_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; core_diagnostics(g, [0.5, 0.5]).max_excess\n-0.5\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.core_frame_highlight","title":"core_frame_highlight","text":"<pre><code>core_frame_highlight(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Small per-frame highlight payload for UI display.</p> <p>Intended for embedding into FrameSpec.highlights.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>The cooperative game instance.</p> required <code>x</code> <code>list of float</code> <p>The candidate allocation vector.</p> required <code>tol</code> <code>float</code> <p>Tolerance for numerical checks (default 1e-9).</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with highlight information for UI.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.diagnostics import core_frame_highlight\n&gt;&gt;&gt; g = Game([0, 0, 0, 1, 1, 1, 2])\n&gt;&gt;&gt; x = [1, 1]\n&gt;&gt;&gt; core_frame_highlight(g, x)\n{'in_core': True, 'efficient': True, ...}\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.core_violations","title":"core_violations","text":"<pre><code>core_violations(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>List all core constraints violated by allocation x (excess &gt; tol).</p> <p>Returns a list ordered by descending excess and coalition mask.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import core_violations\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 1, 2: 0, 3: 1})\n&gt;&gt;&gt; core_violations(g, [0.0, 1.0])  # v({0})=1 violates x0&gt;=1\n[CoreViolation(coalition_mask=1, players=[0], vS=1.0, xS=0.0, excess=1.0)]\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.excesses","title":"excesses","text":"<pre><code>excesses(\n    game, x, *, include_empty=False, include_grand=False\n)\n</code></pre> <p>Excess function <code>e(S, x) = v(S) - x(S)</code> over coalitions.</p> <p>This is a small helper to export the full excess vector as a dict keyed by coalition mask.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> required <code>include_empty</code> <code>bool</code> <p>Whether to include the empty coalition (mask 0). Default False.</p> <code>False</code> <code>include_grand</code> <code>bool</code> <p>Whether to include the grand coalition (mask <code>2**n - 1</code>). Default False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict[int, float]</code> <p>Dict mapping coalition mask to excess <code>v(S) - x(S)</code>.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>x</code> does not have length <code>n_players</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import excesses\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ex = excesses(g, [0.5, 0.5])\n&gt;&gt;&gt; ex[0b01]  # v({0})-x0\n-0.5\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.explain_core_membership","title":"explain_core_membership","text":"<pre><code>explain_core_membership(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=3\n)\n</code></pre> <p>Generate a short textual explanation about core membership of an allocation.</p> <p>This is a human-friendly wrapper around <code>core_diagnostics</code>. It reports (i) efficiency, (ii) whether the allocation is in the core, and (iii) the most violated coalitions when it is not.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for efficiency and core constraints.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>top_k</code> <code>int</code> <p>Maximum number of violations to compute (default 3). The explanation itself reports at most the most violated coalition plus the tight set.</p> <code>3</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>One sentence per line, ready for UI tooltips/logs.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import explain_core_membership\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; explain_core_membership(g, [0.5, 0.5])[0]\n'In the core (max excess=-0.5 &lt;= tol=1e-09).'\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.is_in_core","title":"is_in_core","text":"<pre><code>is_in_core(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check if allocation is in the core (efficient and max_excess &lt;= tol).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import is_in_core\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; is_in_core(g, [0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.is_in_epsilon_core","title":"is_in_epsilon_core","text":"<pre><code>is_in_epsilon_core(\n    game, x, epsilon, *, tol=DEFAULT_GEOMETRY_TOL\n)\n</code></pre> <p>Check if allocation is in the epsilon-core (efficient and max_excess &lt;= epsilon + tol).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import is_in_epsilon_core\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; is_in_epsilon_core(g, [0.5, 0.5], epsilon=0.0)\nTrue\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.max_excess","title":"max_excess","text":"<pre><code>max_excess(game, x)\n</code></pre> <p>Maximum excess over all proper coalitions (non-empty, excluding the grand coalition).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import max_excess\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; max_excess(g, [0.5, 0.5])\n-0.5\n</code></pre>"},{"location":"reference/diagnostics/core_diagnostics/#tucoopy.diagnostics.core_diagnostics.tight_coalitions","title":"tight_coalitions","text":"<pre><code>tight_coalitions(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Find coalitions achieving the maximum excess (within tolerance).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.core_diagnostics import tight_coalitions\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; tight_coalitions(g, [0.5, 0.5]).coalitions\n[1, 2]\n</code></pre>"},{"location":"reference/diagnostics/epsilon_core_diagnostics/","title":"<code>tucoopy.diagnostics.epsilon_core_diagnostics</code>","text":""},{"location":"reference/diagnostics/epsilon_core_diagnostics/#tucoopy.diagnostics.epsilon_core_diagnostics--epsilon-core-diagnostics","title":"Epsilon-core diagnostics.","text":"<p>This module provides :func:<code>epsilon_core_diagnostics</code>, which evaluates whether a payoff vector \\(x\\) belongs to the epsilon-core of a transferable-utility (TU) game.</p> Definitions <p>For a TU game with characteristic function \\(v\\) and an allocation \\(x\\):</p> <ul> <li>Coalition sum: \\(x(S) = \\sum_{i in S} x_i\\)</li> <li>Excess: \\(e(S, x) = v(S) - x(S)\\)</li> </ul> <p>The epsilon-core consists of efficient allocations such that:</p> <p>$\\(\\max_{\\{S \\subset N, S \\neq \\varnothing\\}} e(S, x) \\leq \\epsilon\\)$.</p> Notes <ul> <li>This diagnostic scans all coalitions (excluding \\(\\varnothing\\) and \\(N\\)), so it is   exponential in <code>n_players</code>.</li> <li>Numerical comparisons use <code>tol</code> for efficiency checks and tie detection.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.epsilon_core_diagnostics import epsilon_core_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; d = epsilon_core_diagnostics(g, [0.5, 0.5], epsilon=0.0)\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/epsilon_core_diagnostics/#tucoopy.diagnostics.epsilon_core_diagnostics.EpsilonCoreDiagnostics","title":"EpsilonCoreDiagnostics  <code>dataclass</code>","text":"<p>Diagnostics for epsilon-core membership at an allocation \\(x\\).</p> <p>In addition to efficiency, the epsilon-core membership test is:</p> <p>$$ \\text{max excess} \\leq \\epsilon $$.</p> <p>Attributes:</p> Name Type Description <code>n_players</code> <code>int</code> <p>Number of players.</p> <code>vN</code> <code>float</code> <p>Grand coalition value <code>v(N)</code>.</p> <code>sum_x</code> <code>float</code> <p>Sum of the allocation vector.</p> <code>efficient</code> <code>bool</code> <p>Whether <code>sum_x</code> matches <code>vN</code> within <code>tol</code>.</p> <code>epsilon</code> <code>float</code> <p>The epsilon parameter of the epsilon-core.</p> <code>in_set</code> <code>bool</code> <p>Whether <code>x</code> belongs to the epsilon-core with the provided epsilon.</p> <code>max_excess</code> <code>float</code> <p>Maximum excess over all proper non-empty coalitions.</p> <code>tight_coalitions</code> <code>list[int]</code> <p>Coalitions attaining <code>max_excess</code> (ties within <code>tol</code>).</p> <code>violations</code> <code>list[EpsilonCoreViolation]</code> <p>Most violated coalitions, sorted by excess descending.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = EpsilonCoreDiagnostics(\n...     n_players=2,\n...     vN=1.0,\n...     sum_x=1.0,\n...     efficient=True,\n...     epsilon=0.0,\n...     in_set=True,\n...     max_excess=-0.5,\n...     tight_coalitions=[1, 2],\n...     violations=[],\n... )\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/epsilon_core_diagnostics/#tucoopy.diagnostics.epsilon_core_diagnostics.EpsilonCoreDiagnostics.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert diagnostics to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the diagnostics dataclass.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = EpsilonCoreDiagnostics(\n...     n_players=2,\n...     vN=1.0,\n...     sum_x=1.0,\n...     efficient=True,\n...     epsilon=0.0,\n...     in_set=True,\n...     max_excess=-0.5,\n...     tight_coalitions=[1, 2],\n...     violations=[],\n... )\n&gt;&gt;&gt; d.to_dict()[\"epsilon\"]\n0.0\n</code></pre>"},{"location":"reference/diagnostics/epsilon_core_diagnostics/#tucoopy.diagnostics.epsilon_core_diagnostics.EpsilonCoreViolation","title":"EpsilonCoreViolation  <code>dataclass</code>","text":"<p>One epsilon-core inequality evaluation at an allocation \\(x\\).</p> <p>The epsilon-core constraints are:</p> <p>\\(v(S) - x(S) \\leq \\epsilon\\) for all proper non-empty coalitions \\(S\\).</p> <p>Attributes:</p> Name Type Description <code>coalition_mask</code> <code>int</code> <p>Coalition bitmask.</p> <code>players</code> <code>list[int]</code> <p>List of player indices in the coalition.</p> <code>vS</code> <code>float</code> <p>Coalition value <code>v(S)</code>.</p> <code>xS</code> <code>float</code> <p>Coalition payoff sum <code>x(S)</code>.</p> <code>excess</code> <code>float</code> <p>Excess <code>e(S, x) = v(S) - x(S)</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = EpsilonCoreViolation(1, [0], 1.0, 0.8, 0.2)\n&gt;&gt;&gt; v.excess\n0.2\n</code></pre>"},{"location":"reference/diagnostics/epsilon_core_diagnostics/#tucoopy.diagnostics.epsilon_core_diagnostics.epsilon_core_diagnostics","title":"epsilon_core_diagnostics","text":"<pre><code>epsilon_core_diagnostics(\n    game, x, *, epsilon, tol=DEFAULT_GEOMETRY_TOL, top_k=8\n)\n</code></pre> <p>Compute epsilon-core membership diagnostics for an allocation \\(x\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector of length <code>game.n_players</code>.</p> required <code>epsilon</code> <code>float</code> <p>Epsilon parameter for the epsilon-core.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used for: - efficiency check (<code>abs(sum(x) - v(N)) &lt;= tol</code>), - tie detection for <code>tight_coalitions</code>.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>top_k</code> <code>int</code> <p>Maximum number of violating coalitions to include in <code>violations</code>.</p> <code>8</code> <p>Returns:</p> Type Description <code>EpsilonCoreDiagnostics</code> <p>Diagnostics object including <code>in_set</code> and the most violated coalitions.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>x</code> does not have length <code>game.n_players</code>.</p> Notes <p>Internally, this uses a shared coalition scanner (<code>scan_excesses</code>) to avoid duplicating the exponential coalition loop across diagnostics.</p> <p>Examples:</p> <p>A minimal 2-player example (only the grand coalition has value 1):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.epsilon_core_diagnostics import epsilon_core_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; d = epsilon_core_diagnostics(g, [0.5, 0.5], epsilon=0.0)\n&gt;&gt;&gt; d.efficient\nTrue\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/imputation_diagnostics/","title":"<code>tucoopy.diagnostics.imputation_diagnostics</code>","text":""},{"location":"reference/diagnostics/imputation_diagnostics/#tucoopy.diagnostics.imputation_diagnostics--imputation-and-pre-imputation-diagnostics","title":"Imputation and pre-imputation diagnostics.","text":"<p>This module provides checks for whether a payoff vector is:</p> <ul> <li>efficient (pre-imputation), and</li> <li>individually rational (imputation).</li> </ul> <p>It is used both directly and as a building block for higher-level set diagnostics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.imputation_diagnostics import imputation_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; imputation_diagnostics(g, [0.5, 0.5]).in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/imputation_diagnostics/#tucoopy.diagnostics.imputation_diagnostics.ImputationDiagnostics","title":"ImputationDiagnostics  <code>dataclass</code>","text":"<p>Diagnostics for membership in the imputation set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.diagnostics.bounds import BoundViolation\n&gt;&gt;&gt; d = ImputationDiagnostics(\n...     n_players=2,\n...     vN=1.0,\n...     sum_x=1.0,\n...     efficient=True,\n...     in_set=True,\n...     lower_bounds=[0.0, 0.0],\n...     violations=[],\n... )\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/imputation_diagnostics/#tucoopy.diagnostics.imputation_diagnostics.ImputationDiagnostics.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert diagnostics to a JSON-serializable dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = ImputationDiagnostics(\n...     n_players=2,\n...     vN=1.0,\n...     sum_x=1.0,\n...     efficient=True,\n...     in_set=True,\n...     lower_bounds=[0.0, 0.0],\n...     violations=[],\n... )\n&gt;&gt;&gt; d.to_dict()[\"sum_x\"]\n1.0\n</code></pre>"},{"location":"reference/diagnostics/imputation_diagnostics/#tucoopy.diagnostics.imputation_diagnostics.imputation_diagnostics","title":"imputation_diagnostics","text":"<pre><code>imputation_diagnostics(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL\n)\n</code></pre> <p>Check whether \\(x\\) is an imputation (efficient + individually rational).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector of length <code>game.n_players</code>.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used for the efficiency check and the individual rationality comparisons.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>ImputationDiagnostics</code> <p>Diagnostics object including <code>in_set</code> and any lower-bound violations.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>x</code> does not have length <code>game.n_players</code>.</p> <p>Examples:</p> <p>A minimal 3-player example (only the grand coalition has value 1):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.imputation_diagnostics import imputation_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0:0, 1:0, 2:0, 4:0,\n...     3:0, 5:0, 6:0,\n...     7:1,\n... })\n&gt;&gt;&gt; d = imputation_diagnostics(g, [1/3, 1/3, 1/3])\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/least_core_diagnostics/","title":"<code>tucoopy.diagnostics.least_core_diagnostics</code>","text":""},{"location":"reference/diagnostics/least_core_diagnostics/#tucoopy.diagnostics.least_core_diagnostics--least-core-diagnostics","title":"Least-core diagnostics.","text":"<p>The least-core is the epsilon-core with the smallest feasible epsilon value \\(\\epsilon*\\).</p> <p>This module provides <code>least_core_diagnostics</code>, which:</p> <ol> <li>Computes \\(\\epsilon*\\) via an LP (requires an LP backend),</li> <li>Reuses <code>tucoopy.diagnostics.epsilon_core_diagnostics.epsilon_core_diagnostics</code>    to assess membership of a specific allocation \\(x\\) in the epsilon-core at    \\(\\epsilon = \\epsilon*\\).</li> </ol> Notes <p>If the LP backend is unavailable, diagnostics are returned with <code>available=False</code> and a human-readable <code>reason</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.least_core_diagnostics import least_core_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; d = least_core_diagnostics(g, [0.5, 0.5])\n&gt;&gt;&gt; d.available\nTrue\n</code></pre>"},{"location":"reference/diagnostics/least_core_diagnostics/#tucoopy.diagnostics.least_core_diagnostics.LeastCoreDiagnostics","title":"LeastCoreDiagnostics  <code>dataclass</code>","text":"<p>Diagnostics for membership in the least-core (\\(\\epsilon*\\)).</p> <p>If the LP backend is unavailable, <code>available=False</code> and <code>reason</code> is set.</p> <p>Attributes:</p> Name Type Description <code>available</code> <code>bool</code> <p>Whether the least-core computation was available (LP backend present).</p> <code>reason</code> <code>str | None</code> <p>Explanation when <code>available</code> is False.</p> <code>epsilon_star</code> <code>float | None</code> <p>The least-core value <code>epsilon*</code> when available.</p> <code>epsilon_core</code> <code>EpsilonCoreDiagnostics | None</code> <p>Epsilon-core diagnostics at <code>epsilon = epsilon*</code> when available.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = LeastCoreDiagnostics(available=False, reason=\"no backend\", epsilon_star=None, epsilon_core=None)\n&gt;&gt;&gt; d.available\nFalse\n</code></pre>"},{"location":"reference/diagnostics/least_core_diagnostics/#tucoopy.diagnostics.least_core_diagnostics.LeastCoreDiagnostics.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert diagnostics to a JSON-serializable dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of the diagnostics dataclass.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = LeastCoreDiagnostics(available=False, reason=\"no backend\", epsilon_star=None, epsilon_core=None)\n&gt;&gt;&gt; d.to_dict()[\"available\"]\nFalse\n</code></pre>"},{"location":"reference/diagnostics/least_core_diagnostics/#tucoopy.diagnostics.least_core_diagnostics.least_core_diagnostics","title":"least_core_diagnostics","text":"<pre><code>least_core_diagnostics(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=8\n)\n</code></pre> <p>Compute least-core membership diagnostics for an allocation \\(x\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector of length <code>game.n_players</code>.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance passed to the least-core LP routine and to the epsilon-core diagnostic.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>top_k</code> <code>int</code> <p>Maximum number of violating coalitions to include in the epsilon-core sub-diagnostic.</p> <code>8</code> <p>Returns:</p> Type Description <code>LeastCoreDiagnostics</code> <p>Diagnostics including the computed <code>epsilon_star</code> (when available) and the epsilon-core diagnostics at that epsilon.</p> Notes <p>This function catches exceptions from the least-core LP routine and returns them as <code>reason</code>. This is intentional to keep diagnostics \"UI-friendly\".</p> <p>Examples:</p> <p>Minimal example (requires an LP backend; skip if not available):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.least_core_diagnostics import least_core_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; d = least_core_diagnostics(g, [0.5, 0.5])\n&gt;&gt;&gt; d.available\nTrue\n</code></pre>"},{"location":"reference/diagnostics/linprog_diagnostics/","title":"<code>tucoopy.diagnostics.linprog_diagnostics</code>","text":""},{"location":"reference/diagnostics/linprog_diagnostics/#tucoopy.diagnostics.linprog_diagnostics--linear-programming-lp-diagnostics-and-explanations","title":"Linear-programming (LP) diagnostics and explanations.","text":"<p>This module contains small, serialization-friendly helpers to extract a stable subset of information from LP solver results, plus higher-level helpers used by tucoopy to expose LP-based explanations in analysis outputs.</p> <p>The low-level extractor <code>linprog_diagnostics</code> is designed to work with:</p> <ul> <li>SciPy/HiGHS <code>scipy.optimize.linprog</code> result objects, and</li> <li>the fallback :class:<code>tucoopy.backends.lp.LinprogResult</code> wrapper used by the PuLP backend.</li> </ul> Notes <p>SciPy is an optional dependency in tucoopy. If SciPy (or the configured LP backend) is unavailable, higher-level helpers may raise an <code>ImportError</code> suggesting installing extra dependencies (e.g. <code>pip install \"tucoopy[lp]\"</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.diagnostics.linprog_diagnostics import LinprogDiagnostics, explain_linprog\n&gt;&gt;&gt; d = LinprogDiagnostics(0, \"Optimal\", 1.0, [1.0, 2.0], [0.0], [0.0], [0.0])\n&gt;&gt;&gt; explain_linprog(d)\n['status=0', 'fun=1', 'Optimal']\n</code></pre>"},{"location":"reference/diagnostics/linprog_diagnostics/#tucoopy.diagnostics.linprog_diagnostics.LinprogDiagnostics","title":"LinprogDiagnostics  <code>dataclass</code>","text":"<p>Diagnostics extracted from SciPy/HiGHS linear programming results.</p> <p>Parameters:</p> Name Type Description Default <code>status</code> <code>int</code> <p>Solver status code.</p> required <code>message</code> <code>str</code> <p>Solver message.</p> required <code>fun</code> <code>float</code> <p>Objective function value.</p> required <code>x</code> <code>list of float</code> <p>Solution vector.</p> required <code>ineqlin_residual</code> <code>list of float</code> <p>Inequality constraint residuals.</p> required <code>ineqlin_marginals</code> <code>list of float</code> <p>Inequality constraint multipliers.</p> required <code>eqlin_marginals</code> <code>list of float</code> <p>Equality constraint multipliers.</p> required <p>Methods:</p> Name Description <code>to_dict</code> <p>Returns diagnostics as a dictionary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = LinprogDiagnostics(0, \"Optimal\", 1.0, [1.0, 2.0], [0.0], [0.0], [0.0])\n&gt;&gt;&gt; d.to_dict()\n{...}\n</code></pre>"},{"location":"reference/diagnostics/linprog_diagnostics/#tucoopy.diagnostics.linprog_diagnostics.LinprogDiagnostics.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Returns diagnostics as a dictionary.</p> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary representation of diagnostics.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = LinprogDiagnostics(0, \"Optimal\", 1.0, [1.0, 2.0], [0.0], [0.0], [0.0])\n&gt;&gt;&gt; d.to_dict()\n{...}\n</code></pre>"},{"location":"reference/diagnostics/linprog_diagnostics/#tucoopy.diagnostics.linprog_diagnostics.build_lp_explanations","title":"build_lp_explanations","text":"<pre><code>build_lp_explanations(game, *, tol=1e-09, max_list=256)\n</code></pre> <p>Compute LP-based explanations for cooperative game analysis.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Cooperative game instance.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance (default 1e-9).</p> <code>1e-09</code> <code>max_list</code> <code>int</code> <p>Maximum number of elements in returned lists.</p> <code>256</code> <p>Returns:</p> Type Description <code>dict</code> <p>Dictionary with balancedness and least core explanations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.linprog import build_lp_explanations\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={(): 0, (0,): 1, (1,): 1, (0, 1): 2})\n&gt;&gt;&gt; build_lp_explanations(g)\n{...}\n</code></pre>"},{"location":"reference/diagnostics/linprog_diagnostics/#tucoopy.diagnostics.linprog_diagnostics.explain_linprog","title":"explain_linprog","text":"<pre><code>explain_linprog(diag)\n</code></pre> <p>Generates a readable summary for UI/debug of LP diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>diag</code> <code>LinprogDiagnostics</code> <p>Diagnostics extracted from the solver.</p> required <p>Returns:</p> Type Description <code>list of str</code> <p>Lines of textual summary.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; diag = LinprogDiagnostics(0, \"Optimal\", 1.0, [1.0, 2.0], [0.0], [0.0], [0.0])\n&gt;&gt;&gt; explain_linprog(diag)\n['status=0', 'fun=1', 'Optimal']\n</code></pre>"},{"location":"reference/diagnostics/linprog_diagnostics/#tucoopy.diagnostics.linprog_diagnostics.linprog_diagnostics","title":"linprog_diagnostics","text":"<pre><code>linprog_diagnostics(res)\n</code></pre> <p>Extracts a stable subset of diagnostics from SciPy/HiGHS linprog results.</p> <p>Parameters:</p> Name Type Description Default <code>res</code> <code>Any</code> <p>Result object from linprog solver.</p> required <p>Returns:</p> Type Description <code>LinprogDiagnostics</code> <p>Diagnostics extracted from the result.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # res = scipy.optimize.linprog(...)\n&gt;&gt;&gt; diag = linprog_diagnostics(res)\n&gt;&gt;&gt; diag.status\n0\n</code></pre>"},{"location":"reference/diagnostics/reasonable_diagnostics/","title":"<code>tucoopy.diagnostics.reasonable_diagnostics</code>","text":""},{"location":"reference/diagnostics/reasonable_diagnostics/#tucoopy.diagnostics.reasonable_diagnostics--reasonable-set-diagnostics","title":"Reasonable set diagnostics.","text":"<p>The reasonable set bounds each player's payoff between individual rationality and their utopia payoff, while requiring efficiency:</p> \\[R(v) = \\{ x : \\sum_{i=1}^n x_i = v(N), \\, v(\\{i\\}) \\leq x_i \\leq M_i \\}\\] <p>where \\(M\\) is the utopia payoff vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.reasonable_diagnostics import reasonable_set_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; reasonable_set_diagnostics(g, [0.5, 0.5]).in_set\nTrue\n</code></pre>"},{"location":"reference/diagnostics/reasonable_diagnostics/#tucoopy.diagnostics.reasonable_diagnostics.reasonable_set_diagnostics","title":"reasonable_set_diagnostics","text":"<pre><code>reasonable_set_diagnostics(\n    game, x, *, tol=DEFAULT_GEOMETRY_TOL\n)\n</code></pre> <p>Membership diagnostics for the reasonable set.</p> \\[R(v) = \\{ x : \\sum_{i=1}^n x_i = v(N), \\, v(\\{i\\}) \\leq x_i \\leq M_i \\}.\\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector of length <code>game.n_players</code>.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used for the efficiency check and bound comparisons.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>BoxBoundSetDiagnostics</code> <p>Diagnostics object including the bounds and any bound violations.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>x</code> does not have length <code>game.n_players</code>.</p> See also <p>tucoopy.geometry.reasonable_set.ReasonableSet     The set-valued wrapper around these constraints.</p> <p>Examples:</p> <p>A minimal 3-player example (only the grand coalition has value 1):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.diagnostics.reasonable_diagnostics import reasonable_set_diagnostics\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0:0, 1:0, 2:0, 4:0,\n...     3:0, 5:0, 6:0,\n...     7:1,\n... })\n&gt;&gt;&gt; d = reasonable_set_diagnostics(g, [1/3, 1/3, 1/3])\n&gt;&gt;&gt; d.in_set\nTrue\n</code></pre>"},{"location":"reference/games/additive/","title":"<code>tucoopy.games.additive</code>","text":""},{"location":"reference/games/additive/#tucoopy.games.additive--additive-tu-games","title":"Additive TU games.","text":"<p>An additive game is defined by player weights \\((w_i)\\) and the characteristic function</p> \\[ v(S) = \\sum_{i \\in S} w_i. \\] <p>These games are the simplest TU games; notably, the Shapley value equals the weight vector.</p> See Also <p>tucoopy.solutions.shapley.shapley_value</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.additive import additive_game\n&gt;&gt;&gt; g = additive_game([1.0, 2.0, 3.0])\n&gt;&gt;&gt; g.value(0b101)  # players {0,2}\n4.0\n</code></pre>"},{"location":"reference/games/additive/#tucoopy.games.additive.additive_game","title":"additive_game","text":"<pre><code>additive_game(weights, *, player_labels=None)\n</code></pre> <p>Generate an additive TU game.</p> <p>The characteristic function is:</p> \\[ v(S) = \\sum_{i \\in S} w_i. \\] <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>Sequence[float]</code> <p>Player weights.</p> required <code>player_labels</code> <code>list[str] | None</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Additive cooperative game.</p> Notes <ul> <li>This is the simplest class of TU games.</li> <li>The Shapley value equals the weight vector.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.additive import additive_game\n&gt;&gt;&gt; g = additive_game([1.0, 2.0, 3.0])\n&gt;&gt;&gt; g.n_players\n3\n&gt;&gt;&gt; g.value(0b011)\n3.0\n</code></pre>"},{"location":"reference/games/airport/","title":"<code>tucoopy.games.airport</code>","text":""},{"location":"reference/games/airport/#tucoopy.games.airport--airport-cost-games","title":"Airport (cost) games.","text":"<p>In the standard airport cost game, each player \\(i\\) has a runway requirement \\(r_i\\), and the cost of a coalition is</p> \\[ c(S) = \\max_{i \\in S} r_i. \\] <p>This module returns a TU worth game by negating the cost: \\(v(S) = -c(S)\\).</p> See Also <p>tucoopy.games.mst.mst_game tucoopy.games.flow.flow_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.airport import airport_game\n&gt;&gt;&gt; g = airport_game([3, 5, 7])\n&gt;&gt;&gt; g.value(0b011)\n-5.0\n</code></pre>"},{"location":"reference/games/airport/#tucoopy.games.airport.airport_game","title":"airport_game","text":"<pre><code>airport_game(runway_requirements, *, player_labels=None)\n</code></pre> <p>Construct an airport (cost) game as a TU worth game.</p> <p>Standard airport cost game:</p> \\[c(S) = \\max_{i \\in S} r_i\\] <p>This constructor returns a worth game by taking \\(v(S) = -c(S)\\), so that cost allocations can be represented as negative payoffs.</p> <p>Parameters:</p> Name Type Description Default <code>runway_requirements</code> <code>Sequence[float]</code> <p>List of runway requirements for each player.</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the airport cost game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If fewer than 1 player is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.airport import airport_game\n&gt;&gt;&gt; g = airport_game([3, 5, 7])\n&gt;&gt;&gt; g.n_players\n3\n&gt;&gt;&gt; g.value(1)\n-3.0\n&gt;&gt;&gt; g.value(3)\n-5.0\n&gt;&gt;&gt; g.value(7)\n-7.0\n</code></pre>"},{"location":"reference/games/apex/","title":"<code>tucoopy.games.apex</code>","text":""},{"location":"reference/games/apex/#tucoopy.games.apex--apex-simple-voting-games","title":"Apex (simple voting) games.","text":"<p>An apex game is a weighted voting game with a distinguished apex player \\(a\\). A coalition \\(S\\) is winning if it includes the apex and the other members meet the quota:</p> \\[ a \\in S \\quad \\text{and} \\quad \\sum_{i \\in S,\\ i \\ne a} w_i \\ge q. \\] See Also <p>tucoopy.games.weighted_voting.weighted_voting_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.apex import apex_game\n&gt;&gt;&gt; g = apex_game(0, [2, 3], quota=3)\n&gt;&gt;&gt; g.value(0b11)\n1.0\n</code></pre>"},{"location":"reference/games/apex/#tucoopy.games.apex.apex_game","title":"apex_game","text":"<pre><code>apex_game(\n    apex_player,\n    weights,\n    quota,\n    *,\n    player_labels=None,\n    winning_value=1.0,\n    losing_value=0.0,\n)\n</code></pre> <p>Construct an apex game (simple game).</p> <p>Let \\(a\\) be the apex player and let \\(w_i\\) be the weights. A coalition \\(S\\) is said to be winning if:</p> <ul> <li>\\(a \\in S\\), and</li> <li>\\(\\sum_{i \\in S,\\ i \\ne a} w_i \\ge q\\).</li> </ul> <p>The characteristic function is:</p> \\[ v(S) = \\begin{cases} w_v, &amp; \\text{ if } S \\text{ is winning} \\\\ l_v, &amp; \\text{ otherwise} \\end{cases} \\] <p>where \\(w_v\\) is the winning value and \\(l_v\\) is the losing value.</p> <p>Parameters:</p> Name Type Description Default <code>apex_player</code> <code>int</code> <p>Index of the apex player.</p> required <code>weights</code> <code>Sequence[float]</code> <p>Weights for each player (excluding apex).</p> required <code>quota</code> <code>float</code> <p>Quota required for a coalition to win (excluding apex).</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <code>winning_value</code> <code>float</code> <p>Value assigned to winning coalitions (default 1.0).</p> <code>1.0</code> <code>losing_value</code> <code>float</code> <p>Value assigned to losing coalitions (default 0.0).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the apex game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If fewer than 2 players are provided or <code>apex_player</code> is out of range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.apex import apex_game\n&gt;&gt;&gt; g = apex_game(0, [2, 3], 3)\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(1)\n0.0\n&gt;&gt;&gt; g.value(3)\n1.0\n</code></pre>"},{"location":"reference/games/assignment/","title":"<code>tucoopy.games.assignment</code>","text":""},{"location":"reference/games/assignment/#tucoopy.games.assignment--assignment-games","title":"Assignment games.","text":"<p>An assignment game is defined from a bipartite value matrix. Coalitions can form matches between the two sides, and their worth is the maximum total matching value attainable by a one-to-one assignment.</p> See Also <p>tucoopy.games.market.market_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.assignment import assignment_game\n&gt;&gt;&gt; g = assignment_game([[1, 2], [3, 4]])\n&gt;&gt;&gt; g.n_players\n4\n&gt;&gt;&gt; g.value(0b1111)  # grand coalition\n5.0\n</code></pre>"},{"location":"reference/games/assignment/#tucoopy.games.assignment.assignment_game","title":"assignment_game","text":"<pre><code>assignment_game(values_matrix, *, player_labels=None)\n</code></pre> <p>Construct an assignment game (TU) from a bipartite value matrix.</p> <p>Players are split into two sides:</p> <ul> <li>left players:  \\(0 \\ldots m-1\\)</li> <li>right players: \\(m \\ldots m+n-1\\)</li> </ul> <p>For a coalition \\(S\\), let \\(L(S)\\) be the left players in \\(S\\) and \\(R(S)\\) the right players in \\(S\\). The coalition worth is the maximum total assignment value achievable by matching \\(L(S)\\) to \\(R(S)\\) (one-to-one), using the given value matrix.</p> <p>Parameters:</p> Name Type Description Default <code>values_matrix</code> <code>Sequence[Sequence[float]]</code> <p>Biadjacency matrix (m x n) of the bipartite value graph.</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the assignment game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the matrix is empty, not rectangular, or has zero rows/columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.assignment import assignment_game\n&gt;&gt;&gt; g = assignment_game([[1, 2], [3, 4]])\n&gt;&gt;&gt; g.n_players\n4\n&gt;&gt;&gt; g.value(3)\n0.0\n&gt;&gt;&gt; g.value(15)\n5.0\n</code></pre>"},{"location":"reference/games/bankruptcy/","title":"<code>tucoopy.games.bankruptcy</code>","text":""},{"location":"reference/games/bankruptcy/#tucoopy.games.bankruptcy--bankruptcy-games","title":"Bankruptcy games.","text":"<p>Bankruptcy games model the division of a limited estate \\(E\\) among players with claims \\(c_i\\). The standard characteristic function is:</p> \\[ v(S) = \\max\\left(0, E - \\sum_{i \\notin S} c_i\\right). \\] See Also <p>tucoopy.games.savings.savings_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.bankruptcy import bankruptcy_game\n&gt;&gt;&gt; g = bankruptcy_game(10, [4, 7])\n&gt;&gt;&gt; g.value(0b01)\n3.0\n</code></pre>"},{"location":"reference/games/bankruptcy/#tucoopy.games.bankruptcy.bankruptcy_game","title":"bankruptcy_game","text":"<pre><code>bankruptcy_game(estate, claims, *, player_labels=None)\n</code></pre> <p>Construct a bankruptcy game (TU) as a worth game.</p> <p>The standard definition of the characteristic function is:</p> \\[v(S) = \\max\\left(0, E - \\sum_{i \\notin S} c_i\\right)\\] <p>where \\(E\\) is the estate and \\(c_i\\) are claims.</p> <p>Parameters:</p> Name Type Description Default <code>estate</code> <code>float</code> <p>Total estate to be divided.</p> required <code>claims</code> <code>Sequence[float]</code> <p>Claims of each player.</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the bankruptcy game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If fewer than 1 player is provided.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.bankruptcy import bankruptcy_game\n&gt;&gt;&gt; g = bankruptcy_game(10, [4, 7])\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(1)\n3.0\n&gt;&gt;&gt; g.value(3)\n10.0\n</code></pre>"},{"location":"reference/games/cost_sharing/","title":"<code>tucoopy.games.cost_sharing</code>","text":""},{"location":"reference/games/cost_sharing/#tucoopy.games.cost_sharing--cost-sharing-games-via-savings","title":"Cost-sharing games (via savings).","text":"<p>This module constructs a TU worth game from stand-alone costs \\(c_i\\) and a dense table of coalition costs \\(C(S)\\) (length \\(2^n\\)) using the standard savings transformation:</p> \\[ v(S) = \\sum_{i \\in S} c_i - C(S). \\] See Also <p>tucoopy.games.savings.savings_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.cost_sharing import cost_sharing_game\n&gt;&gt;&gt; g = cost_sharing_game([2, 3], [0, 2, 3, 4])\n&gt;&gt;&gt; g.value(0b11)\n1.0\n</code></pre>"},{"location":"reference/games/cost_sharing/#tucoopy.games.cost_sharing.cost_sharing_game","title":"cost_sharing_game","text":"<pre><code>cost_sharing_game(\n    individual_costs, coalition_costs, *, player_labels=None\n)\n</code></pre> <p>Construct a cost-sharing game as a TU worth game (via savings).</p> <p>Given:</p> <ul> <li>individual (stand-alone) costs \\(c_i\\)</li> <li>coalition costs \\(C(S)\\) for every coalition mask \\(S\\) (dense, length \\(2^n\\))</li> </ul> <p>Define the savings game:</p> \\[v(S) = \\sum_{i \\in S} c_i - C(S)\\] <p>Parameters:</p> Name Type Description Default <code>individual_costs</code> <code>Sequence[float]</code> <p>Stand-alone costs for each player.</p> required <code>coalition_costs</code> <code>Sequence[float]</code> <p>Costs for each coalition (length \\(2^n\\)).</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the cost-sharing game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If coalition_costs does not have length \\(2^n\\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.cost_sharing import cost_sharing_game\n&gt;&gt;&gt; g = cost_sharing_game([2, 3], [0, 2, 3, 4])\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(1)\n0.0\n&gt;&gt;&gt; g.value(3)\n1.0\n</code></pre>"},{"location":"reference/games/flow/","title":"<code>tucoopy.games.flow</code>","text":""},{"location":"reference/games/flow/#tucoopy.games.flow--flow-games","title":"Flow games.","text":"<p>In a flow game, players own edges of a capacitated directed network. A coalition \\(S\\) may use exactly the edges owned by its members, and its worth is the maximum \\(s\\)-\\(t\\) flow achievable in the induced network.</p> Notes <p>This implementation uses the Edmonds\u2013Karp algorithm and is intended for small networks and examples.</p> See Also <p>tucoopy.games.mst.mst_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.flow import OwnedEdge, flow_game\n&gt;&gt;&gt; edges = [OwnedEdge(0, 1, 1.0, owner=0), OwnedEdge(1, 2, 1.0, owner=1)]\n&gt;&gt;&gt; g = flow_game(n_players=2, n_nodes=3, edges=edges)\n&gt;&gt;&gt; g.value(0b11)\n1.0\n</code></pre>"},{"location":"reference/games/flow/#tucoopy.games.flow.OwnedEdge","title":"OwnedEdge  <code>dataclass</code>","text":"<p>An owned directed edge in a flow game.</p> <p>Attributes:</p> Name Type Description <code>u, v</code> <p>Tail and head node indices.</p> <code>capacity</code> <code>float</code> <p>Non-negative edge capacity.</p> <code>owner</code> <code>int</code> <p>Player index that owns the edge.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; OwnedEdge(0, 1, 2.0, owner=0)\nOwnedEdge(u=0, v=1, capacity=2.0, owner=0)\n</code></pre>"},{"location":"reference/games/flow/#tucoopy.games.flow.flow_game","title":"flow_game","text":"<pre><code>flow_game(\n    *,\n    n_players,\n    n_nodes,\n    edges,\n    player_labels=None,\n    source=0,\n    sink=None,\n)\n</code></pre> <p>Construct a flow game (TU) from a directed capacitated network with edge ownership.</p> <p>Coalition \\(S\\) can use exactly the edges whose <code>owner</code> is in \\(S\\), and its worth is the maximum \\(s-t\\) flow in that induced network.</p> <p>Parameters:</p> Name Type Description Default <code>n_players</code> <code>int</code> <p>Number of players (edge owners).</p> required <code>n_nodes</code> <code>int</code> <p>Number of nodes in the network.</p> required <code>edges</code> <code>list of OwnedEdge</code> <p>List of owned edges.</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <code>source</code> <code>int</code> <p>Source node index (default 0).</p> <code>0</code> <code>sink</code> <code>int</code> <p>Sink node index (default n_nodes-1).</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the flow game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If n_nodes &lt; 2, source/sink out of range, or edge owner/endpoints out of range.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.flow import flow_game, OwnedEdge\n&gt;&gt;&gt; edges = [OwnedEdge(0, 1, 5, 0), OwnedEdge(1, 2, 3, 1)]\n&gt;&gt;&gt; g = flow_game(n_players=2, n_nodes=3, edges=edges)\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(3)\n3.0\n</code></pre>"},{"location":"reference/games/glove/","title":"<code>tucoopy.games.glove</code>","text":""},{"location":"reference/games/glove/#tucoopy.games.glove--glove-games","title":"Glove games.","text":"<p>In a glove game, each player \\(i\\) owns \\(L_i\\) left gloves and \\(R_i\\) right gloves. The coalition value is proportional to the number of pairs that can be formed:</p> \\[ v(S) = u \\min\\left(\\sum_{i \\in S} L_i, \\sum_{i \\in S} R_i\\right), \\] <p>where \\(u\\) is the unit value per pair.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.glove import glove_game\n&gt;&gt;&gt; g = glove_game([1, 0], [0, 1])\n&gt;&gt;&gt; g.value(0b11)\n1.0\n</code></pre>"},{"location":"reference/games/glove/#tucoopy.games.glove.glove_game","title":"glove_game","text":"<pre><code>glove_game(\n    left_gloves,\n    right_gloves,\n    *,\n    unit_value=1.0,\n    player_labels=None,\n)\n</code></pre> <p>Construct a glove game (TU).</p> <p>Each player \\(i\\) owns \\(L_i\\) left gloves and \\(R_i\\) right gloves. A coalition's value is:</p> \\[v(S) = u_v \\min\\left(\\sum_{i \\in S} L_i, \\sum_{i \\in S} R_i\\right)\\] <p>where \\(u_v\\) is the unit value.</p> <p>Parameters:</p> Name Type Description Default <code>left_gloves</code> <code>Sequence[int]</code> <p>Number of left gloves owned by each player.</p> required <code>right_gloves</code> <code>Sequence[int]</code> <p>Number of right gloves owned by each player.</p> required <code>unit_value</code> <code>float</code> <p>Value per pair of gloves (default 1.0).</p> <code>1.0</code> <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the glove game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If left_gloves and right_gloves have different lengths or fewer than 1 player.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.glove import glove_game\n&gt;&gt;&gt; g = glove_game([1, 0], [0, 1])\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(3)\n1.0\n</code></pre>"},{"location":"reference/games/market/","title":"<code>tucoopy.games.market</code>","text":""},{"location":"reference/games/market/#tucoopy.games.market--market-games-buyers-vs-sellers","title":"Market games (buyers vs sellers).","text":"<p>In a market game, players are divided into buyers and sellers. A coalition's worth is the maximum trade surplus it can realize by matching its internal buyers and sellers.</p> Notes <ul> <li>Players \\(0 \\ldots B-1\\) are buyers and players \\(B \\ldots B+S-1\\) are sellers.</li> <li>This implementation uses a greedy matching strategy and is intended as a   lightweight generator for examples and demos.</li> </ul> See Also <p>tucoopy.games.assignment.assignment_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.market import market_game\n&gt;&gt;&gt; g = market_game([10, 8], [3])\n&gt;&gt;&gt; g.n_players\n3\n&gt;&gt;&gt; g.value(0b111)  # grand coalition\n7.0\n</code></pre>"},{"location":"reference/games/market/#tucoopy.games.market.market_game","title":"market_game","text":"<pre><code>market_game(buyers, sellers, *, player_labels=None)\n</code></pre> <p>Generate a market game (buyers vs sellers).</p> <p>Coalition value equals the maximum trade surplus achievable by matching buyers and sellers inside the coalition.</p> <p>Parameters:</p> Name Type Description Default <code>buyers</code> <code>Sequence[float]</code> <p>Buyer valuations.</p> required <code>sellers</code> <code>Sequence[float]</code> <p>Seller costs.</p> required <code>player_labels</code> <code>list[str] | None</code> <p>Optional labels.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Market cooperative game.</p> Notes <ul> <li>Players \\(0 \\ldots B-1\\) are buyers, \\(B \\ldots B+S-1\\) are sellers.</li> <li>Value is computed by greedy matching of highest surplus pairs.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.market import market_game\n&gt;&gt;&gt; g = market_game([10, 8], [3])\n&gt;&gt;&gt; g.value(0b111)\n7.0\n</code></pre>"},{"location":"reference/games/mst/","title":"<code>tucoopy.games.mst</code>","text":""},{"location":"reference/games/mst/#tucoopy.games.mst--minimum-spanning-tree-cost-games","title":"Minimum spanning tree (cost) games.","text":"<p>Given a complete undirected graph over players with edge weights \\(w(i,j)\\), the coalition cost is the MST cost over the induced subgraph on \\(S\\):</p> \\[ c(S) = \\mathrm{MST}(S). \\] <p>This module returns a TU worth game by taking \\(v(S) = -c(S)\\).</p> See Also <p>tucoopy.games.flow.flow_game tucoopy.games.airport.airport_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.mst import mst_game\n&gt;&gt;&gt; g = mst_game([[0, 1], [1, 0]])\n&gt;&gt;&gt; g.value(0b11)\n-1.0\n</code></pre>"},{"location":"reference/games/mst/#tucoopy.games.mst.mst_game","title":"mst_game","text":"<pre><code>mst_game(weights, *, player_labels=None)\n</code></pre> <p>Construct a minimum spanning tree (cost) game as a TU worth game.</p> <p>Given a complete undirected graph over players with edge weights \\(w(i,j)\\), define the coalition cost as the MST cost over the induced subgraph on \\(S\\):</p> \\[c(S) = \\text{MST cost}(S)\\] <p>This constructor returns a worth game by taking \\(v(S) = -c(S)\\).</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>Sequence[Sequence[float]]</code> <p>Edge weights for the complete graph (n x n matrix).</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the MST cost game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If weights is not a square n x n matrix or the graph is disconnected.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.mst import mst_game\n&gt;&gt;&gt; g = mst_game([[0, 1], [1, 0]])\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(3)\n-1.0\n</code></pre>"},{"location":"reference/games/production/","title":"<code>tucoopy.games.production</code>","text":""},{"location":"reference/games/production/#tucoopy.games.production--production-games","title":"Production games.","text":"<p>In a (linear) production game, players own resources and coalitions can pool their resources to produce output that is valued by fixed prices.</p> <p>This implementation uses a simplified linear model where the coalition worth is the total market value of the pooled resources:</p> \\[ v(S) = \\sum_{k} p_k \\left(\\sum_{i \\in S} r_{i,k}\\right), \\] <p>where \\(r_{i,k}\\) is the amount of resource \\(k\\) owned by player \\(i\\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.production import production_game\n&gt;&gt;&gt; g = production_game(resources=[[1, 0], [0, 2]], prices=[10, 5])\n&gt;&gt;&gt; g.value(0b11)\n20.0\n</code></pre>"},{"location":"reference/games/production/#tucoopy.games.production.production_game","title":"production_game","text":"<pre><code>production_game(resources, prices, *, player_labels=None)\n</code></pre> <p>Generate a production game.</p> <p>Players own resources, and coalitions can combine resources to produce goods with given prices.</p> <p>Parameters:</p> Name Type Description Default <code>resources</code> <code>Sequence[Sequence[float]]</code> <p>resources[i][k] = amount of resource k owned by player i.</p> required <code>prices</code> <code>Sequence[float]</code> <p>Price per unit of each resource.</p> required <code>player_labels</code> <code>list[str] | None</code> <p>Optional labels.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Production cooperative game.</p> Notes <ul> <li>Coalition value is total market value of combined resources.</li> <li>This is a simplified linear production model.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.production import production_game\n&gt;&gt;&gt; g = production_game(resources=[[1, 0], [0, 2]], prices=[10, 5])\n&gt;&gt;&gt; g.value(0b01)  # player 0 alone\n10.0\n&gt;&gt;&gt; g.value(0b11)  # pooled\n20.0\n</code></pre>"},{"location":"reference/games/savings/","title":"<code>tucoopy.games.savings</code>","text":""},{"location":"reference/games/savings/#tucoopy.games.savings--savings-games","title":"Savings games.","text":"<p>Given stand-alone costs \\(c_i\\) and a dense table of coalition costs \\(C(S)\\) (length \\(2^n\\)), the savings game is defined by:</p> \\[ v(S) = \\sum_{i \\in S} c_i - C(S). \\] See Also <p>tucoopy.games.cost_sharing.cost_sharing_game</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.savings import savings_game\n&gt;&gt;&gt; g = savings_game([2, 3], [0, 2, 3, 4])\n&gt;&gt;&gt; g.value(0b11)\n1.0\n</code></pre>"},{"location":"reference/games/savings/#tucoopy.games.savings.savings_game","title":"savings_game","text":"<pre><code>savings_game(\n    individual_costs, coalition_costs, *, player_labels=None\n)\n</code></pre> <p>Construct a savings game (TU) as a worth game.</p> <p>Given:</p> <ul> <li>individual costs \\(c_i\\)</li> <li>coalition costs \\(C(S)\\) for every coalition mask \\(S\\) (length \\(2^n\\))</li> </ul> <p>Define savings:</p> \\[v(S) = \\sum_{i \\in S} c_i - C(S)\\] <p>Parameters:</p> Name Type Description Default <code>individual_costs</code> <code>Sequence[float]</code> <p>Individual costs for each player.</p> required <code>coalition_costs</code> <code>Sequence[float]</code> <p>Costs for each coalition (length \\(2^n\\)).</p> required <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the savings game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If fewer than 1 player or coalition_costs does not have length \\(2^n\\).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.savings import savings_game\n&gt;&gt;&gt; g = savings_game([2, 3], [0, 2, 3, 4])\n&gt;&gt;&gt; g.n_players\n2\n&gt;&gt;&gt; g.value(1)\n0.0\n&gt;&gt;&gt; g.value(3)\n1.0\n</code></pre>"},{"location":"reference/games/unanimity/","title":"<code>tucoopy.games.unanimity</code>","text":""},{"location":"reference/games/unanimity/#tucoopy.games.unanimity--unanimity-games","title":"Unanimity games.","text":"<p>The unanimity game \\(u_T\\) assigns a positive value to coalitions that contain a fixed coalition \\(T\\):</p> \\[ u_T(S) = \\begin{cases} v, &amp; \\text{if } T \\subseteq S, \\\\ 0, &amp; \\text{otherwise}. \\end{cases} \\] <p>Unanimity games form a convenient basis for TU games (via Harsanyi dividends).</p> See Also <p>tucoopy.games.glove.glove_game tucoopy.transforms.harsanyi.harsanyi_dividends</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.unanimity import unanimity_game\n&gt;&gt;&gt; g = unanimity_game([0, 1], value=2.0, n_players=3)\n&gt;&gt;&gt; g.value(0b111)\n2.0\n</code></pre>"},{"location":"reference/games/unanimity/#tucoopy.games.unanimity.unanimity_game","title":"unanimity_game","text":"<pre><code>unanimity_game(\n    coalition,\n    *,\n    value=1.0,\n    n_players=None,\n    player_labels=None,\n)\n</code></pre> <p>Construct a unanimity game \\(u_T\\) (TU).</p> <p>Let \\(v\\) denote the value. Given a coalition \\(S\\) define:</p> \\[ u_T(S) =  \\begin{cases} v &amp; \\text{ if } T \\subseteq S \\\\  0 &amp; \\text{ otherwise } \\end{cases} \\] <p>Provide either:</p> <ul> <li>coalition as bitmask and n_players, or</li> <li>coalition as iterable of players and n_players inferred from labels/explicit arg.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>coalition</code> <code>int or Iterable[int]</code> <p>Coalition as bitmask or iterable of player indices.</p> required <code>value</code> <code>float</code> <p>Value assigned if T is a subset of S (default 1.0).</p> <code>1.0</code> <code>n_players</code> <code>int</code> <p>Number of players (required if coalition is bitmask or no labels provided).</p> <code>None</code> <code>player_labels</code> <code>list of str</code> <p>Optional labels for players.</p> <code>None</code> <p>Returns:</p> Type Description <code>Game</code> <p>Cooperative game instance representing the unanimity game.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If n_players is missing or fewer than 1 player.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.unanimity import unanimity_game\n&gt;&gt;&gt; g = unanimity_game([0, 1], value=2.0, n_players=3)\n&gt;&gt;&gt; g.n_players\n3\n&gt;&gt;&gt; g.value(3)\n2.0\n&gt;&gt;&gt; g.value(7)\n2.0\n</code></pre>"},{"location":"reference/games/weighted_voting/","title":"<code>tucoopy.games.weighted_voting</code>","text":""},{"location":"reference/games/weighted_voting/#tucoopy.games.weighted_voting--weighted-voting-games-simple-games","title":"Weighted voting games (simple games).","text":"<p>Given weights \\(w_i\\) and quota \\(q\\), a coalition \\(S\\) is winning if \\(\\sum_{i \\in S} w_i \\ge q\\). The characteristic function takes two values: <code>winning_value</code> and <code>losing_value</code> (with \\(v(\\varnothing)=0\\) enforced).</p> See Also <p>tucoopy.power.banzhaf.banzhaf_index tucoopy.power.shapley_shubik.shapley_shubik_index</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.weighted_voting import weighted_voting_game\n&gt;&gt;&gt; g = weighted_voting_game([2, 1, 1], quota=3)\n&gt;&gt;&gt; g.value(0b011)\n1.0\n</code></pre>"},{"location":"reference/games/weighted_voting/#tucoopy.games.weighted_voting.weighted_voting_game","title":"weighted_voting_game","text":"<pre><code>weighted_voting_game(\n    weights,\n    quota,\n    *,\n    player_labels=None,\n    winning_value=1.0,\n    losing_value=0.0,\n)\n</code></pre> <p>Construct a weighted voting game (simple game).</p> <p>Given weights \\(w_i\\) and quota \\(q\\), coalition \\(S\\) is winning if \\(\\sum_{i \\in S} w_i \\geq q\\). The characteristic function is given by:</p> \\[ v(S) = \\begin{cases} w_v, &amp; \\text{ if } S \\text{ is winning} \\\\ l_v, &amp; \\text{ otherwise} \\end{cases} \\] <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>Sequence[float]</code> <p>Player weights.</p> required <code>quota</code> <code>float</code> <p>Winning threshold.</p> required <code>player_labels</code> <code>list of str</code> <p>Optional display labels for players.</p> <code>None</code> <code>winning_value</code> <code>float</code> <p>Value assigned to winning coalitions (default 1.0).</p> <code>1.0</code> <code>losing_value</code> <code>float</code> <p>Value assigned to losing coalitions (default 0.0). The empty coalition is always normalized to 0.0 (TU convention).</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Game</code> <p>A TU game with values in {0,1} (by default), suitable for power indices.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If fewer than 1 player is provided.</p> Notes <p>Commonly: <code>winning_value=1</code>, <code>losing_value=0</code>. The TU convention \\(v(\\varnothing)=0\\) is enforced even if <code>losing_value</code> is non-zero.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.games.weighted_voting import weighted_voting_game\n&gt;&gt;&gt; g = weighted_voting_game([2, 1, 1], quota=3)\n&gt;&gt;&gt; g.value(0b011)  # 2+1 meets quota\n1.0\n&gt;&gt;&gt; g.value(0b001)\n0.0\n</code></pre>"},{"location":"reference/geometry/bargaining_set/","title":"<code>tucoopy.geometry.bargaining_set</code>","text":""},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set--aumannamaschler-bargaining-set-small-n-helpers","title":"Aumann\u00e2\u20ac\u201cMaschler bargaining set (small-\\(n\\) helpers).","text":"<p>This module implements a pragmatic, small-\\(n\\) oriented toolkit around the bargaining set for transferable-utility (TU) cooperative games.</p> <p>The bargaining set is defined via objections and counter-objections and is computationally expensive in general. The implementation here focuses on:</p> <ul> <li>clear data structures (<code>Objection</code>, <code>CounterObjection</code>),</li> <li>a test function suitable for diagnostics/visualization workflows, and</li> <li>a sampling-based approach (via :func:<code>tucoopy.geometry.sampling.sample_imputation_set</code>)   for exploring candidate points when exhaustive checks are infeasible.</li> </ul> Notes <p>This module is intended for use with <code>tucoopy.geometry.ImputationSet</code> and other core-family objects. For large games, prefer approximate workflows and explicit limits (number of samples, max attempts, etc.).</p> <p>Examples:</p> <p>Create a small game and instantiate the bargaining-set helper:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.bargaining_set import BargainingSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; bs = BargainingSet(g)\n&gt;&gt;&gt; isinstance(bs, BargainingSet)\nTrue\n</code></pre>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingCheckResult","title":"BargainingCheckResult  <code>dataclass</code>","text":"<p>Result of a bargaining-set membership check.</p> <p>Attributes:</p> Name Type Description <code>in_set</code> <code>bool</code> <p>True iff the allocation passed the (heuristic) bargaining-set test.</p> <code>witness</code> <code>Objection | None</code> <p>If <code>in_set</code> is False, an objection (S, y) that has no counterobjection under the heuristic search strategy. If <code>in_set</code> is True, this is None.</p> Notes <p>This result is intended primarily for debugging/visualization: a non-empty witness helps explain why a point was rejected.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry.bargaining_set import BargainingCheckResult\n&gt;&gt;&gt; res = BargainingCheckResult(in_set=True)\n&gt;&gt;&gt; res.in_set\nTrue\n</code></pre>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet","title":"BargainingSet  <code>dataclass</code>","text":"<p>Aumann\u00e2\u20ac\u201cMaschler bargaining set (small-\\(n\\) heuristic membership test).</p> Definition (informal) <p>Let \\(x\\) be an imputation (efficient and individually rational). An objection \\((S, y)\\) by \\(i\\) against \\(j\\) is \"justified\" if it improves coalition members in \\(S\\) (and strictly improves \\(i\\)). The bargaining set contains imputations for which every objection has a counterobjection.</p> <p>This object provides:</p> <ul> <li><code>contains(x)</code> / <code>check(x)</code> as a heuristic membership test (\\(x\\) must be an imputation)</li> <li><code>sample_points(...)</code> rejection sampling for visualization</li> </ul> Implementation scope <p>This implementation is intended for very small games (default \\(n \\leq 4\\)). It searches over coalitions and constructs objections/counterobjections using a closed-form solver for the subproblem:</p> \\[ \\text{maximize } z_j \\] <p>subject to</p> \\[ \\begin{cases}  \\sum_{k \\in T} z_k = v(T), \\\\ z_k \\geq \\text{lower}_k \\text{ for } k \\in T \\end{cases} \\] <p>That subproblem is trivial: assign all players at their lower bounds and give all slack to the maximized player.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used for comparisons (excess positivity, strict improvements, etc.).</p> <code>DEFAULT_BARGAINING_TOL</code> <code>max_objections_per_pair</code> <code>int</code> <p>Limit the number of candidate coalitions S tried for each ordered pair (i, j). Candidates are sorted by descending excess and truncated.</p> <code>8</code> <code>n_max</code> <code>int</code> <p>Safety limit on the number of players. The search is exponential in n.</p> <code>DEFAULT_MAX_PLAYERS</code> Notes <ul> <li>This is not a complete bargaining-set algorithm for arbitrary \\(n\\).   It is meant for pedagogical use and visualization.</li> <li>The method can return false negatives/positives in principle, because it   truncates the search (<code>max_objections_per_pair</code>) and uses simple tie-breaking.</li> </ul> <p>Examples:</p> <p>Basic construction and type-checking:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; bs = BargainingSet(g, max_objections_per_pair=4)\n&gt;&gt;&gt; x = [1.0, 1.0, 2.0]\n&gt;&gt;&gt; isinstance(bs.contains(x), bool)\nTrue\n</code></pre> <p>Sampling imputations (deterministic with a seed):</p> <pre><code>&gt;&gt;&gt; pts = bs.sample_points(n_samples=20, seed=0, max_points=5)\n&gt;&gt;&gt; len(pts) &lt;= 5\nTrue\n</code></pre>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet.check","title":"check","text":"<pre><code>check(\n    x,\n    *,\n    search=\"top_excess\",\n    seed=None,\n    max_objections_per_pair=None,\n    max_counterobjections_per_pair=None,\n    record_counter_attempts=False,\n)\n</code></pre> <p>Heuristic bargaining-set membership test (small \\(n\\)).</p> Overview <ol> <li>Verify that \\(x\\) is an imputation.</li> <li>For each ordered pair \\((i, j)\\), enumerate candidate coalitions \\(S\\) with:    \\(i \\in S\\), \\(j \\notin S\\), and positive excess \\(e(S,x) &gt; \\text{tol}\\).</li> <li> <p>For each candidate \\(S\\) (up to max_objections_per_pair):</p> <ul> <li>construct an objection \\((S, y)\\) by maximizing \\(y_i\\) subject to  \\(y_k \\geq x_k\\) for \\(k \\in S\\) and \\(\\sum_{k \\in S} y_k = v(S)\\).</li> <li>if \\(y_i &gt; x_i + \\text{tol}\\), this is a genuine objection candidate.</li> <li>if no counterobjection exists for it, return a witness.</li> </ul> </li> <li> <p>If every considered objection is countered, return <code>in_set=True</code>.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Candidate allocation (must be an imputation).</p> required <code>search</code> <code>str</code> <p>Search policy for objection coalitions S and counterobjection coalitions T. One of: <code>\"top_excess\"</code>, <code>\"random\"</code>, <code>\"all\"</code>.</p> <code>'top_excess'</code> <code>seed</code> <code>int | None</code> <p>Optional RNG seed used when <code>search=\"random\"</code>.</p> <code>None</code> <code>max_objections_per_pair</code> <code>int | None</code> <p>Optional override for the per-pair limit on objection coalitions S.</p> <code>None</code> <code>max_counterobjections_per_pair</code> <code>int | None</code> <p>Optional limit for counterobjection coalitions T tested per objection.</p> <code>None</code> <code>record_counter_attempts</code> <code>bool</code> <p>If True and the check fails, include attempted counterobjections in the witness.</p> <code>False</code> <p>Returns:</p> Type Description <code>BargainingCheckResult</code> <p>Membership decision plus optional witness objection.</p> Notes <ul> <li>Candidate coalitions S are sorted by descending excess to find strong   objections first.</li> <li>The search is truncated; passing this test does not formally prove   bargaining-set membership for arbitrary games.</li> </ul>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet.contains","title":"contains","text":"<pre><code>contains(x)\n</code></pre> <p>Return True iff \\(x\\) passes the bargaining-set heuristic check.</p>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet.explain","title":"explain","text":"<pre><code>explain(\n    x,\n    *,\n    max_objections_per_pair=None,\n    max_counterobjections_per_pair=None,\n    search=\"top_excess\",\n    seed=None,\n    record_counter_attempts=False,\n)\n</code></pre> <p>Return a short human-readable explanation of bargaining-set membership.</p> Notes <p>This is a thin wrapper around <code>check</code>.</p>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet.sample_point","title":"sample_point","text":"<pre><code>sample_point(\n    *, n_samples=200, seed=None, max_attempts=None\n)\n</code></pre> <p>Return one bargaining-set point found by sampling, or None.</p> <p>This is a convenience wrapper around <code>sample_points</code>.</p>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet.sample_points","title":"sample_points","text":"<pre><code>sample_points(*, n_samples, seed=None, max_attempts=None)\n</code></pre> <p>Sample bargaining-set points for visualization (small \\(n\\)) via rejection sampling.</p> Procedure <ol> <li>Draw candidate points from the imputation set using <code>tucoopy.geometry.sampling.sample_imputation_set</code>.</li> <li>Keep points that satisfy <code>contains</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Target number of accepted points.</p> required <code>seed</code> <code>int | None</code> <p>Optional seed for the underlying imputation sampler.</p> <code>None</code> <code>max_attempts</code> <code>int | None</code> <p>Maximum number of candidate points tested. If None, defaults to <code>200 * n_samples</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Accepted bargaining-set points. May contain fewer than <code>n_samples</code> points if <code>max_attempts</code> is reached.</p> Notes <p>Degenerate imputation simplex: If the imputation set is empty, returns <code>[]</code>. If it is a singleton, returns either <code>[x0]</code> or <code>[]</code> depending on membership.</p>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.BargainingSet.scan_imputation_grid","title":"scan_imputation_grid","text":"<pre><code>scan_imputation_grid(\n    *,\n    step,\n    max_points=5000,\n    search=\"top_excess\",\n    seed=None,\n    max_objections_per_pair=1,\n    max_counterobjections_per_pair=1,\n)\n</code></pre> <p>Scan a coarse grid over the 3-player imputation simplex (sanity-check helper).</p> <p>This enumerates points in the imputation set for \\(n=3\\) by discretizing the \"slack\" coordinates:</p> <ul> <li>\\(x = l + y\\) where \\(l\\) is the imputation lower bound vector, and</li> <li>\\(y_i \\ge 0\\) with \\(\\sum_i y_i = r := v(N) - \\sum_i l_i\\).</li> </ul> <p>The scan uses a simple grid spacing <code>step</code> in the payoff units of the game, then tests each point with <code>contains</code>.</p> <p>Parameters:</p> Name Type Description Default <code>step</code> <code>float</code> <p>Grid spacing in payoff units. Larger values mean fewer points.</p> required <code>max_points</code> <code>int</code> <p>Hard limit on returned points.</p> <code>5000</code> <code>search</code> <code>str</code> <p>Passed to <code>check</code>.</p> <code>'top_excess'</code> <code>seed</code> <code>str</code> <p>Passed to <code>check</code>.</p> <code>'top_excess'</code> <code>max_objections_per_pair</code> <code>str</code> <p>Passed to <code>check</code>.</p> <code>'top_excess'</code> <code>max_counterobjections_per_pair</code> <code>str</code> <p>Passed to <code>check</code>.</p> <code>'top_excess'</code> <p>Returns:</p> Type Description <code>list[tuple[list[float], bool]]</code> <p>List of (x, in_set) pairs. Points are returned in a deterministic order.</p> Notes <ul> <li>Implemented only for \\(n=3\\).</li> <li>This is a debugging/visualization helper; it does not provide guarantees   about bargaining-set membership for arbitrary games.</li> <li>The membership test requires an LP backend when non-trivial objections are   present.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import BargainingSet\n&gt;&gt;&gt; g = Game.from_coalitions(\n...     n_players=3,\n...     values={\n...         (): 0.0,\n...         (0,): 1.0, (1,): 1.2, (2,): 0.8,\n...         (0, 1): 2.8, (0, 2): 2.2, (1, 2): 2.0,\n...         (0, 1, 2): 4.0,\n...     },\n... )\n&gt;&gt;&gt; bs = BargainingSet(g)\n&gt;&gt;&gt; pts = bs.scan_imputation_grid(step=0.5)\n&gt;&gt;&gt; len(pts) &gt; 0\nTrue\n</code></pre>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.CounterobjectionAttempt","title":"CounterobjectionAttempt  <code>dataclass</code>","text":"<p>Attempt to find a counterobjection on a coalition \\(T\\).</p> <p>This is optional diagnostic information returned when a bargaining-set check fails and the caller requests counter-search details.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry.bargaining_set import CounterobjectionAttempt\n&gt;&gt;&gt; att = CounterobjectionAttempt(coalition=0b101, feasible=True, achieved_maximized_value=1.0, required_value=0.5)\n&gt;&gt;&gt; att.feasible\nTrue\n</code></pre>"},{"location":"reference/geometry/bargaining_set/#tucoopy.geometry.bargaining_set.Objection","title":"Objection  <code>dataclass</code>","text":"<p>Objection \\((S, y)\\) by player \\(i\\) against player \\(j\\).</p> Background <p>In the Aumann\u00e2\u20ac\u201cMaschler bargaining set, an objection is a pair \\((S, y)\\) where:</p> <ul> <li>\\(S\\) is a coalition such that \\(i \\in S\\) and \\(j \\notin S\\)</li> <li>\\(y\\) is an allocation for coalition \\(S\\) (extended to \\(N\\) by leaving non-members as \\(0\\)),   satisfying feasibility on \\(S\\) and improving all members of \\(S\\) relative to \\(x\\)</li> </ul> <p>In this implementation we follow the common imputation-based notion:</p> <ul> <li>\\(y\\) is feasible for \\(S\\):  $\\(\\sum_{k in S} y_k = v(S)\\)$</li> <li>each \\(k \\in S\\) is at least as well off as in \\(x: y_k \\geq x_k\\)</li> <li>player \\(i\\) strictly improves: \\(y_i &gt; x_i\\)</li> </ul> <p>The pair \\((i, j)\\) identifies \"who objects against whom\".</p> <p>Attributes:</p> Name Type Description <code>i, j</code> <p>Player indices (0-based).</p> <code>coalition</code> <code>Coalition</code> <p>Coalition mask S.</p> <code>y</code> <code>list[float]</code> <p>Full length-n vector representing the objection allocation (entries outside S are typically unused / 0 in this implementation).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry.bargaining_set import Objection\n&gt;&gt;&gt; obj = Objection(i=0, j=2, coalition=0b011, y=[1.5, 0.5, 0.0])\n&gt;&gt;&gt; (obj.i, obj.j, obj.coalition)\n(0, 2, 3)\n</code></pre>"},{"location":"reference/geometry/core_cover_set/","title":"<code>tucoopy.geometry.core_cover_set</code>","text":""},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set--core-cover-polyhedral-superset-of-the-core","title":"Core cover (polyhedral superset of the core).","text":"<p>This module provides :class:<code>CoreCover</code>, a set-valued object with a polyhedral representation (H-representation) accessible via the :attr:<code>CoreCover.poly</code> property.</p> <p>The core cover is a classical polyhedral superset of the core defined using the minimal rights vector and the utopia payoff vector.</p> See Also <p>tucoopy.solutions.tau.minimal_rights tucoopy.solutions.tau.utopia_payoff tucoopy.geometry.PolyhedralSet</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover","title":"CoreCover  <code>dataclass</code>","text":"<p>Core cover polytope.</p> Definition <p>Let:</p> \\[ M_i = \\text{ utopia payoff of player } i \\\\ m_i = \\text{ minimal rights of player } i \\] <p>The core cover is the polytope:</p> \\[ CC(v) = \\left\\{ x \\in \\mathbb{R}^n \\, : \\, \\sum_{i=1}^n x_i = v(N), m_i \\leq x_i \\leq M_i \\text{ for all } i \\right\\} \\] Interpretation <ul> <li>The utopia payoff \\(M_i\\) represents the maximum amount player \\(i\\) could   hope to obtain without making any coalition worse off.</li> <li>The minimal rights \\(m_i\\) represent the minimal amount player \\(i\\) can   guarantee for themselves considering all coalitional possibilities.</li> <li>The core cover is therefore a box-constrained efficiency slice,   often much easier to compute and visualize than the core.</li> </ul> <p>The core is always contained in the core cover:</p> \\[ \\text{Core}(v) \\subseteq \\text{CoreCover}(v) \\] <p>and for many classes of games, the core cover provides a very tight outer approximation of the core.</p> Notes <ul> <li>This object is purely geometric and built as a <code>PolyhedralSet</code>.</li> <li>All geometric operations (sampling, Chebyshev center, projection,   extreme points) are delegated to the underlying polyhedron.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_value_function(3, lambda S: float(len(S)))\n&gt;&gt;&gt; cc = CoreCover(g)\n&gt;&gt;&gt; cc.is_empty()\nFalse\n&gt;&gt;&gt; cc.sample_point()\n[1.0, 1.0, 1.0]\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Underlying polyhedral representation of the core cover.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Compute the Chebyshev center of the core cover.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).chebyshev_center()\n([0.5, 0.5], 0.0)\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.check","title":"check","text":"<pre><code>check(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Return core-cover membership diagnostics for \\(x\\).</p> Notes <p>This delegates to <code>tucoopy.diagnostics.core_cover_diagnostics.core_cover_diagnostics</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).check([0.5, 0.5]).in_set\nTrue\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check if \\(x\\) belongs to the core cover.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.explain","title":"explain","text":"<pre><code>explain(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Return a short human-readable explanation of core-cover membership.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).explain([0.5, 0.5])\n['In the core cover.']\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points of the core cover (small dimension).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).extreme_points(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Check if the core cover is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).is_empty()\nFalse\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the core cover onto selected dimensions.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).project((0,), max_dim=2)\n[[0.0], [1.0]]\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Sample a feasible point from the core cover.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).sample_point()\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/core_cover_set/#tucoopy.geometry.core_cover_set.CoreCover.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Vertices of the core cover (small dimension).</p> Notes <p>This delegates to <code>extreme_points</code> for consistency with other set-valued objects.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import CoreCover\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; CoreCover(g).vertices(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/core_set/","title":"<code>tucoopy.geometry.core_set</code>","text":""},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set--core-as-a-polyhedral-set-and-a-set-valued-wrapper","title":"Core as a polyhedral set and a set-valued wrapper.","text":"<p>This module provides:</p> <ul> <li><code>core_polyhedron</code>: build the core in H-representation,</li> <li><code>Core</code>: a thin wrapper exposing a <code>Core.poly</code> and delegating common   operations to it (membership, sampling, vertex enumeration for small \\(n\\)).</li> </ul> Notes <p>The core is described by one equality (efficiency) and one inequality per non-empty proper coalition. For large \\(n\\), enumerating all inequalities is expensive; most geometry helpers in this package assume \"small \\(n\\)\" workflows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; Core(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core","title":"Core  <code>dataclass</code>","text":"<p>Core as a set-valued object (polyhedron).</p> <p>This is a thin wrapper around <code>core_polyhedron</code> providing convenience methods such as membership tests, sampling, and (small-n) vertex enumeration.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>restrict_to_imputation</code> <code>bool</code> <p>If True, use individual-rationality bounds <code>x_i &gt;= v({i})</code> when building the underlying polyhedron.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt;\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; C = Core(g)\n&gt;&gt;&gt; C.contains([1.0, 1.0, 1.0])\nTrue\n&gt;&gt;&gt; C.vertices()\n[[1.0, 1.0, 1.0]]\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Underlying polyhedral representation of the core.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; C = Core(g)\n&gt;&gt;&gt; C.poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Chebyshev center of the core polyhedron (if non-empty).</p> <p>Returns:</p> Type Description <code>(x, r) | None</code> <p><code>x</code> is the center and <code>r</code> is the radius of the largest Euclidean ball contained in the core (as computed by the underlying backend). Returns None if the core is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; cc = Core(g).chebyshev_center()\n&gt;&gt;&gt; cc is not None\nTrue\n&gt;&gt;&gt; x, r = cc\n&gt;&gt;&gt; Core(g).contains(x)  # center is feasible\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.check","title":"check","text":"<pre><code>check(x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=8)\n</code></pre> <p>Return core-membership diagnostics for \\(x\\).</p> Notes <p>This method delegates to <code>tucoopy.diagnostics.core_diagnostics.core_diagnostics</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; Core(g).check([0.5, 0.5]).in_core\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Membership test: check whether \\(x\\) lies in the core.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if <code>x</code> satisfies efficiency and all core inequalities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; C = Core(g)\n&gt;&gt;&gt; C.contains([1.0, 1.0, 1.0])\nTrue\n&gt;&gt;&gt; C.contains([2.0, 0.0, 0.0])  # violates some coalitional constraints\nFalse\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.explain","title":"explain","text":"<pre><code>explain(x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=3)\n</code></pre> <p>Return a short human-readable explanation of core membership.</p> <p>This delegates to :func:<code>tucoopy.diagnostics.core_diagnostics.explain_core_membership</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; Core(g).explain([0.5, 0.5])[0].startswith(\"In the core\")\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points of the core polyhedron via the underlying polyhedral representation.</p> <p>This is a more general (but potentially more expensive) alternative to <code>vertices</code>, delegated to the polyhedral backend.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance for feasibility and de-duplication.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Safety limit for the backend enumeration routine.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list of list of float</code> <p>Extreme points of the core, or an empty list if the core is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; C = Core(g)\n&gt;&gt;&gt; eps = C.extreme_points()\n&gt;&gt;&gt; len(eps) &gt; 0\nTrue\n&gt;&gt;&gt; all(C.contains(x) for x in eps)\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Check whether the core is empty.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the underlying polyhedron is infeasible.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; empty = Game.from_coalitions(\n...     n_players=3,\n...     values={\n...         (): 0.0,\n...         (0,): 1.0, (1,): 1.0, (2,): 1.0,\n...         (0, 1): 2.0, (0, 2): 2.0, (1, 2): 2.0,\n...         (0, 1, 2): 2.0,\n...     },\n... )\n&gt;&gt;&gt; Core(empty).is_empty()\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the core polyhedron onto a subset of coordinates.</p> <p>This is useful for visualization in low dimensions (e.g. 2D/3D plots of the core by selecting two or three players).</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>tuple[int, ...] | list[int]</code> <p>Indices of players (coordinates) to keep in the projection.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for the backend projection routine.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Safety limit for the backend routine.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list of list of float</code> <p>Vertices of the projected polytope.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; C = Core(g)\n&gt;&gt;&gt; # Project core onto players 0 and 1\n&gt;&gt;&gt; proj = C.project((0, 1))\n&gt;&gt;&gt; len(proj) &gt; 0\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Return an arbitrary feasible point in the core, if any.</p> <p>Returns:</p> Type Description <code>list[float] | None</code> <p>A feasible core allocation, or None if the core is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; x = Core(g).sample_point()\n&gt;&gt;&gt; x is not None\nTrue\n&gt;&gt;&gt; Core(g).contains(x)\nTrue\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.Core.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate core vertices (small \\(n\\)).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import Core\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; Core(g).vertices()\n[[1.0, 1.0, 1.0]]\n</code></pre>"},{"location":"reference/geometry/core_set/#tucoopy.geometry.core_set.core_polyhedron","title":"core_polyhedron","text":"<pre><code>core_polyhedron(game, *, restrict_to_imputation=False)\n</code></pre> <p>Core as a polyhedral set in H-representation.</p> Constraints <ul> <li>Efficiency:</li> </ul> \\[\\sum_{i=1}^n x_i = v(N)\\] <ul> <li>Coalitional rationality (core constraints):</li> </ul> \\[x(S) \\geq v(S) \\text{ for all non-empty proper coalitions } S\\] <p>If <code>restrict_to_imputation=True</code>, also enforce individual rationality \\(x_i \\geq v(\\{i\\})\\) via bounds.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>restrict_to_imputation</code> <code>bool</code> <p>If True, add bounds <code>x_i &gt;= v({i})</code>. This can be useful for numerical stability when sampling/centers, but note the core is already a subset of the imputation set for TU games.</p> <code>False</code> <p>Returns:</p> Type Description <code>PolyhedralSet</code> <p>A polyhedral set in H-representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import core_polyhedron\n&gt;&gt;&gt;\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda ps: float(len(ps)))\n&gt;&gt;&gt; poly = core_polyhedron(g)\n&gt;&gt;&gt; poly.contains([1.0, 1.0, 1.0])\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Same object but with explicit individual-rationality bounds:\n&gt;&gt;&gt; poly2 = core_polyhedron(g, restrict_to_imputation=True)\n&gt;&gt;&gt; poly2.contains([1.0, 1.0, 1.0])\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/","title":"<code>tucoopy.geometry.epsilon_core_set</code>","text":""},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set--epsilon-core-as-a-polyhedral-set-and-a-set-valued-wrapper","title":"Epsilon-core as a polyhedral set and a set-valued wrapper.","text":"<p>This module defines the epsilon-core constraints</p> <p>\\(x(S) \\geq v(S) - \\epsilon\\) for all non-empty proper coalitions \\(S\\),</p> <p>plus efficiency. It provides both:</p> <ul> <li>polyhedral constructors (H-representation), and</li> <li><code>EpsilonCore</code>, a convenience wrapper exposing <code>EpsilonCore.poly</code>.</li> </ul> Notes <p>The epsilon-core is a key building block for the least-core and for LP-based explanations (e.g. \"most violated coalition\").</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore","title":"EpsilonCore  <code>dataclass</code>","text":"<p>Epsilon-core polytope as a set-valued object.</p> <p>This is a thin wrapper around <code>epsilon_core_polyhedron(...)</code> that exposes convenience methods like containment, sampling, Chebyshev center, projections, and (small-\\(n\\)) brute-force vertex enumeration.</p> <p>Attributes:</p> Name Type Description <code>game</code> <code>Game</code> <p>TU game.</p> <code>epsilon</code> <code>float</code> <p>Relaxation parameter epsilon.</p> <code>restrict_to_imputation</code> <code>bool</code> <p>If True, intersect with individual rationality bounds x_i &gt;= v({i}).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; C = EpsilonCore(g, epsilon=0.0)\n&gt;&gt;&gt; C.contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>The underlying polyhedral representation (H-rep).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Compute a Chebyshev center of the epsilon-core (if available).</p> <p>Returns:</p> Type Description <code>(x, r) or None</code> <p>x is the center point and r is the radius of the largest inscribed ball.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).chebyshev_center()\n([0.5, 0.5], 0.0)\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.check","title":"check","text":"<pre><code>check(x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=8)\n</code></pre> <p>Return epsilon-core membership diagnostics for <code>x</code>.</p> Notes <p>This delegates to :func:<code>tucoopy.diagnostics.epsilon_core_diagnostics.epsilon_core_diagnostics</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).check([0.5, 0.5]).in_set\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check whether x lies in the epsilon-core (within tolerance).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.explain","title":"explain","text":"<pre><code>explain(x, *, tol=DEFAULT_GEOMETRY_TOL, top_k=3)\n</code></pre> <p>Return a short human-readable explanation of epsilon-core membership.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).explain([0.5, 0.5])[0].startswith(\"In the epsilon-core\")\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points of the epsilon-core (backend-dependent).</p> Notes <p>This method delegates to <code>PolyhedralSet.extreme_points</code> and may be more robust to degeneracy than the brute-force <code>vertices</code> method, depending on the backend implementation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).extreme_points(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Return True if the epsilon-core polytope is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).is_empty()\nFalse\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the epsilon-core onto selected coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>tuple[int, ...] | list[int]</code> <p>Coordinates to keep (e.g., (0,1) for a 2D projection).</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Safety cap for projection dimension in the backend.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Extreme points of the projected polytope (backend-dependent).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).project((0,), max_dim=2)\n[[0.0], [1.0]]\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Attempt to find any feasible point in the epsilon-core.</p> <p>Returns None if the set is empty or if the backend fails to find a point.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).sample_point()\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.EpsilonCore.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate vertices of the epsilon-core polytope (small \\(n\\)).</p> <p>This is intended mainly for visualization and delegates to <code>PolyhedralSet.extreme_points</code> via <code>poly</code>.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance used for feasibility and de-duplication.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_players</code> <code>int</code> <p>Safety cap. This method is exponential in n and intended for small n.</p> <code>DEFAULT_GEOMETRY_MAX_PLAYERS</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>List of epsilon-core vertices, or an empty list if the epsilon-core is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import EpsilonCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; EpsilonCore(g, epsilon=0.0).vertices(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.LeastCorePolytope","title":"LeastCorePolytope  <code>dataclass</code>","text":"<p>Container for the least-core polytope (small-n visualization output).</p> <p>Attributes:</p> Name Type Description <code>epsilon</code> <code>float</code> <p>Least-core epsilon (minimum relaxation that makes the epsilon-core non-empty).</p> <code>vertices</code> <code>list[list[float]]</code> <p>Vertices of the least-core polytope (computed via brute-force enumeration).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lc = LeastCorePolytope(epsilon=0.0, vertices=[[1.0, 1.0, 1.0]])\n&gt;&gt;&gt; lc.epsilon\n0.0\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.epsilon_core_polyhedron","title":"epsilon_core_polyhedron","text":"<pre><code>epsilon_core_polyhedron(\n    game, epsilon, *, restrict_to_imputation=False\n)\n</code></pre> <p>Build the epsilon-core as a <code>PolyhedralSet</code> (H-representation).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>epsilon</code> <code>float</code> <p>Relaxation parameter epsilon.</p> required <code>restrict_to_imputation</code> <code>bool</code> <p>If True, also enforce individual rationality bounds x_i &gt;= v({i}).</p> <code>False</code> <p>Returns:</p> Type Description <code>PolyhedralSet</code> <p>The epsilon-core polyhedron represented as linear equalities/inequalities.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.epsilon_core_set import epsilon_core_polyhedron\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\n&gt;&gt;&gt; poly = epsilon_core_polyhedron(g, epsilon=0.0)\n&gt;&gt;&gt; poly.contains([1.0, 1.0, 1.0])\nTrue\n</code></pre>"},{"location":"reference/geometry/epsilon_core_set/#tucoopy.geometry.epsilon_core_set.least_core_polytope","title":"least_core_polytope","text":"<pre><code>least_core_polytope(\n    game,\n    *,\n    restrict_to_imputation=False,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n)\n</code></pre> <p>Compute the least-core epsilon and (small-\\(n\\)) vertices of the least-core set.</p> <p>The least-core is the epsilon-core with the smallest epsilon for which the epsilon-core is non-empty. This function:</p> <ol> <li>computes least-core epsilon via an LP (SciPy/HiGHS),</li> <li>enumerates vertices of the resulting epsilon-core (small \\(n\\), brute force).</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>restrict_to_imputation</code> <code>bool</code> <p>If True, also enforce individual rationality bounds \\(x_i \\geq v(\\{i\\})\\).</p> <code>False</code> <code>tol</code> <code>float</code> <p>Numerical tolerance passed to the LP solver and vertex enumeration.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_players</code> <code>int</code> <p>Safety cap for brute-force vertex enumeration.</p> <code>DEFAULT_GEOMETRY_MAX_PLAYERS</code> <p>Returns:</p> Type Description <code>LeastCorePolytope</code> <p>Object containing (epsilon, vertices).</p> Requires <p>SciPy at runtime (install with: <code>pip install \"tucoopy[lp]\"</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.epsilon_core_set import least_core_polytope\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\n&gt;&gt;&gt; lc = least_core_polytope(g)\n&gt;&gt;&gt; lc.epsilon\n0.0\n&gt;&gt;&gt; lc.vertices\n[[1.0, 1.0, 1.0]]\n</code></pre>"},{"location":"reference/geometry/imputation_set/","title":"<code>tucoopy.geometry.imputation_set</code>","text":""},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set--imputation-and-pre-imputation-sets","title":"Imputation and pre-imputation sets.","text":"<p>This module provides polyhedral representations of:</p> <ul> <li>the pre-imputation set (efficiency only), and</li> <li>the imputation set (efficiency + individual rationality).</li> </ul> <p>The imputation set is an intersection of an affine hyperplane with box constraints, and is therefore polyhedral.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationProjection","title":"ImputationProjection  <code>dataclass</code>","text":"<p>Output of <code>project_to_imputation</code>.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Projected allocation (same dimension as the input vector).</p> <code>feasible</code> <code>bool</code> <p><code>False</code> if the imputation set is empty, i.e.</p> <p>$$     \\sum_{i=1}^n v({i}) &gt; v(N).</p> <code>$$</code> <p>In this case, <code>x</code> is returned unchanged (a copy of the input).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = ImputationProjection(x=[0.5, 0.5], feasible=True)\n&gt;&gt;&gt; p.feasible\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet","title":"ImputationSet  <code>dataclass</code>","text":"<p>Imputation set wrapper (efficiency + individual rationality).</p> <p>This wrapper exposes both polyhedral operations and diagnostics specialized for imputation membership.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Examples:</p> <p>::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, S: int) -&gt; float:\n...         return {1: 1.0, 2: 2.0, 3: 5.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; I = ImputationSet(_G())\n&gt;&gt;&gt; I.contains([1.0, 4.0])\nTrue\n&gt;&gt;&gt; I.explain([0.5, 4.5])[0].startswith(\"Violates\")\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Underlying polyhedral representation (efficiency + IR bounds).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Compute the Chebyshev center (if supported by the backend).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).chebyshev_center()\n([0.5, 0.5], 0.0)\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.check","title":"check","text":"<pre><code>check(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Compute imputation-set diagnostics for \\(x\\).</p> <p>Delegates to <code>tucoopy.diagnostics.imputation_diagnostics.imputation_diagnostics</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>Any</code> <p>Diagnostics object with fields such as <code>in_set</code>, <code>efficient</code>, <code>sum_x</code>, <code>vN</code> and potential IR violations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).check([0.5, 0.5]).in_set\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Test membership via the polyhedral representation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>x</code> is in the imputation set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.explain","title":"explain","text":"<pre><code>explain(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Produce a short human-readable explanation of membership.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>A list of message lines. Empty list is avoided; when <code>x</code> is in the set, a single affirmative line is returned.</p> <p>Examples:</p> <p>::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, S: int) -&gt; float:\n...         return {1: 1.0, 2: 2.0, 3: 5.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; ImputationSet(_G()).explain([1.0, 4.0])\n['In the imputation set.']\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points (when representable).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).extreme_points(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Return whether the imputation set is empty.</p> Notes <p>The imputation set is empty iff</p> \\[     \\sum_{i=1}^n v(\\{i\\}) &gt; v(N). \\] <p>(subject to numerical tolerance inside the polyhedral backend).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).is_empty()\nFalse\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the set onto selected coordinates (returns projected vertices when representable).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).project((0,), max_dim=2)\n[[0.0], [1.0]]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Try to sample one point from the imputation set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ImputationSet(g).sample_point()\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.ImputationSet.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_IMPUTATION_SAMPLE_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Return the vertices of the imputation set (closed form).</p> <p>The imputation set is a shifted simplex:</p> \\[ \\left\\{ x : \\sum_{i=1}^n x_i = v(N),\\ x_i \\ge v(\\{i\\}) \\right\\}. \\] <p>Let</p> \\[ l_i = v(\\{i\\}), \\qquad r = v(N) - \\sum_{i=1}^n l_i. \\] <ul> <li>If \\(r &gt; 0\\), the vertices are \\(l + r e_i\\) for \\(i=0,\\ldots,n-1\\).</li> <li>If \\(r = 0\\), the set is the single point \\(l\\).</li> <li>If \\(r &lt; 0\\), the set is empty.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance used to decide whether <code>r</code> is negative/zero.</p> <code>DEFAULT_IMPUTATION_SAMPLE_TOL</code> <code>max_players</code> <code>int</code> <p>Guardrail: this closed-form enumeration is intended for small <code>n</code>.</p> <code>DEFAULT_GEOMETRY_MAX_PLAYERS</code> <code>max_dim</code> <code>int</code> <p>Present for API consistency with other geometric sets; not used here.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Vertices of the imputation set, or <code>[]</code> if empty.</p> <p>Examples:</p> <p>3 players, singleton values (1,2,0) and v(N)=10 =&gt; r=7, vertices are l+7e_i::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 3\n...     grand_coalition = 7\n...     def value(self, S: int) -&gt; float:\n...         return {1: 1.0, 2: 2.0, 4: 0.0, 7: 10.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; I = ImputationSet(_G())\n&gt;&gt;&gt; I.vertices()\n[[8.0, 2.0, 0.0], [1.0, 9.0, 0.0], [1.0, 2.0, 7.0]]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet","title":"PreImputationSet  <code>dataclass</code>","text":"<p>Pre-imputation set wrapper.</p> <p>This is a convenience wrapper around <code>preimputation_polyhedron</code> exposing common geometric operations.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Examples:</p> <p>::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 3\n...     grand_coalition = 7\n...     def value(self, S: int) -&gt; float:\n...         return 10.0 if S == 7 else 0.0\n...\n&gt;&gt;&gt; P = PreImputationSet(_G())\n&gt;&gt;&gt; P.contains([1.0, 2.0, 7.0])\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Underlying polyhedral representation (efficiency only).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Compute the Chebyshev center (if defined by the backend).</p> <p>Returns:</p> Type Description <code>(center, radius) or None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).chebyshev_center()\n([0.5, 0.5], 0.0)\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.check","title":"check","text":"<pre><code>check(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Run allocation diagnostics for \\(x\\).</p> <p>This is a convenience hook that delegates to <code>tucoopy.diagnostics.checks.check_allocation</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>Any</code> <p>The diagnostics object returned by <code>check_allocation</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).check([0.5, 0.5]).efficient\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Test membership in the pre-imputation set.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Allocation vector.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>sum(x) = v(N)</code> within tolerance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).contains([0.25, 0.75])\nTrue\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points (when the set is bounded in the projected space).</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension for vertex enumeration (backend-dependent safeguard).</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>List of vertices/extreme points.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).extreme_points(max_dim=2)\n[]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Return whether the pre-imputation set is empty.</p> Notes <p>For standard TU games, \\(\\sum_{i=1}^n x_i = v(N)\\)$ with free bounds is non-empty. Emptiness can occur only if the underlying polyhedral machinery considers the constraint system infeasible (e.g. NaNs).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).is_empty()\nFalse\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the set onto a subset of coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>tuple[int, ...] | list[int]</code> <p>Indices of coordinates to keep (e.g. <code>(0, 1)</code>).</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Maximum dimension for vertex enumeration.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Vertices of the projected polytope (when representable).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).project((0,), max_dim=2)\n[]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.PreImputationSet.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Try to sample one point from the set.</p> <p>Returns:</p> Type Description <code>list[float] | None</code> <p>A feasible point, or <code>None</code> if sampling fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import PreImputationSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; PreImputationSet(g).sample_point()\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.imputation_lower_bounds","title":"imputation_lower_bounds","text":"<pre><code>imputation_lower_bounds(game)\n</code></pre> <p>Compute the individual-rationality lower bounds for the imputation set.</p> <p>In a TU cooperative game with characteristic function \\(v\\), the imputation set requires individual rationality:</p> \\[     x_i \\ge v(\\{i\\}), \\quad i=1,\\dots,n. \\] <p>Define the lower bounds</p> \\[     l_i := v(\\{i\\}). \\] <p>This function returns the vector \\(l = (l_1,\\dots,l_n)\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>The lower bounds <code>[l_0, ..., l_{n-1}]</code> with <code>l_i = v({i})</code>.</p> <p>Examples:</p> <p>Minimal runnable example using a tiny dummy game (3 players)::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 3\n...     grand_coalition = (1 &lt;&lt; 3) - 1\n...     def value(self, S: int) -&gt; float:\n...         # singleton values: v({0})=1, v({1})=2, v({2})=0.5\n...         return {1: 1.0, 2: 2.0, 4: 0.5}.get(S, 0.0)\n...\n&gt;&gt;&gt; imputation_lower_bounds(_G())\n[1.0, 2.0, 0.5]\n</code></pre> Notes <ul> <li>Coalitions are encoded as bitmasks: <code>{i}</code> is <code>1 &lt;&lt; i</code>.</li> <li>The returned bounds are floats.</li> </ul>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.imputation_polyhedron","title":"imputation_polyhedron","text":"<pre><code>imputation_polyhedron(game)\n</code></pre> <p>Return the imputation set as a polyhedral set (H-representation).</p> <p>The imputation set is the intersection of the efficiency hyperplane with the individual-rationality halfspaces:</p> \\[     \\left\\{ x : \\sum_{i=1}^n x_i = v(N),\\ x_i \\ge v(\\{i\\}) \\right\\}. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>PolyhedralSet</code> <p>H-representation using a single equality constraint and per-player lower bounds.</p> <p>Examples:</p> <p>A 2-player game with <code>v(N)=5</code> and singleton values <code>(1,2)</code>::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, S: int) -&gt; float:\n...         return {1: 1.0, 2: 2.0, 3: 5.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; poly = imputation_polyhedron(_G())\n&gt;&gt;&gt; poly.contains([1.0, 4.0])\nTrue\n&gt;&gt;&gt; poly.contains([0.5, 4.5])  # violates x0 &gt;= 1\nFalse\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.is_in_imputation_set","title":"is_in_imputation_set","text":"<pre><code>is_in_imputation_set(game, x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Test whether an allocation belongs to the imputation set.</p> <p>The imputation set for a TU game \\(v\\) is the set of allocations that are:</p> <ul> <li>Efficient (feasible for the grand coalition):</li> </ul> \\[       \\sum_{i=1}^n x_i = v(N) \\] <ul> <li>Individually rational:</li> </ul> \\[       x_i \\ge v(\\{i\\}), \\quad i=1,\\dots,n. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used in comparisons. Efficiency is checked with <code>abs(sum(x) - v(N)) &lt;= tol</code> and individual rationality with <code>x_i + tol &gt;= v({i})</code>.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p><code>True</code> if <code>x</code> is efficient and individually rational; otherwise <code>False</code>.</p> <p>Examples:</p> <p>A 2-player dummy game where \\(v(\\{0\\})=1\\), \\(v(\\{1\\})=2\\), \\(v(N)=5\\)::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, S: int) -&gt; float:\n...         return {1: 1.0, 2: 2.0, 3: 5.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; is_in_imputation_set(_G(), [1.0, 4.0])\nTrue\n&gt;&gt;&gt; is_in_imputation_set(_G(), [0.9, 4.1])  # violates x0 &gt;= 1\nFalse\n&gt;&gt;&gt; is_in_imputation_set(_G(), [1.0, 3.9])  # not efficient (sum != 5)\nFalse\n</code></pre> Notes <p>This is a lightweight membership check. For richer diagnostics, use <code>ImputationSet.check</code> / <code>ImputationSet.explain</code>.</p>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.preimputation_polyhedron","title":"preimputation_polyhedron","text":"<pre><code>preimputation_polyhedron(game)\n</code></pre> <p>Return the pre-imputation set as a polyhedral (affine) set.</p> <p>The pre-imputation set consists of allocations that satisfy only efficiency:</p> \\[     \\sum_{i=1}^n x_i = v(N), \\] <p>with no lower bounds \\(x_i \\ge v(\\{i\\})\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>PolyhedralSet</code> <p>H-representation of the affine set <code>sum(x)=v(N)</code> with free bounds.</p> <p>Examples:</p> <p>For a 3-player game with <code>v(N)=10</code> , the set is the plane <code>x0+x1+x_2=10</code>::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 3\n...     grand_coalition = 7\n...     def value(self, S: int) -&gt; float:\n...         return 10.0 if S == 7 else 0.0\n...\n&gt;&gt;&gt; poly = preimputation_polyhedron(_G())\n&gt;&gt;&gt; poly.contains([3.0, 3.0, 4.0])\nTrue\n&gt;&gt;&gt; poly.contains([3.0, 3.0, 3.9])\nFalse\n</code></pre>"},{"location":"reference/geometry/imputation_set/#tucoopy.geometry.imputation_set.project_to_imputation","title":"project_to_imputation","text":"<pre><code>project_to_imputation(\n    game, x_hat, *, tol=DEFAULT_IMPUTATION_SAMPLE_TOL\n)\n</code></pre> <p>Compute the Euclidean projection onto the imputation set.</p> <p>The imputation set is</p> \\[ \\mathcal{I}(v) = \\left\\{ x : \\sum_{i=1}^n x_i = v(N),\\ x_i \\ge v(\\{i\\}) \\right\\}. \\] <p>This routine returns the closest point (in Euclidean norm) in $\\mathcal{I}(v)<code>to a given vector $\\hat{x} \\in \\mathbb{R}^n</code>.</p> Algorithm <p>Let <code>l_i = v({i})</code> and <code>r = v(N) - sum_i l_i</code>.</p> <ol> <li>Shift: <code>y = x_hat - l</code>.</li> <li>Project <code>y</code> onto the simplex <code>{z: z&gt;=0, sum(z)=r}</code>.</li> <li>Shift back: <code>x = l + z</code>.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x_hat</code> <code>list[float]</code> <p>Arbitrary vector in $\\mathbb{R}^n` (must have length <code>n_players</code>).</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance used to decide emptiness / degeneracy of the imputation set.</p> <code>DEFAULT_IMPUTATION_SAMPLE_TOL</code> <p>Returns:</p> Type Description <code>ImputationProjection</code> <p><code>x</code> is the projected allocation. If the imputation set is empty, returns <code>feasible=False</code> and <code>x</code> is a copy of <code>x_hat</code>.</p> <p>Examples:</p> <p>2 players, singleton bounds <code>(1,2)</code> and <code>v(N)=5</code> =&gt; imputation is segment between <code>(3,2)</code> and <code>(1,4)</code>. Projecting <code>[10, -10]</code> lands at the nearest endpoint::</p> <pre><code>&gt;&gt;&gt; class _G:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, S: int) -&gt; float:\n...         return {1: 1.0, 2: 2.0, 3: 5.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; proj = project_to_imputation(_G(), [10.0, -10.0])\n&gt;&gt;&gt; proj.feasible\nTrue\n&gt;&gt;&gt; round(sum(proj.x), 10)\n5.0\n&gt;&gt;&gt; proj.x[0] &gt;= 1.0 and proj.x[1] &gt;= 2.0\nTrue\n</code></pre> <p>Empty imputation set example (<code>sum singletons &gt; v(N)</code>)::</p> <pre><code>&gt;&gt;&gt; class _Bad:\n...     n_players = 2\n...     grand_coalition = 3\n...     def value(self, S: int) -&gt; float:\n...         return {1: 5.0, 2: 5.0, 3: 3.0}.get(S, 0.0)\n...\n&gt;&gt;&gt; proj = project_to_imputation(_Bad(), [0.0, 0.0])\n&gt;&gt;&gt; proj.feasible\nFalse\n</code></pre> Notes <ul> <li>This is a projection in \\(\\ell_2\\). It does not guarantee any   game-theoretic property beyond imputation feasibility.</li> <li>If \\(r\\) is numerically zero, the imputation set collapses to the   single point \\(l\\).</li> </ul>"},{"location":"reference/geometry/kernel_set/","title":"<code>tucoopy.geometry.kernel_set</code>","text":""},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set--kernel-and-pre-kernel-set-valued-sampling-based-diagnostics","title":"Kernel and pre-kernel (set-valued, sampling-based diagnostics).","text":"<p>This module provides <code>KernelSet</code> / <code>PreKernelSet</code> helpers aimed at \"small n\" usage and diagnostics workflows.</p> <p>The kernel and pre-kernel are defined via pairwise surplus comparisons and are not polyhedral in general. The implementation therefore relies on:</p> <ul> <li>fast surplus evaluation helpers, and</li> <li>sampling points from the imputation set to probe membership / produce examples.</li> </ul> Notes <p>For large games, kernel/pre-kernel computations can be expensive. This module exposes explicit iteration limits and sampling limits to keep the runtime under control.</p> <p>Examples:</p> <p>Instantiate the set-valued helpers for a small 3-player game:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import PreKernelSet, KernelSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; isinstance(PreKernelSet(g), PreKernelSet)\nTrue\n&gt;&gt;&gt; isinstance(KernelSet(g), KernelSet)\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelCheckResult","title":"KernelCheckResult  <code>dataclass</code>","text":"<p>Result of a kernel membership check.</p> <p>Attributes:</p> Name Type Description <code>in_set</code> <code>bool</code> <p>True if the point passes the kernel test within tolerance.</p> <code>efficient</code> <code>bool</code> <p>Efficiency flag (sum x = v(N)).</p> <code>imputation</code> <code>bool</code> <p>Imputation flag (efficiency + individual rationality).</p> <code>max_violation</code> <code>float</code> <p>Maximum kernel complementarity violation detected.</p> <code>required_bounds</code> <code>list[int]</code> <p>List of players that, according to dominance relations, must be at their individual rationality bound (x_i = v({i})) for kernel membership.</p> <code>pairs</code> <code>list[PairSurplusDiagnostics]</code> <p>A (possibly truncated) list of per-pair surplus diagnostics, sorted by decreasing |delta|.</p> Notes <p>Kernel membership (for imputations) can be stated as:</p> <ul> <li>x is an imputation</li> <li>for each pair (i, j):   if :math:<code>s_{ij}(x) &gt; s_{ji}(x)</code> then player j must be at its lower bound   :math:<code>x_j = v(\\{j\\})</code>.</li> </ul> <p>Equivalently, whenever both i and j are interior (strictly above bounds), we must have :math:<code>s_{ij}(x)=s_{ji}(x)</code> within tolerance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry.kernel_set import KernelCheckResult\n&gt;&gt;&gt; res = KernelCheckResult(in_set=False, efficient=True, imputation=False, max_violation=1.0, required_bounds=[0], pairs=[])\n&gt;&gt;&gt; res.in_set\nFalse\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelCheckResult.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a JSON-friendly dict.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelResult","title":"KernelResult  <code>dataclass</code>","text":"<p>Result container for the kernel iteration (imputation-constrained).</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Candidate kernel allocation (length <code>n_players</code>), intended to lie in the imputation set (efficiency + individual rationality).</p> <code>iterations</code> <code>int</code> <p>Number of outer iterations performed.</p> <code>residual</code> <code>float</code> <p>A measure of kernel complementarity violation used as stopping criterion.</p> <code>delta</code> <code>float</code> <p>Maximum absolute coordinate update in the last iteration.</p> <code>argmax</code> <code>dict[tuple[int, int], int]</code> <p>Dictionary mapping ordered pairs (i, j) to an argmax coalition mask achieving \\(s_{ij}(x)\\) at the returned point.</p> <code>active_bounds</code> <code>set[int]</code> <p>Active-set of players clamped at individual rationality bounds (\\(x_i = v(\\{i\\})\\)) at the returned point.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet","title":"KernelSet  <code>dataclass</code>","text":"<p>Kernel set (set-valued).</p> Definition <p>Kernel membership (for imputations) can be stated as:</p> <ul> <li>x is an imputation (efficiency + individual rationality)</li> <li>for each pair (i, j):   if :math:<code>s_{ij}(x) &gt; s_{ji}(x)</code> (by more than tolerance),   then player j must be at its lower bound: :math:<code>x_j = v(\\{j\\})</code>.</li> </ul> <p>Equivalently, whenever both i and j are interior (:math:<code>x_i &gt; v(\\{i\\})</code> and :math:<code>x_j &gt; v(\\{j\\})</code>), we must have :math:<code>s_{ij}(x) = s_{ji}(x)</code> within tolerance.</p> Practical notes <ul> <li>Checking membership is exponential in n (coalition enumeration).</li> <li>This class is intended for small-n diagnostics/visualization.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Default tolerance used in membership tests.</p> <code>DEFAULT_KERNEL_TOL</code> <code>max_iter</code> <code>int</code> <p>Iteration limit used by <code>element()</code> (solver).</p> <code>DEFAULT_KERNEL_MAX_ITER</code> <code>max_players</code> <code>int</code> <p>Safety cap for exponential routines.</p> <code>DEFAULT_KERNEL_MAX_PLAYERS</code> <code>approx_max_coalitions_per_pair</code> <code>int | None</code> <p>If provided, approximate each pairwise surplus by checking only this many random coalitions per ordered pair (i, j).</p> <code>DEFAULT_KERNEL_APPROX_MAX_COALITIONS_PER_PAIR</code> <code>approx_seed</code> <code>int | None</code> <p>Random seed used for the approximation.</p> <code>DEFAULT_KERNEL_APPROX_SEED</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import KernelSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; ks = KernelSet(g)\n&gt;&gt;&gt; out = ks.check([1.0, 1.0, 2.0], top_k=2)\n&gt;&gt;&gt; isinstance(out.in_set, bool)\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet.check","title":"check","text":"<pre><code>check(x, *, tol=None, top_k=8)\n</code></pre> <p>Compute a kernel membership check plus pairwise surplus diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Candidate allocation (length <code>n_players</code>).</p> required <code>tol</code> <code>float | None</code> <p>Optional override tolerance.</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Include at most this many (i, j) diagnostic entries.</p> <code>8</code> <p>Returns:</p> Type Description <code>KernelCheckResult</code> <p>Membership result + diagnostics.</p> <p>Raises:</p> Type Description <code>NotSupportedError</code> <p>If <code>n_players</code> is above <code>max_players</code>.</p> <code>InvalidParameterError</code> <p>If <code>x</code> has the wrong length.</p> <p>Examples:</p> <p>Minimal 2-player game (kernel coincides with the imputation segment):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import KernelSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; ks = KernelSet(g)\n&gt;&gt;&gt; ks.check([0.5, 0.5]).imputation\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet.contains","title":"contains","text":"<pre><code>contains(x, *, tol=None)\n</code></pre> <p>Return True iff x is in the kernel (within tolerance).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Candidate allocation.</p> required <code>tol</code> <code>float | None</code> <p>Optional override tolerance.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet.element","title":"element","text":"<pre><code>element()\n</code></pre> <p>Compute one representative kernel element using the iterative solver.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>A candidate kernel allocation (intended to lie in the imputation set).</p> Notes <p>Uses the iterative solver implemented in this module.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet.explain","title":"explain","text":"<pre><code>explain(x, *, tol=None, top_k=3)\n</code></pre> <p>Return a short human-readable explanation of kernel membership.</p> Notes <p>This is a thin wrapper around <code>check</code>.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet.sample_point","title":"sample_point","text":"<pre><code>sample_point(\n    *, n_samples=5000, seed=None, max_points=50, tol=None\n)\n</code></pre> <p>Return one kernel point found by sampling, or None.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>5000</code> <code>seed</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>5000</code> <code>max_points</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>5000</code> <code>tol</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>5000</code> <p>Returns:</p> Type Description <code>list[float] | None</code>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.KernelSet.sample_points","title":"sample_points","text":"<pre><code>sample_points(\n    *, n_samples=5000, seed=None, max_points=50, tol=None\n)\n</code></pre> <p>Heuristically search for kernel points by sampling the imputation set.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Number of imputations to sample.</p> <code>5000</code> <code>seed</code> <code>int | None</code> <p>Optional RNG seed.</p> <code>None</code> <code>max_points</code> <code>int</code> <p>Stop once this many passing points are found.</p> <code>50</code> <code>tol</code> <code>float | None</code> <p>Optional override tolerance for membership testing.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Up to <code>max_points</code> candidate kernel points found by sampling.</p> Notes <ul> <li>Intended for visualization and debugging (small n).</li> <li>Does not guarantee finding any point, even if the kernel is non-empty.</li> <li>Points are de-duplicated with a cheap L-infinity rule within tolerance.</li> </ul>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PairSurplusDiagnostics","title":"PairSurplusDiagnostics  <code>dataclass</code>","text":"<p>Diagnostics for a player pair (i, j) at an allocation x.</p> <p>Fields correspond to:</p> <ul> <li><code>s_ij</code>: :math:<code>\\max_{S: i\\in S,\\ j\\notin S} e(S,x)</code></li> <li><code>s_ji</code>: :math:<code>\\max_{S: j\\in S,\\ i\\notin S} e(S,x)</code></li> <li><code>delta</code>: <code>s_ij - s_ji</code></li> <li><code>argmax_ij</code> / <code>argmax_ji</code>: coalition masks achieving the maxima   (tie-broken by smaller mask)</li> </ul> Notes <p>The argmax masks are useful to understand which coalitions witness the surplus imbalance for a given pair.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry.kernel_set import PairSurplusDiagnostics\n&gt;&gt;&gt; d = PairSurplusDiagnostics(i=0, j=1, s_ij=0.5, s_ji=0.25, delta=0.25, argmax_ij=3, argmax_ji=5)\n&gt;&gt;&gt; d.delta\n0.25\n&gt;&gt;&gt; isinstance(d.to_dict(), dict)\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PairSurplusDiagnostics.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a JSON-friendly dict.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelCheckResult","title":"PreKernelCheckResult  <code>dataclass</code>","text":"<p>Result of a pre-kernel membership check.</p> <p>Attributes:</p> Name Type Description <code>in_set</code> <code>bool</code> <p>True if the point passes the pre-kernel test within tolerance.</p> <code>efficient</code> <code>bool</code> <p>Efficiency flag (sum x = v(N)).</p> <code>max_abs_delta</code> <code>float</code> <p>Maximum absolute surplus imbalance:</p> <p>.. math::</p> <pre><code>\\max_{i&lt;j} |s_{ij}(x) - s_{ji}(x)|.\n</code></pre> <code>pairs</code> <code>list[PairSurplusDiagnostics]</code> <p>A (possibly truncated) list of per-pair diagnostics, sorted by decreasing |delta|.</p> Notes <ul> <li>The pre-kernel condition requires efficiency and the equalities   :math:<code>s_{ij}(x)=s_{ji}(x)</code> for all i != j.</li> <li><code>pairs</code> is intended for debugging/visualization: it contains the worst   offending pairs.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry.kernel_set import PairSurplusDiagnostics, PreKernelCheckResult\n&gt;&gt;&gt; pairs = [PairSurplusDiagnostics(i=0, j=1, s_ij=0.0, s_ji=0.0, delta=0.0, argmax_ij=1, argmax_ji=2)]\n&gt;&gt;&gt; res = PreKernelCheckResult(in_set=True, efficient=True, max_abs_delta=0.0, pairs=pairs)\n&gt;&gt;&gt; res.in_set\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelCheckResult.to_dict","title":"to_dict","text":"<pre><code>to_dict()\n</code></pre> <p>Convert to a JSON-friendly dict.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelResult","title":"PreKernelResult  <code>dataclass</code>","text":"<p>Result container for the pre-kernel iteration.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Candidate pre-kernel allocation (length <code>n_players</code>).</p> <code>iterations</code> <code>int</code> <p>Number of outer iterations performed.</p> <code>residual</code> <code>float</code> <p>Final maximum surplus imbalance:</p> \\[ \\max_{i&lt;j} |s_{ij}(x) - s_{ji}(x)|. \\] <code>delta</code> <code>float</code> <p>Maximum absolute coordinate update in the last iteration.</p> <code>argmax</code> <code>dict[tuple[int, int], int]</code> <p>Dictionary mapping ordered pairs (i, j) to an argmax coalition mask achieving \\(s_{ij}(x)\\) at the returned point.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet","title":"PreKernelSet  <code>dataclass</code>","text":"<p>Pre-kernel set (set-valued).</p> Definition <p>A (pre-)kernel element x (typically in the pre-imputation set) satisfies:</p> <ul> <li>efficiency: :math:<code>\\sum_i x_i = v(N)</code></li> <li>pairwise surplus equalities: :math:<code>s_{ij}(x) = s_{ji}(x)</code> for all i != j</li> </ul> <p>where :math:<code>s_{ij}(x)</code> is the maximum excess over coalitions containing i and excluding j.</p> Practical notes <ul> <li>Checking membership is exponential in n because it enumerates coalitions   to compute argmax surpluses.</li> <li>This class is meant for small-n visualization and diagnostics.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Default tolerance used in membership tests.</p> <code>DEFAULT_KERNEL_TOL</code> <code>max_iter</code> <code>int</code> <p>Iteration limit used by <code>element()</code> (solver).</p> <code>DEFAULT_KERNEL_MAX_ITER</code> <code>max_players</code> <code>int</code> <p>Safety cap for exponential routines.</p> <code>DEFAULT_KERNEL_MAX_PLAYERS</code> <code>approx_max_coalitions_per_pair</code> <code>int | None</code> <p>If provided, approximate each pairwise surplus by checking only this many random coalitions per ordered pair (i, j). This keeps <code>O(2^n)</code> DP for coalition sums but avoids scanning all admissible coalitions per pair.</p> <code>DEFAULT_KERNEL_APPROX_MAX_COALITIONS_PER_PAIR</code> <code>approx_seed</code> <code>int | None</code> <p>Random seed used for the approximation.</p> <code>DEFAULT_KERNEL_APPROX_SEED</code> <p>Examples:</p> <p>Run a basic check (the returned object contains detailed diagnostics):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import PreKernelSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; pk = PreKernelSet(g)\n&gt;&gt;&gt; out = pk.check([1.0, 1.0, 2.0], top_k=2)\n&gt;&gt;&gt; isinstance(out.in_set, bool)\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet.check","title":"check","text":"<pre><code>check(x, *, tol=None, top_k=8)\n</code></pre> <p>Compute a pre-kernel membership check plus pairwise surplus diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Candidate allocation (length <code>n_players</code>).</p> required <code>tol</code> <code>float | None</code> <p>Optional override tolerance.</p> <code>None</code> <code>top_k</code> <code>int</code> <p>Include at most this many (i, j) diagnostic entries (largest imbalances).</p> <code>8</code> <p>Returns:</p> Type Description <code>PreKernelCheckResult</code> <p>Membership result + diagnostics.</p> <p>Raises:</p> Type Description <code>NotSupportedError</code> <p>If <code>n_players</code> is above <code>max_players</code>.</p> <code>InvalidParameterError</code> <p>If <code>x</code> has the wrong length.</p> <p>Examples:</p> <p>Minimal 3-player example (complete characteristic function):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import PreKernelSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0:0, 1:0, 2:0, 4:0,\n...     3:0, 5:0, 6:0,\n...     7:1,\n... })\n&gt;&gt;&gt; pk = PreKernelSet(g)\n&gt;&gt;&gt; x = [1/3, 1/3, 1/3]\n&gt;&gt;&gt; pk.check(x).efficient\nTrue\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet.contains","title":"contains","text":"<pre><code>contains(x, *, tol=None)\n</code></pre> <p>Return True iff x is in the pre-kernel (within tolerance).</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[float]</code> <p>Candidate allocation.</p> required <code>tol</code> <code>float | None</code> <p>Optional override tolerance.</p> <code>None</code> <p>Returns:</p> Type Description <code>bool</code>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet.element","title":"element","text":"<pre><code>element()\n</code></pre> <p>Compute one representative pre-kernel element using the iterative solver.</p> <p>Returns:</p> Type Description <code>list[float]</code> <p>A candidate pre-kernel allocation.</p> Notes <p>Uses the iterative solver implemented in this module.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet.explain","title":"explain","text":"<pre><code>explain(x, *, tol=None, top_k=3)\n</code></pre> <p>Return a short human-readable explanation of pre-kernel membership.</p> Notes <p>This is a thin wrapper around <code>check</code>.</p>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet.sample_point","title":"sample_point","text":"<pre><code>sample_point(\n    *, n_samples=2000, seed=None, max_points=50, tol=None\n)\n</code></pre> <p>Return one pre-kernel point found by sampling, or None.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>2000</code> <code>seed</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>2000</code> <code>max_points</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>2000</code> <code>tol</code> <code>int</code> <p>Forwarded to <code>sample_points</code>.</p> <code>2000</code> <p>Returns:</p> Type Description <code>list[float] | None</code>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.PreKernelSet.sample_points","title":"sample_points","text":"<pre><code>sample_points(\n    *, n_samples=2000, seed=None, max_points=50, tol=None\n)\n</code></pre> <p>Heuristically search for pre-kernel points by sampling the imputation set.</p> <p>This routine draws random imputations and returns those that pass the pre-kernel test (within tolerance).</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Number of imputations to sample.</p> <code>2000</code> <code>seed</code> <code>int | None</code> <p>Optional RNG seed.</p> <code>None</code> <code>max_points</code> <code>int</code> <p>Stop once this many passing points are found.</p> <code>50</code> <code>tol</code> <code>float | None</code> <p>Optional override tolerance for membership testing.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Up to <code>max_points</code> candidate pre-kernel points found by sampling.</p> Notes <ul> <li>Intended for visualization and debugging (small n).</li> <li>Does not guarantee finding any point, even if the set is non-empty.</li> </ul>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.kernel","title":"kernel","text":"<pre><code>kernel(\n    game,\n    *,\n    x0=None,\n    tol=DEFAULT_KERNEL_TOL,\n    max_iter=DEFAULT_KERNEL_MAX_ITER,\n    approx_max_coalitions_per_pair=DEFAULT_KERNEL_APPROX_MAX_COALITIONS_PER_PAIR,\n    approx_seed=DEFAULT_KERNEL_APPROX_SEED,\n)\n</code></pre> <p>Compute a (candidate) kernel element.</p> Background <p>The kernel refines the pre-kernel by imposing a complementarity condition with respect to the imputation set. Using the same surplus definition \\(s_{ij}(x)\\) as in the pre-kernel, the kernel condition can be stated as:</p> <ul> <li>For each pair \\((i, j)\\), if player \\(i\\) has strictly larger surplus against \\(j\\),   i.e. \\(s_{ij}(x) &gt; s_{ji}(x)\\), then player \\(j\\) must be at its individual   rationality bound: \\(x_j = v(\\{j\\})\\).</li> </ul> <p>This prevents a player with \"weaker bargaining position\" from receiving more than their minimal guaranteed payoff.</p> Method (active-set heuristic) <p>This implementation is a practical small-n solver:</p> <ol> <li>Maintain \\(x\\) in the imputation set (efficiency + individual rationality),    using projection.</li> <li>Maintain an active-set <code>active_bounds</code> of players clamped at their    individual rationality bounds.</li> <li>From the current \\(x\\), derive which bounds must be active based on surplus    dominance relations.</li> <li>With a fixed active-set, solve pre-kernel equalities (in least-squares form)    for the remaining free players, then project back to the imputation set.</li> <li>Repeat until:</li> <li>argmax selections stabilize,</li> <li>the active-set stabilizes,</li> <li>kernel violations are below tolerance.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x0</code> <code>list[float] | None</code> <p>Optional initial allocation. If omitted, the Shapley value is used as a starting point, then projected into the imputation set.</p> <code>None</code> <code>tol</code> <code>float</code> <p>Tolerance used for dominance comparisons and stopping conditions.</p> <code>DEFAULT_KERNEL_TOL</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations.</p> <code>DEFAULT_KERNEL_MAX_ITER</code> <code>approx_max_coalitions_per_pair</code> <code>int | None</code> <p>If provided, approximate each surplus <code>s_ij(x)</code> by evaluating at most this many candidate coalitions for each ordered pair (i, j).</p> <code>DEFAULT_KERNEL_APPROX_MAX_COALITIONS_PER_PAIR</code> <code>approx_seed</code> <code>int | None</code> <p>Random seed used when <code>approx_max_coalitions_per_pair</code> is set.</p> <code>DEFAULT_KERNEL_APPROX_SEED</code> <p>Returns:</p> Type Description <code>KernelResult</code> <p>Candidate kernel point and iteration diagnostics.</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the imputation set is empty (i.e. \\(\\sum_i v(\\{i\\}) &gt; v(N)\\)).</p> Notes <ul> <li>This is a heuristic implementation intended primarily for small games   (e.g. \\(n \\leq 4\\)) and visualization use-cases.</li> <li>Requires NumPy (<code>pip install \"tucoopy[fast]\"</code>) for least-squares solves.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import kernel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Additive game: kernel is the equal split\n&gt;&gt;&gt; g = Game.from_value_function(\n...     n_players=3,\n...     value_fn=lambda ps: float(len(ps)),\n... )\n&gt;&gt;&gt; res = kernel(g, tol=1e-10, max_iter=200)\n&gt;&gt;&gt; [round(v, 8) for v in res.x]\n[1.0, 1.0, 1.0]\n&gt;&gt;&gt; res.residual &lt;= 1e-8\nTrue\n&gt;&gt;&gt;\n&gt;&gt;&gt; # If the imputation set is empty, kernel() raises InvalidGameError:\n&gt;&gt;&gt; bad = Game.from_coalitions(\n...     n_players=2,\n...     values={\n...         (): 0.0,\n...         (0,): 2.0,\n...         (1,): 2.0,\n...         (0, 1): 1.0,  # v(N) &lt; v({0}) + v({1})\n...     },\n... )\n&gt;&gt;&gt; kernel(bad)\nTraceback (most recent call last):\n    ...\nInvalidGameError: kernel undefined: imputation set is empty (sum v({i}) &gt; v(N))\n</code></pre>"},{"location":"reference/geometry/kernel_set/#tucoopy.geometry.kernel_set.prekernel","title":"prekernel","text":"<pre><code>prekernel(\n    game,\n    *,\n    x0=None,\n    tol=DEFAULT_KERNEL_TOL,\n    max_iter=DEFAULT_KERNEL_MAX_ITER,\n    relax=1.0,\n    approx_max_coalitions_per_pair=DEFAULT_KERNEL_APPROX_MAX_COALITIONS_PER_PAIR,\n    approx_seed=DEFAULT_KERNEL_APPROX_SEED,\n)\n</code></pre> <p>Compute a (candidate) pre-kernel element.</p> Background <p>For an allocation \\(x \\in \\mathbb{R}^n\\), define the pairwise surplus:</p> \\[ s_{ij}(x) = \\max_{S: i \\in S,\\ j \\notin S} \\left[v(S) - x(S)\\right]. \\] <p>The pre-kernel is the set of allocations \\(x\\) such that</p> \\[ s_{ij}(x) = s_{ji}(x) \\quad \\text{for all } i \\ne j. \\] Method <p>This routine implements a practical fixed-point style iteration:</p> <ol> <li>Given the current allocation \\(x\\), compute argmax coalitions \\(S_{ij}\\) for each    ordered pair \\((i,j)\\) (so that \\(S_{ij}\\) achieves \\(s_{ij}(x)\\)).</li> <li>Freeze these argmax coalitions and enforce the equalities</li> </ol> \\[ s_{ij}(x) = s_{ji}(x) \\iff x(S_{ji}) - x(S_{ij}) = v(S_{ji}) - v(S_{ij}) \\] <p>for all \\(i&lt;j\\).</p> <ol> <li>Solve the resulting (typically overdetermined) linear system in a least-squares    sense, adding the efficiency constraint \\(\\sum_i x_i = v(N)\\).</li> <li>Optionally apply a damped update controlled by <code>relax</code>.</li> <li>Repeat until argmax selections stabilize and the maximum surplus imbalance is    below tolerance.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x0</code> <code>list[float] | None</code> <p>Optional initial allocation. If omitted, the Shapley value is used as a starting point.</p> <code>None</code> <code>tol</code> <code>float</code> <p>Stopping tolerance for both surplus imbalance and coordinate changes.</p> <code>DEFAULT_KERNEL_TOL</code> <code>max_iter</code> <code>int</code> <p>Maximum number of iterations.</p> <code>DEFAULT_KERNEL_MAX_ITER</code> <code>relax</code> <code>float</code> <p>Relaxation parameter in (0, 1]. Values below 1 damp updates and can improve stability in degenerate cases.</p> <code>1.0</code> <code>approx_max_coalitions_per_pair</code> <code>int | None</code> <p>If provided, approximate each surplus <code>s_ij(x)</code> by evaluating at most this many candidate coalitions for each ordered pair (i, j), sampled uniformly without replacement from the admissible set <code>{S: i in S, j not in S}</code>. This reduces per-iteration cost substantially for n &gt; ~10.</p> <code>DEFAULT_KERNEL_APPROX_MAX_COALITIONS_PER_PAIR</code> <code>approx_seed</code> <code>int | None</code> <p>Random seed used when <code>approx_max_coalitions_per_pair</code> is set.</p> <code>DEFAULT_KERNEL_APPROX_SEED</code> <p>Returns:</p> Type Description <code>PreKernelResult</code> <p>Candidate pre-kernel point and iteration diagnostics.</p> Notes <ul> <li>This is a numerical heuristic intended for small games and visualization.   Convergence is not guaranteed for all games.</li> <li>Requires NumPy (<code>pip install \"tucoopy[fast]\"</code>) for least-squares solves.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.kernel_set import prekernel\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Additive game: v(S) = |S|\n&gt;&gt;&gt; g = Game.from_value_function(\n...     n_players=3,\n...     value_fn=lambda ps: float(len(ps)),\n... )\n&gt;&gt;&gt; res = prekernel(g, tol=1e-10, max_iter=200)\n&gt;&gt;&gt; [round(v, 8) for v in res.x]\n[1.0, 1.0, 1.0]\n&gt;&gt;&gt; res.residual &lt;= 1e-8\nTrue\n</code></pre>"},{"location":"reference/geometry/least_core_set/","title":"<code>tucoopy.geometry.least_core_set</code>","text":""},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set--least-core-set-valued-object-lp-helpers","title":"Least-core (set-valued object + LP helpers).","text":"<p>The least-core is the epsilon-core with the smallest feasible <code>epsilon*</code>. This module defines <code>LeastCore</code> as a thin wrapper that:</p> <ul> <li>computes/stores the optimal <code>epsilon*</code> (when an LP backend is available),</li> <li>exposes a corresponding <code>tucoopy.geometry.EpsilonCore</code> / polyhedron, and</li> <li>provides convenience methods for membership and small-n geometry operations.</li> </ul> <p>In addition, this module provides LP-based helpers to compute <code>epsilon*</code> and select representative points from the least-core polytope.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; lc = LeastCore(g)\n&gt;&gt;&gt; lc.contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore","title":"LeastCore  <code>dataclass</code>","text":"<p>Least-core as a set-valued object.</p> Background <p>For a TU game, the (standard) core is the set of efficient allocations that satisfy all coalitional constraints:</p> \\[ \\sum_i x_i = v(N), \\qquad x(S) \\ge v(S) \\; \\text{for all } \\varnothing \\ne S \\subsetneq N. \\] <p>When the core is empty, a common relaxation is the epsilon-core:</p> \\[ \\sum_i x_i = v(N), \\qquad x(S) \\ge v(S) - \\varepsilon \\; \\text{for all } \\varnothing \\ne S \\subsetneq N. \\] <p>The least-core is the epsilon-core at the smallest relaxation level \\(\\varepsilon^*\\) for which the epsilon-core becomes non-empty:</p> \\[ \\varepsilon^* = \\min\\{\\varepsilon \\ge 0 : \\text{epsilon-core}(\\varepsilon) \\ne \\varnothing\\}. \\] <p>This class is a thin wrapper around <code>EpsilonCore(game, epsilon*)</code>, computed lazily on first access.</p> Lazy evaluation / dependencies <p>The value <code>epsilon</code> is computed on demand via <code>least_core_epsilon_star</code> in this module (which requires an LP backend at runtime, typically via <code>pip install \"tucoopy[lp]\"</code>). Once computed, it is cached in <code>_epsilon</code>.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>restrict_to_imputation</code> <code>bool</code> <p>If True, additionally enforce individual rationality <code>x_i &gt;= v({i})</code> (handled as bounds) when forming the underlying polyhedron. This selects the least-core within the imputation set.</p> <code>False</code> <code>tol</code> <code>float</code> <p>Numerical tolerance forwarded to the LP solver and set-membership checks.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>_epsilon</code> <code>float | None</code> <p>Optional cached value for <code>epsilon</code> (internal). If provided, the LP solve is skipped.</p> <code>None</code> <p>Attributes:</p> Name Type Description <code>epsilon</code> <code>float</code> <p>The least-core value <code>epsilon*</code> (computed lazily and cached).</p> <code>epsilon_core</code> <code>EpsilonCore</code> <p>The epsilon-core object at <code>epsilon*</code>.</p> <code>poly</code> <code>PolyhedralSet</code> <p>The underlying polyhedral representation (<code>PolyhedralSet</code>) of the least-core.</p> Notes <ul> <li><code>LeastCore</code> is set-valued. If you need a single-valued selector, use   a routine like <code>least_core_point</code> (e.g., Chebyshev center) on top of this set.</li> <li>The method <code>vertices</code> enumerates vertices using a brute-force routine intended   for small n (visualization).</li> </ul> <p>Examples:</p> <p>Minimal example (may have empty core; least-core always exists for TU games under this LP formulation):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\n&gt;&gt;&gt; lc = LeastCore(g)\n&gt;&gt;&gt; eps = lc.epsilon\n&gt;&gt;&gt; eps\n0.0\n&gt;&gt;&gt; lc.sample_point()  # one least-core point (here also core point)\n[1.0, 1.0, 1.0]\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.epsilon","title":"epsilon  <code>property</code>","text":"<pre><code>epsilon\n</code></pre> <p>Least-core value <code>epsilon*</code> (computed lazily).</p> Notes <p>This requires an LP backend (typically SciPy/HiGHS via <code>tucoopy[lp]</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).epsilon\n0.0\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.epsilon_core","title":"epsilon_core  <code>property</code>","text":"<pre><code>epsilon_core\n</code></pre> <p>Epsilon-core object at <code>epsilon*</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; lc = LeastCore(g)\n&gt;&gt;&gt; lc.epsilon_core.epsilon\n0.0\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Underlying polyhedral representation of the least-core.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Compute the Chebyshev center of the least-core polytope.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).chebyshev_center()\n([0.5, 0.5], 0.0)\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.check","title":"check","text":"<pre><code>check(x, *, tol=None, top_k=8)\n</code></pre> <p>Return least-core membership diagnostics for \\(x\\).</p> Notes <p>This delegates to <code>tucoopy.diagnostics.least_core_diagnostics.least_core_diagnostics</code>. If the LP backend is unavailable, the returned diagnostics will have <code>available=False</code>.</p>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.contains","title":"contains","text":"<pre><code>contains(x, *, tol=None)\n</code></pre> <p>Check whether x lies in the least-core (within tolerance).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.explain","title":"explain","text":"<pre><code>explain(x, *, tol=None, top_k=3)\n</code></pre> <p>Return a short human-readable explanation of least-core membership.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).explain([0.5, 0.5])[0]\n'In the least-core (epsilon*=0).'\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points of the least-core (small dimension).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).extreme_points(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Return True if the least-core polytope is empty.</p> Notes <p>This delegates to the underlying epsilon-core polyhedron. Requires an LP backend.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).is_empty()\nFalse\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the least-core to selected coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).project((0,), max_dim=2)\n[[0.0], [1.0]]\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Attempt to sample one point from the least-core.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).sample_point()\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.LeastCore.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate vertices of the least-core polytope (small dimension).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import LeastCore\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; LeastCore(g).vertices(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.least_core","title":"least_core","text":"<pre><code>least_core(game, *, tol=1e-09)\n</code></pre> <p>Compute a least-core allocation and the least-core epsilon.</p> Notes <p>Requires an LP backend at runtime (<code>pip install \"tucoopy[lp]\"</code>).</p>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.least_core_epsilon_star","title":"least_core_epsilon_star","text":"<pre><code>least_core_epsilon_star(game, *, tol=1e-09)\n</code></pre> <p>Compute the least-core value epsilon*.</p>"},{"location":"reference/geometry/least_core_set/#tucoopy.geometry.least_core_set.least_core_point","title":"least_core_point","text":"<pre><code>least_core_point(\n    game,\n    *,\n    restrict_to_imputation=False,\n    tol=1e-09,\n    method=\"chebyshev_center\",\n)\n</code></pre> <p>Select a single allocation from the least-core set.</p>"},{"location":"reference/geometry/polyhedron/","title":"<code>tucoopy.geometry.polyhedron</code>","text":""},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron--polyhedral-sets-h-representation-for-geometry-modules","title":"Polyhedral sets (H-representation) for geometry modules.","text":"<p>This module defines <code>PolyhedralSet</code>, a small wrapper around linear constraints in the form:</p> <ul> <li>inequalities: \\(A_{ub} x \\leq b_{ub}\\)</li> <li>equalities: \\(A_{eq} x = b_{eq}\\)</li> <li>variable bounds: \\(l_i \\leq x_i \\leq u_i\\)</li> </ul> <p>It provides core operations used across <code>tucoopy.geometry</code>:</p> <ul> <li>feasibility checks and extracting a sample point (LP),</li> <li>membership tests,</li> <li>Chebyshev center (LP),</li> <li>(small-\\(n\\)) vertex enumeration and projection.</li> </ul> Notes <p>This class is intentionally lightweight and relies on the configured LP backend. For large-dimensional polytopes, vertex enumeration is not feasible; helpers in this module are explicitly guarded by <code>max_dim</code> limits.</p> <p>Examples:</p> <p>A 2D triangle (simplex): x&gt;=0, y&gt;=0, x+y&lt;=1.</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(\n...     A_ub=[[-1, 0], [0, -1], [1, 1]],\n...     b_ub=[0, 0, 1],\n... )\n&gt;&gt;&gt; P.extreme_points()\n[[0.0, 0.0], [0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet","title":"PolyhedralSet  <code>dataclass</code>","text":"<p>Polyhedral set in H-representation with optional bounds.</p> Definition <p>A polyhedral set (polyhedron) in \\(\\mathbb{R}\\) is described by linear equalities, linear inequalities, and coordinate bounds:</p> \\[ A_{ub} x \\le b_{ub}, \\\\ A_{eq} x  = b_{eq}, \\\\ l_i \\le x_i \\le u_i. \\] <p>This class is a lightweight geometry utility intended to support set-valued solution objects (core, epsilon-core, least-core, etc.) and visualization tasks such as: - feasibility checks, - sampling a feasible point, - Chebyshev center, - enumerating extreme points in small dimension (brute-force), - projecting extreme points to selected coordinates.</p> Notes <ul> <li>LP-based methods require an LP backend (SciPy/HiGHS or PuLP via your <code>linprog_solve</code> wrapper).</li> <li>The <code>extreme_points</code> enumerator is exponential and intended only for   small dimension (visualization).</li> </ul> <p>Attributes:</p> Name Type Description <code>A_ub, b_ub</code> <p>Inequality constraints <code>A_ub x &lt;= b_ub</code>.</p> <code>A_eq, b_eq</code> <p>Equality constraints <code>A_eq x = b_eq</code>.</p> <code>bounds</code> <code>list[tuple[float | None, float | None]]</code> <p>Per-coordinate bounds <code>(lb, ub)</code>; each side may be None.</p> <p>Examples:</p> <p>A 2D triangle: x&gt;=0, y&gt;=0, x+y&lt;=1.</p> <pre><code>&gt;&gt;&gt; P = PolyhedralSet.from_hrep(\n...     A_ub=[[ -1,  0], [ 0, -1], [1, 1]],\n...     b_ub=[  0,  0, 1],\n... )\n&gt;&gt;&gt; P.contains([0.2, 0.3])\nTrue\n&gt;&gt;&gt; P.contains([0.8, 0.3])\nFalse\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.n_vars","title":"n_vars  <code>property</code>","text":"<pre><code>n_vars\n</code></pre> <p>Dimension (number of variables) inferred from bounds or constraints.</p> <p>Returns:</p> Type Description <code>int</code> <p>The inferred dimension n.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the dimension cannot be inferred (no bounds and empty constraint matrices).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0), (None, None)])\n&gt;&gt;&gt; P.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.affine_dimension","title":"affine_dimension","text":"<pre><code>affine_dimension(*, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Estimate the affine dimension of the equality/bound hull.</p> <p>This estimates the dimension of the affine subspace defined by:</p> <ul> <li>equalities: \\(A_{eq} x = b_{eq}\\), and</li> <li>fixed bounds: \\(x_i = l_i = u_i\\).</li> </ul> <p>The returned value is:</p> \\[\\dim \\approx n - \\mathrm{rank}(M),\\] <p>where \\(M\\) stacks the equality rows and the unit vectors for fixed coordinates.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance used in the rank estimate.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>int</code> <p>Estimated affine dimension in \\(\\{0,\\dots,n\\}\\).</p> Notes <ul> <li>This method does not check feasibility. For an empty set, the result is   a diagnostic estimate for the constraint hull rather than the set   itself.</li> <li>If there are no equalities and no fixed bounds, this returns \\(n\\).</li> </ul> <p>Examples:</p> <p>A line segment in 2D has affine dimension 1:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_eq=[[1.0, 1.0]], b_eq=[1.0], bounds=[(0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; P.affine_dimension()\n1\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Chebyshev center via LP (maximum inscribed ball).</p> <p>The Chebyshev center is the point maximizing the radius of an Euclidean ball contained in the polyhedron. For inequalities \\(a_k^T x \\leq b_k\\), the ball constraint becomes:</p> \\[ a_k^T x + \\|a_k\\|_2 \\, r \\le b_k, \\qquad r \\geq 0. \\] <p>Equalities are kept as \\(a^T x = b\\) (they do not involve \\(r\\)).</p> <p>Returns:</p> Type Description <code>(center, radius) | None</code> <p>The center <code>x</code> and radius <code>r</code> of the largest inscribed ball, or None if infeasible.</p> Notes <ul> <li>If there are no inequalities (only equalities/bounds), a meaningful   inscribed-ball radius is not defined in the same way. In that case we   return any feasible point and \\(r = +\\infty\\) as a sentinel.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_ub=[[1, 0], [0, 1], [-1, 0], [0, -1]], b_ub=[1, 1, 0, 0])\n&gt;&gt;&gt; center, r = P.chebyshev_center()\n&gt;&gt;&gt; r &gt;= 0\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.chebyshev_center_with_diag","title":"chebyshev_center_with_diag","text":"<pre><code>chebyshev_center_with_diag()\n</code></pre> <p>Chebyshev center via LP with diagnostics.</p> <p>Returns:</p> Type Description <code>(center_radius, result)</code> <p><code>center_radius</code> is <code>(x, r)</code> or None if infeasible. <code>result</code> is the LP backend result object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0)])\n&gt;&gt;&gt; (cc, res) = P.chebyshev_center_with_diag()\n&gt;&gt;&gt; cc is None or len(cc[0]) == 1\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check membership with tolerance.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Candidate point.</p> required <code>tol</code> <code>float</code> <p>Tolerance for bound checks, inequalities, and equalities.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if x satisfies all constraints within tolerance.</p> Notes <ul> <li>Inequalities are accepted if \\(A_{ub} x \\leq b_{ub} + \\text{tol}\\).</li> <li>Equalities are accepted if \\(|A_{eq} x - b_{eq}| \\leq \\text{tol}\\) row-wise.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_ub=[[1, 1]], b_ub=[1], bounds=[(0.0, None), (0.0, None)])\n&gt;&gt;&gt; P.contains([0.25, 0.25])\nTrue\n&gt;&gt;&gt; P.contains([0.75, 0.75])\nFalse\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points (vertices) for small-dimensional polytopes.</p> Method <p>A point is a vertex if it is the unique intersection of \\(n\\) linearly independent active constraints (equalities plus tight inequalities/bounds).</p> <p>This brute-force enumerator proceeds as follows:</p> <ol> <li>Convert variable bounds to additional inequalities.</li> <li>Choose \\(n - m_{eq}\\) inequalities to add to the \\(m_eq\\) equalities,    yielding a square linear system \\(A x = b\\).</li> <li>Solve this system.</li> <li>Keep the solution if it satisfies the original polyhedron constraints.</li> <li>De-duplicate solutions by quantizing coordinates.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance used both in the linear solve and membership tests.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Safety limit: only dimensions <code>n &lt;= max_dim</code> are supported.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>List of vertices, sorted lexicographically. Returns an empty list if no vertices are found.</p> Notes <ul> <li>This routine is exponential in the number of inequalities and is intended   for visualization (e.g. \\(n=2,3,4\\)) rather than serious polyhedral computation.</li> <li>Degenerate polytopes (many redundant/tied constraints) may require a larger   tolerance for stable de-duplication.</li> </ul> <p>Examples:</p> <p>Triangle in 2D:</p> <pre><code>&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_ub=[[-1,0],[0,-1],[1,1]], b_ub=[0,0,1])\n&gt;&gt;&gt; P.extreme_points()\n[[0.0, 0.0], [0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.from_hrep","title":"from_hrep  <code>classmethod</code>","text":"<pre><code>from_hrep(\n    *,\n    A_ub=None,\n    b_ub=None,\n    A_eq=None,\n    b_eq=None,\n    bounds=None,\n)\n</code></pre> <p>Construct a polyhedron from an H-representation.</p> <p>Parameters:</p> Name Type Description Default <code>A_ub</code> <code>Sequence[Sequence[float]] | None</code> <p>Inequality constraints <code>A_ub x &lt;= b_ub</code>. If omitted, no inequalities.</p> <code>None</code> <code>b_ub</code> <code>Sequence[Sequence[float]] | None</code> <p>Inequality constraints <code>A_ub x &lt;= b_ub</code>. If omitted, no inequalities.</p> <code>None</code> <code>A_eq</code> <code>Sequence[Sequence[float]] | None</code> <p>Equality constraints <code>A_eq x = b_eq</code>. If omitted, no equalities.</p> <code>None</code> <code>b_eq</code> <code>Sequence[Sequence[float]] | None</code> <p>Equality constraints <code>A_eq x = b_eq</code>. If omitted, no equalities.</p> <code>None</code> <code>bounds</code> <code>Sequence[tuple[float | None, float | None]] | None</code> <p>Optional bounds <code>(lb, ub)</code> per coordinate.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolyhedralSet</code> <p>A normalized polyhedral set.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If dimensions mismatch or the dimension cannot be inferred.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; # Unit square in 2D: 0&lt;=x&lt;=1, 0&lt;=y&lt;=1.\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; P.contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.is_bounded","title":"is_bounded","text":"<pre><code>is_bounded(*, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check boundedness by optimizing each coordinate (LP-based).</p> <p>A polyhedron is bounded iff every linear functional attains a finite maximum. As a practical diagnostic, this method checks whether each coordinate \\(x_i\\) has a finite minimum and maximum by solving \\(2n\\) LPs.</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Tolerance used to detect fixed bounds and to interpret solver output.</p> <code>DEFAULT_GEOMETRY_TOL</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if bounded (or empty), False if an unbounded direction is found.</p> Notes <ul> <li>Requires an LP backend at runtime.</li> <li>For large <code>n</code>, this can be expensive (\\(2n\\) solves).</li> <li>This method is intended mainly for guarding algorithms like hit-and-run.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; P.is_bounded()\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Feasibility check via LP.</p> <p>This solves a trivial feasibility LP (zero objective) and returns whether the LP solver finds any feasible point.</p> <p>Returns:</p> Type Description <code>bool</code> <p>True if the set is infeasible (empty); False otherwise.</p> Notes <p>Requires an LP backend at runtime (e.g. SciPy/HiGHS through <code>linprog_solve</code>).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; # Infeasible: x &lt;= 0 and x &gt;= 1.\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_ub=[[1], [-1]], b_ub=[0, -1])\n&gt;&gt;&gt; P.is_empty()\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.is_empty_with_diag","title":"is_empty_with_diag","text":"<pre><code>is_empty_with_diag()\n</code></pre> <p>Feasibility check via LP with diagnostics.</p> <p>Returns:</p> Type Description <code>(is_empty, result)</code> <p>Where <code>result</code> is the LP backend result object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_ub=[[1.0], [-1.0]], b_ub=[0.0, -1.0])\n&gt;&gt;&gt; empty, res = P.is_empty_with_diag()\n&gt;&gt;&gt; empty\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n    approx_n_points=None,\n    approx_seed=None,\n)\n</code></pre> <p>Project enumerated extreme points to selected coordinates (visualization helper).</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>Sequence[int]</code> <p>Indices of coordinates to keep.</p> required <code>tol</code> <code>float</code> <p>Passed to <code>extreme_points</code>.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Passed to <code>extreme_points</code>.</p> <code>DEFAULT_GEOMETRY_MAX_DIM</code> <code>approx_n_points</code> <code>int | None</code> <p>If provided and <code>n_vars &gt; max_dim</code>, use hit-and-run sampling to produce approximately projected points. This requires boundedness and an LP backend to find a starting point.</p> <code>None</code> <code>approx_seed</code> <code>int | None</code> <p>Optional RNG seed used by hit-and-run when <code>approx_n_points</code> is set.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Projected vertex list.</p> Notes <p>This is not a true polyhedral projection (which would require eliminating variables). It simply enumerates vertices in the full space (small \\(n\\)) and returns the selected coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0), (0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; # Project cube vertices to the first two coordinates.\n&gt;&gt;&gt; verts2 = P.project((0, 1), max_dim=3)\n&gt;&gt;&gt; [0.0, 0.0] in verts2 and [1.0, 1.0] in verts2\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.residual_eq","title":"residual_eq","text":"<pre><code>residual_eq(x)\n</code></pre> <p>Compute equality residuals \\(a_k^T x - b_k\\) for each equality row.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Point in R^n.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Residuals for each equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_eq=[[1, 1]], b_eq=[1], bounds=[(0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; P.residual_eq([0.25, 0.75])\n[0.0]\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Find any feasible point via LP.</p> <p>Returns:</p> Type Description <code>list[float] | None</code> <p>A feasible point if one exists, otherwise None.</p> Notes <p>This is a convenience wrapper around a feasibility LP with zero objective.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; x = P.sample_point()\n&gt;&gt;&gt; x is None or P.contains(x)\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.sample_point_with_diag","title":"sample_point_with_diag","text":"<pre><code>sample_point_with_diag()\n</code></pre> <p>Find any feasible point via LP with diagnostics.</p> <p>Returns:</p> Type Description <code>(x, result)</code> <p><code>x</code> is a feasible point if one exists, otherwise None. <code>result</code> is the LP backend result object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0)])\n&gt;&gt;&gt; x, res = P.sample_point_with_diag()\n&gt;&gt;&gt; x is None or P.contains(x)\nTrue\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.sample_points_hit_and_run","title":"sample_points_hit_and_run","text":"<pre><code>sample_points_hit_and_run(\n    n_points,\n    *,\n    start_point=None,\n    burn_in=DEFAULT_HIT_AND_RUN_BURN_IN,\n    thinning=DEFAULT_HIT_AND_RUN_THINNING,\n    seed=None,\n    tol=DEFAULT_HIT_AND_RUN_TOL,\n)\n</code></pre> <p>Sample points using hit-and-run within the polyhedron (approximate uniform sampling).</p> <p>This sampler: 1) starts from a feasible point (either <code>start_point</code> or <code>sample_point</code>), 2) repeatedly samples a random direction (restricted to the equality subspace), 3) computes the feasible segment along that direction using all inequalities    (including bounds encoded as inequalities), 4) samples uniformly on that segment.</p> <p>Parameters:</p> Name Type Description Default <code>n_points</code> <code>int</code> <p>Number of returned samples.</p> required <code>start_point</code> <code>Sequence[float] | None</code> <p>Optional feasible start point. If omitted, a start point is found via <code>sample_point</code> (which requires an LP backend, e.g. <code>tucoopy[lp]</code>).</p> <code>None</code> <code>burn_in</code> <code>int</code> <p>Number of initial steps discarded.</p> <code>DEFAULT_HIT_AND_RUN_BURN_IN</code> <code>thinning</code> <code>int</code> <p>Keep one sample every <code>thinning</code> steps after burn-in.</p> <code>DEFAULT_HIT_AND_RUN_THINNING</code> <code>seed</code> <code>int | None</code> <p>Random seed.</p> <code>None</code> <code>tol</code> <code>float</code> <p>Numerical tolerance used in feasibility checks.</p> <code>DEFAULT_HIT_AND_RUN_TOL</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Sampled points (each a length-n vector).</p> Notes <ul> <li>Requires a feasible start point. If <code>start_point</code> is not provided,   this method calls <code>sample_point</code>, which requires an LP backend.</li> <li>If the polyhedron is unbounded in a sampled direction (infinite segment),   this method raises ValueError because \"uniform\" sampling is not defined.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(bounds=[(0.0, 1.0), (0.0, 1.0)])\n&gt;&gt;&gt; pts = P.sample_points_hit_and_run(3, seed=0)\n&gt;&gt;&gt; len(pts)\n3\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.slack_eq","title":"slack_eq","text":"<pre><code>slack_eq(x)\n</code></pre> <p>Compute absolute equality slacks \\(|a_k^T x - b_k|\\) for each equality row.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Point in R^n.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Absolute residuals for each equality constraint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_eq=[[1.0, 1.0]], b_eq=[1.0])\n&gt;&gt;&gt; P.slack_eq([0.25, 0.75])\n[0.0]\n</code></pre>"},{"location":"reference/geometry/polyhedron/#tucoopy.geometry.polyhedron.PolyhedralSet.slack_ub","title":"slack_ub","text":"<pre><code>slack_ub(x)\n</code></pre> <p>Compute inequality slacks for the combined \\(A_{ub} x \\leq b_{ub}\\) system.</p> <p>This includes bound-inequalities (lb/ub converted to halfspaces) so it is suitable for \"tight set\" diagnostics.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Sequence[float]</code> <p>Point in R^n.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Slacks <code>b_k - a_k^T x</code> for each inequality row k.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.geometry import PolyhedralSet\n&gt;&gt;&gt; P = PolyhedralSet.from_hrep(A_ub=[[1]], b_ub=[1], bounds=[(0.0, None)])\n&gt;&gt;&gt; P.slack_ub([0.25])[0]\n0.75\n</code></pre>"},{"location":"reference/geometry/projection/","title":"<code>tucoopy.geometry.projection</code>","text":""},{"location":"reference/geometry/projection/#tucoopy.geometry.projection--coordinate-conversions-and-projections-for-visualization","title":"Coordinate conversions and projections for visualization.","text":"<p>This module contains helpers that map allocations <code>x</code> in the imputation hyperplane to convenient 2D/3D coordinates:</p> <ul> <li>barycentric coordinates on the imputation simplex (<code>n=3</code>),</li> <li>2D/3D embeddings used by the static Matplotlib visualizations in <code>tucoopy.viz</code>.</li> </ul> Notes <p>These helpers are intentionally simple and aimed at visualization and diagnostics. They are not intended as general-purpose dimensionality reduction tools.</p> <p>Examples:</p> <p>Convert a point in the imputation set to barycentric coordinates (n=3):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.projection import allocation_to_barycentric_imputation\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; b = allocation_to_barycentric_imputation(g, [1.0, 1.0, 2.0])\n&gt;&gt;&gt; (len(b), round(sum(b), 12))\n(3, 1.0)\n</code></pre>"},{"location":"reference/geometry/projection/#tucoopy.geometry.projection.allocation_to_barycentric_imputation","title":"allocation_to_barycentric_imputation","text":"<pre><code>allocation_to_barycentric_imputation(\n    game, x, *, tol=DEFAULT_IMPUTATION_SAMPLE_TOL\n)\n</code></pre> <p>Convert an allocation to barycentric coordinates of the imputation simplex.</p> Background <p>The imputation set of a TU game can be written as a shifted simplex:</p> \\[ x = l + r \\cdot b, \\] <p>where</p> <ul> <li>\\(l_i = v(\\{i\\})\\) are the individual rationality lower bounds,</li> <li>\\(r = v(N) - \\sum_i l_i\\) is the remaining distributable surplus,</li> <li>\\(b \\in \\mathbb{R}^n\\) satisfies</li> </ul> <p>$$   \\sum_i b_i = 1, \\qquad b_i \\ge 0.   $$</p> <p>The vector \\(b\\) is a set of barycentric coordinates inside the standard simplex, representing the position of \\(x\\) relative to the imputation simplex.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>) assumed to lie in the imputation set.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for detecting degenerate simplices.</p> <code>DEFAULT_IMPUTATION_SAMPLE_TOL</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Barycentric coordinates <code>b</code> such that <code>sum(b)=1</code> and <code>b&gt;=0</code>.</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the imputation simplex is empty or degenerate (\\(v(N) - \\sum_i v(\\{i\\}) \\le 0\\)).</p> Notes <p>These coordinates are the natural input for geometric visualizations of allocations in 2D (n=3) and 3D (n=4).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; b = allocation_to_barycentric_imputation(g, [1.0, 1.0, 1.0])\n&gt;&gt;&gt; sum(b)\n1.0\n</code></pre>"},{"location":"reference/geometry/projection/#tucoopy.geometry.projection.project_allocation","title":"project_allocation","text":"<pre><code>project_allocation(game, x, *, space='imputation_simplex')\n</code></pre> <p>Project an allocation to Euclidean coordinates for visualization.</p> Background <p>For small games, the imputation set is a simplex that can be embedded in low-dimensional Euclidean space:</p> <ul> <li>For <code>n=3</code>, the imputation simplex is a triangle in 2D.</li> <li>For <code>n=4</code>, the imputation simplex is a tetrahedron in 3D.</li> </ul> <p>This function:</p> <ol> <li>Converts the allocation to barycentric coordinates in the imputation simplex.</li> <li>Maps these barycentric coordinates to Cartesian coordinates using    canonical simplex embeddings.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>x</code> <code>list[float]</code> <p>Allocation vector in the imputation set.</p> required <code>space</code> <code>Literal['imputation_simplex']</code> <p>Currently only <code>\"imputation_simplex\"</code> is supported.</p> <code>'imputation_simplex'</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>2D coordinates (for n=3) or 3D coordinates (for n=4).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the space is unknown.</p> <code>NotSupportedError</code> <p>If the number of players is not supported for this projection.</p> Notes <p>This is intended for geometric plotting of solution concepts such as:</p> <ul> <li>Core</li> <li>Epsilon-core</li> <li>Least-core</li> <li>Kernel / Pre-kernel</li> <li>Nucleolus</li> <li>Tau value</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; project_allocation(g, [1.0, 1.0, 1.0])\n[x_coord, y_coord]\n</code></pre>"},{"location":"reference/geometry/reasonable_set/","title":"<code>tucoopy.geometry.reasonable_set</code>","text":""},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set--reasonable-set-polyhedral-superset-of-the-core","title":"Reasonable set (polyhedral superset of the core).","text":"<p>This module provides :class:<code>ReasonableSet</code>, which is the efficient box defined by per-player lower bounds (individual rationality) and upper bounds (utopia payoffs).</p> <p>The reasonable set is polyhedral and is often used as a computationally friendly outer approximation of the core.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet","title":"ReasonableSet  <code>dataclass</code>","text":"<p>Reasonable set as a polyhedral set.</p> Background <p>For a TU cooperative game, define for each player the utopia payoff</p> \\[ M_i = v(N) - v(N \\setminus \\{i\\}), \\] <p>which represents the maximum amount player \\(i\\) could conceivably receive without making the remaining players worse off than standing alone.</p> <p>The reasonable set is defined as</p> \\[ R = \\left\\{ x \\in \\mathbb{R}^n :     \\sum_i x_i = v(N), \\quad     v(\\{i\\}) \\le x_i \\le M_i \\ \\text{for all } i \\right\\}. \\] <p>It is the set of allocations that are:</p> <ul> <li>efficient (use the whole worth of the grand coalition),</li> <li>individually rational (\\(x_i \\ge v(\\{i\\})\\)),</li> <li>utopia-bounded (\\(x_i \\le M_i\\)).</li> </ul> <p>Geometrically, this is the intersection of the imputation simplex with the hyper-rectangle defined by the utopia payoffs.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Attributes:</p> Name Type Description <code>poly</code> <code>PolyhedralSet</code> <p>Underlying <code>PolyhedralSet</code> representing the reasonable set in H-representation.</p> Notes <ul> <li>The reasonable set always contains the tau-value (when defined).</li> <li>It is typically a superset of the core when the core is non-empty.</li> <li>For small n, <code>vertices()</code> can be used for visualization.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\n&gt;&gt;&gt; R = ReasonableSet(g)\n&gt;&gt;&gt; R.contains([1.0, 1.0, 1.0])\nTrue\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Underlying polyhedral representation of the reasonable set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).poly.n_vars\n2\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.chebyshev_center","title":"chebyshev_center","text":"<pre><code>chebyshev_center()\n</code></pre> <p>Chebyshev center of the reasonable set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).chebyshev_center()\n([0.5, 0.5], 0.0)\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.check","title":"check","text":"<pre><code>check(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Return reasonable-set membership diagnostics for <code>x</code>.</p> Notes <p>This delegates to :func:<code>tucoopy.diagnostics.reasonable_diagnostics.reasonable_set_diagnostics</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).check([0.5, 0.5]).in_set\nTrue\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.contains","title":"contains","text":"<pre><code>contains(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Check if x belongs to the reasonable set (within tolerance).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).contains([0.5, 0.5])\nTrue\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.explain","title":"explain","text":"<pre><code>explain(x, *, tol=DEFAULT_GEOMETRY_TOL)\n</code></pre> <p>Return a short human-readable explanation of reasonable-set membership.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).explain([0.5, 0.5])\n['In the reasonable set.']\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.extreme_points","title":"extreme_points","text":"<pre><code>extreme_points(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Enumerate extreme points (small dimension).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).extreme_points(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.is_empty","title":"is_empty","text":"<pre><code>is_empty()\n</code></pre> <p>Check if the reasonable set is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).is_empty()\nFalse\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.project","title":"project","text":"<pre><code>project(\n    dims,\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Project the reasonable set to selected coordinates.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).project((0,), max_dim=2)\n[[0.0], [1.0]]\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.sample_point","title":"sample_point","text":"<pre><code>sample_point()\n</code></pre> <p>Attempt to sample one point from the reasonable set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).sample_point()\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/reasonable_set/#tucoopy.geometry.reasonable_set.ReasonableSet.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=DEFAULT_GEOMETRY_MAX_DIM,\n)\n</code></pre> <p>Vertices of the reasonable set (small dimension).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import ReasonableSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 3: 1})\n&gt;&gt;&gt; ReasonableSet(g).vertices(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/sampling/","title":"<code>tucoopy.geometry.sampling</code>","text":""},{"location":"reference/geometry/sampling/#tucoopy.geometry.sampling--sampling-helpers-for-geometry-objects","title":"Sampling helpers for geometry objects.","text":"<p>This module focuses on sampling points from the imputation set (a shifted simplex) via a uniform Dirichlet sampler, which is useful for:</p> <ul> <li>visual debugging,</li> <li>approximate membership probing for non-polyhedral sets (kernel, bargaining set),</li> <li>generating example points for documentation.</li> </ul> <p>Examples:</p> <p>Sample imputations from a small 3-player game (deterministic with a seed):</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.sampling import sample_imputation_set\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; pts = sample_imputation_set(g, n_samples=5, seed=0)\n&gt;&gt;&gt; len(pts)\n5\n</code></pre>"},{"location":"reference/geometry/sampling/#tucoopy.geometry.sampling.sample_imputation_set","title":"sample_imputation_set","text":"<pre><code>sample_imputation_set(\n    game,\n    *,\n    n_samples,\n    seed=None,\n    tol=DEFAULT_IMPUTATION_SAMPLE_TOL,\n)\n</code></pre> <p>Sample points from the imputation set (shifted simplex).</p> <p>The imputation set is</p> \\[ I(v) = \\left\\{ x \\in \\mathbb{R}^n : \\sum_{i=1}^n x_i = v(N),\\; x_i \\ge v(\\{i\\}) \\right\\}. \\] <p>Let \\(\\ell_i = v(\\{i\\})\\) and \\(r = v(N) - \\sum_i \\ell_i\\). When \\(r \\ge 0\\), the imputation set is a translation of the standard simplex:</p> \\[ x = \\ell + r\\,b, \\qquad b \\ge 0,\\; \\sum_i b_i = 1. \\] <p>This routine samples \\(b\\) using a Dirichlet distribution with all parameters equal to 1 (uniform over the simplex in barycentric coordinates), then maps back to \\(x\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>n_samples</code> <code>int</code> <p>Number of points to sample (must be &gt;= 1).</p> required <code>seed</code> <code>int | None</code> <p>Optional seed for reproducibility (Python's <code>random.Random</code>).</p> <code>None</code> <code>tol</code> <code>float</code> <p>Numerical tolerance for detecting an empty or degenerate imputation set.</p> <code>DEFAULT_IMPUTATION_SAMPLE_TOL</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>A list of allocations in the imputation set.</p> <ul> <li>If the imputation set is empty (<code>r &lt; -tol</code>), returns <code>[]</code>.</li> <li>If the imputation set is a singleton (<code>|r| &lt;= tol</code>), returns <code>[l]</code>.</li> <li>Otherwise returns <code>n_samples</code> sampled imputations.</li> </ul> Notes <ul> <li>\"Uniform-ish\" means uniform with respect to the simplex volume in the   barycentric coordinates \\(b\\) (Dirichlet(1,...,1)). After the affine   map \\(x = \\ell + r b\\), this corresponds to the natural uniform measure   on the shifted simplex as well.</li> <li>This is meant for visualization / Monte Carlo intuition, not for any   sophisticated MCMC mixing guarantees.</li> </ul> <p>Examples:</p> <p>Minimal 3-player example where the imputation set is non-empty:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.sampling import sample_imputation_set\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0, 1: 0, 2: 0, 4: 0,\n...     3: 0, 5: 0, 6: 0,\n...     7: 1,\n... })\n&gt;&gt;&gt; pts = sample_imputation_set(g, n_samples=3, seed=0)\n&gt;&gt;&gt; len(pts)\n3\n&gt;&gt;&gt; all(abs(sum(x) - 1.0) &lt; 1e-9 for x in pts)\nTrue\n</code></pre> <p>Degenerate case: singleton imputation set (r = 0):</p> <pre><code>&gt;&gt;&gt; g2 = Game.from_coalitions(n_players=2, values={0:0, 1:1, 2:2, 3:3})\n&gt;&gt;&gt; sample_imputation_set(g2, n_samples=10)\n[[1.0, 2.0]]\n</code></pre>"},{"location":"reference/geometry/weber_set/","title":"<code>tucoopy.geometry.weber_set</code>","text":""},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set--weber-set-convex-hull-of-marginal-vectors","title":"Weber set (convex hull of marginal vectors).","text":"<p>The Weber set of a TU game is defined as the convex hull of all marginal payoff vectors induced by permutations of players.</p> <p>This module provides:</p> <ul> <li>functions to compute marginal vectors (exact/enumerative, and sampling-based),</li> <li>:class:<code>WeberSet</code>, a set-valued object exposing a polyhedral representation for   small <code>n</code> via :class:<code>tucoopy.geometry.PolyhedralSet</code>.</li> </ul> Notes <p>The number of permutations is <code>n!</code> and grows quickly. Exact construction is intended for small <code>n</code> only; for larger games, use sampling helpers.</p> <p>Examples:</p> <p>Compute marginal vectors and build a Weber set for a small game:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry.weber_set import marginal_vector, WeberSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0, 2: 0, 3: 1})\n&gt;&gt;&gt; marginal_vector(g, [0, 1])\n[0.0, 1.0]\n&gt;&gt;&gt; ws = WeberSet(g)\n&gt;&gt;&gt; len(ws.points())\n2\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet","title":"WeberSet  <code>dataclass</code>","text":"<p>Weber set helper (V-representation generator).</p> Definition <p>The Weber set is the convex hull of all marginal contribution vectors:</p> \\[ W(v) = \\mathrm{conv}\\{ m_\\pi : \\pi \\in \\Pi(N) \\}. \\] Representation in this library <p>This object provides access to the generating point set \\(\\{m_\\pi\\}\\) (V-representation) via :meth:<code>points</code> and :meth:<code>sample_points</code>.</p> <p>For <code>n_players</code> in <code>{2, 3}</code>, this class also provides a lightweight H-representation via :attr:<code>poly</code>, which is useful for plotting and for reusing :class:<code>~tucoopy.geometry.polyhedron.PolyhedralSet</code> helpers.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>max_permutations</code> <code>int</code> <p>Safety cap for full enumeration via :meth:<code>points</code>.</p> <code>720</code> <p>Examples:</p> <p>For n=3, the exact generator set contains at most <code>3! = 6</code> points:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; ws = WeberSet(g)\n&gt;&gt;&gt; len(ws.points()) &lt;= 6\nTrue\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.poly","title":"poly  <code>property</code>","text":"<pre><code>poly\n</code></pre> <p>Return an H-representation polyhedron for the Weber set (n=2 or n=3).</p> <p>For n=2, the Weber set is a line segment on the efficiency line. For n=3, the Weber set is a polygon on the efficiency plane and we return a halfspace representation (inequalities + the efficiency equality).</p> Notes <ul> <li>Implemented only for n=2 and n=3.</li> <li>Requires enumerating all marginal vectors via :meth:<code>points</code>, so it is limited   by <code>max_permutations</code>.</li> </ul>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.mean_marginal","title":"mean_marginal","text":"<pre><code>mean_marginal()\n</code></pre> <p>Return the mean marginal vector under full enumeration (if feasible).</p> Notes <p>When all permutations are enumerated, this equals the Shapley value.</p>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.mean_marginal_sample","title":"mean_marginal_sample","text":"<pre><code>mean_marginal_sample(*, n_samples, seed=None)\n</code></pre> <p>Approximate the mean marginal vector by sampling random permutations.</p>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.points","title":"points","text":"<pre><code>points()\n</code></pre> <pre><code>Return all marginal vectors if the permutation count is small enough.\n</code></pre> <pre><code>Returns\n</code></pre> <pre><code>list[list[float]]\n    All marginal vectors (one per permutation).\n</code></pre> <pre><code>Raises\n</code></pre> <p>NotSupportedError     If <code>n! &gt; max_permutations</code>.</p> <pre><code>Examples\n</code></pre> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import WeberSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; WeberSet(g).points()\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.project","title":"project","text":"<pre><code>project(dims, *, tol=DEFAULT_GEOMETRY_TOL, max_dim=3)\n</code></pre> <p>Project the Weber set polytope onto selected coordinates (n=2 or n=3).</p> <p>Parameters:</p> Name Type Description Default <code>dims</code> <code>tuple[int, ...] | list[int]</code> <p>Coordinate indices to keep.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance passed to the underlying polyhedron.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_dim</code> <code>int</code> <p>Safety limit used by the underlying enumeration routine.</p> <code>3</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Projected points derived from the vertex set.</p>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.sample_points","title":"sample_points","text":"<pre><code>sample_points(*, n_samples, seed=None)\n</code></pre> <p>Sample marginal vectors uniformly by sampling random permutations.</p> <p>Parameters:</p> Name Type Description Default <code>n_samples</code> <code>int</code> <p>Number of sampled permutations.</p> required <code>seed</code> <code>int | None</code> <p>Optional RNG seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Sampled marginal vectors.</p>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.WeberSet.vertices","title":"vertices","text":"<pre><code>vertices(\n    *,\n    tol=DEFAULT_GEOMETRY_TOL,\n    max_players=DEFAULT_GEOMETRY_MAX_PLAYERS,\n    max_dim=3,\n)\n</code></pre> <p>Enumerate vertices of the Weber set polytope (small n).</p> <p>This is available only when :attr:<code>poly</code> is available (currently <code>n=2</code> or <code>n=3</code>).</p> <p>Parameters:</p> Name Type Description Default <code>tol</code> <code>float</code> <p>Numerical tolerance passed to the underlying polyhedron.</p> <code>DEFAULT_GEOMETRY_TOL</code> <code>max_players</code> <code>int</code> <p>Safety cap (API consistency). This helper is intended for small n.</p> <code>DEFAULT_GEOMETRY_MAX_PLAYERS</code> <code>max_dim</code> <code>int</code> <p>Safety limit for vertex enumeration.</p> <code>3</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>Vertex list (possibly empty if the construction fails).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import WeberSet\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; WeberSet(g).vertices(max_dim=2)\n[[0.0, 1.0], [1.0, 0.0]]\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.marginal_vector","title":"marginal_vector","text":"<pre><code>marginal_vector(game, order)\n</code></pre> <p>Marginal contribution vector for a permutation of players.</p> <p>Given a permutation (order) \\(\\pi\\) of \\(N = \\{0,\\dots,n-1\\}\\), define the growing chain of coalitions</p> \\[ S_k = \\{\\pi_1, \\dots, \\pi_k\\}, \\qquad k=0,1,\\dots,n, \\] <p>with \\(S_0 = \\varnothing\\). The marginal contribution vector \\(m_\\pi \\in \\mathbb{R}^n\\) is defined by</p> \\[ m_\\pi[\\pi_k] = v(S_k) - v(S_{k-1}), \\qquad k=1,\\dots,n. \\] Intuition <p>Walk through the players in the given order. When player i enters, they \"add\" \\(v(S \\cup \\{i\\}) - v(S)\\) to the coalition. Collect these increments into a vector.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>order</code> <code>Sequence[int]</code> <p>A permutation of players <code>0..n-1</code>.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Marginal vector (length <code>n_players</code>).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>order</code> is not a valid permutation of length <code>n_players</code>.</p> <p>Examples:</p> <p>Minimal 2-player example:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import marginal_vector\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; marginal_vector(g, [0, 1])\n[0.0, 1.0]\n&gt;&gt;&gt; marginal_vector(g, [1, 0])\n[1.0, 0.0]\n</code></pre> <p>Minimal 3-player \"unanimity\" game (only grand coalition has value 1):</p> <pre><code>&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0:0, 1:0, 2:0, 4:0,\n...     3:0, 5:0, 6:0,\n...     7:1,\n... })\n&gt;&gt;&gt; marginal_vector(g, [0, 1, 2])\n[0.0, 0.0, 1.0]\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.mean_marginal_sample","title":"mean_marginal_sample","text":"<pre><code>mean_marginal_sample(game, *, n_samples, seed=None)\n</code></pre> <p>Approximate the mean marginal contribution vector by sampling permutations.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>n_samples</code> <code>int</code> <p>Number of random permutations to sample.</p> required <code>seed</code> <code>int | None</code> <p>Optional RNG seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Approximate mean marginal vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0: 0.0,\n...     1: 1.0, 2: 1.0, 4: 1.0,\n...     3: 2.0, 5: 2.0, 6: 2.0,\n...     7: 4.0,\n... })\n&gt;&gt;&gt; m = mean_marginal_sample(g, n_samples=20, seed=0)\n&gt;&gt;&gt; len(m)\n3\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.mean_marginal_vector","title":"mean_marginal_vector","text":"<pre><code>mean_marginal_vector(game, *, max_permutations=720)\n</code></pre> <p>Mean marginal contribution vector across all permutations.</p> <p>If all permutations are enumerated, this equals the Shapley value.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>max_permutations</code> <code>int</code> <p>Safety cap: allow enumeration only if <code>n! &lt;= max_permutations</code>.</p> <code>720</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Mean marginal vector (length <code>n_players</code>).</p> <p>Examples:</p> <p>For n=2, the mean marginal vector is easy to compute:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0: 0, 1: 0, 2: 0, 3: 1})\n&gt;&gt;&gt; mean_marginal_vector(g)\n[0.5, 0.5]\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.weber_marginal_vectors","title":"weber_marginal_vectors","text":"<pre><code>weber_marginal_vectors(\n    game: GameProtocol,\n    *,\n    max_permutations: int = 720,\n    return_witness: Literal[False] = False,\n) -&gt; list[list[float]]\n</code></pre><pre><code>weber_marginal_vectors(\n    game: GameProtocol,\n    *,\n    max_permutations: int = 720,\n    return_witness: Literal[True],\n) -&gt; tuple[list[list[float]], list[tuple[int, ...]]]\n</code></pre> <pre><code>weber_marginal_vectors(\n    game, *, max_permutations=720, return_witness=False\n)\n</code></pre> <p>Enumerate all marginal contribution vectors (all permutations), if feasible.</p> <p>The Weber set is the convex hull of marginal vectors, one per permutation. This helper returns the generating point set:</p> \\[ \\{ m_\\pi : \\pi \\in \\Pi(N) \\}. \\] <p>Since there are \\(n!\\) permutations, full enumeration is only practical for small n. This routine raises if \\(n!\\) exceeds <code>max_permutations</code>.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>max_permutations</code> <code>int</code> <p>Safety cap: allow enumeration only if <code>n! &lt;= max_permutations</code>. Default 720 corresponds to n&lt;=6.</p> <code>720</code> <code>return_witness</code> <code>bool</code> <p>If True, also return the permutation (\"witness\") that generated each marginal vector. This is useful for debugging and visualization.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>List of marginal vectors (each of length <code>n_players</code>).</p> <code>tuple[list[list[float]], list[tuple[int, ...]]]</code> <p>If <code>return_witness=True</code>: <code>(points, witnesses)</code>, where <code>witnesses[i]</code> is the permutation that generated <code>points[i]</code>.</p> <p>Raises:</p> Type Description <code>NotSupportedError</code> <p>If <code>n! &gt; max_permutations</code>.</p> Notes <p>For visualization you often only need the point cloud (V-rep). Converting the convex hull to an H-representation can be significantly heavier and may require additional dependencies.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import weber_marginal_vectors\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={0:0, 1:0, 2:0, 3:1})\n&gt;&gt;&gt; weber_marginal_vectors(g)\n[[0.0, 1.0], [1.0, 0.0]]\n&gt;&gt;&gt; pts, perms = weber_marginal_vectors(g, return_witness=True)\n&gt;&gt;&gt; perms\n[(0, 1), (1, 0)]\n</code></pre>"},{"location":"reference/geometry/weber_set/#tucoopy.geometry.weber_set.weber_sample","title":"weber_sample","text":"<pre><code>weber_sample(game, *, n_samples, seed=None)\n</code></pre> <p>Sample marginal vectors by sampling random permutations.</p> <p>This is a Monte Carlo approximation to the generating set of the Weber set. It returns a list of marginal vectors \\(m_\\pi\\), where each permutation \\(\\pi\\) is sampled (approximately) uniformly at random.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>n_samples</code> <code>int</code> <p>Number of random permutations / marginal vectors to generate.</p> required <code>seed</code> <code>int | None</code> <p>Optional RNG seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[list[float]]</code> <p>A list of sampled marginal vectors (each length <code>n_players</code>).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>n_samples &lt; 1</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.geometry import weber_sample\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=3, values={\n...     0:0, 1:0, 2:0, 4:0,\n...     3:0, 5:0, 6:0,\n...     7:1,\n... })\n&gt;&gt;&gt; pts = weber_sample(g, n_samples=5, seed=0)\n&gt;&gt;&gt; len(pts)\n5\n</code></pre>"},{"location":"reference/io/analysis/","title":"<code>tucoopy.io.analysis</code>","text":""},{"location":"reference/io/analysis/#tucoopy.io.analysis--high-level-analysis-builder-for-cooperative-game-artifacts","title":"High-level analysis builder for cooperative game artifacts.","text":"<p>This module builds the <code>analysis</code> section used by the JSON/animation contracts:</p> <ul> <li>computes selected point solutions (e.g. Shapley, Banzhaf),</li> <li>computes selected set-valued objects (e.g. imputation set, core),</li> <li>attaches diagnostics summaries (e.g. core membership of solutions),</li> <li>and applies limits (max players, max points, truncation) to keep outputs stable.</li> </ul> <p>The resulting object is intended to be JSON-serializable and suitable for renderers (e.g. the JS demo) and static reports.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.io.analysis import build_analysis\n&gt;&gt;&gt; g = Game.from_coalitions(\n...     n_players=2,\n...     values={(): 0.0, (0,): 0.0, (1,): 0.0, (0, 1): 1.0},\n... )\n&gt;&gt;&gt; report = build_analysis(g, include_blocking_regions=False, include_bundle=False)\n&gt;&gt;&gt; \"solutions\" in report and \"sets\" in report\nTrue\n</code></pre>"},{"location":"reference/io/animation_spec/","title":"<code>tucoopy.io.animation_spec</code>","text":""},{"location":"reference/io/animation_spec/#tucoopy.io.animation_spec--json-ready-animation-spec-dataclasses","title":"JSON-ready animation spec dataclasses.","text":"<p>This module defines a small set of dataclasses that match the animation/spec contract used by the JS demo renderer, plus helpers to build specs from:</p> <ul> <li>a <code>tucoopy.base.game.Game</code> object, and</li> <li>a sequence of allocations (frames).</li> </ul> Notes <p><code>AnimationSpec.to_json</code> uses <code>ensure_ascii=True</code> to produce a strictly ASCII JSON string (any non-ASCII content is escaped). This keeps the output portable across environments while still being valid UTF-8 when written to disk.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy import Game\n&gt;&gt;&gt; from tucoopy.io.animation_spec import build_animation_spec\n&gt;&gt;&gt; g = Game.from_coalitions(\n...     n_players=2,\n...     values={(): 0.0, (0,): 0.0, (1,): 0.0, (0, 1): 1.0},\n... )\n&gt;&gt;&gt; spec = build_animation_spec(game=g, series_id=\"demo\", allocations=[[0.0, 1.0]], dt=1/60)\n&gt;&gt;&gt; spec.schema_version\n'0.1.0'\n</code></pre>"},{"location":"reference/io/game_spec/","title":"<code>tucoopy.io.game_spec</code>","text":""},{"location":"reference/io/game_spec/#tucoopy.io.game_spec--parsing-and-conversion-helpers-for-spec-like-json-objects","title":"Parsing and conversion helpers for spec-like JSON objects.","text":"<p>This module provides:</p> <ul> <li>tolerant \"field access\" helpers for dict-like / attribute-like objects,</li> <li>JSON loading helpers for specs (string/bytes/path),</li> <li>converters between <code>tucoopy.base.game.Game</code> and a stable wire dict, and</li> <li>helpers to extract relevant pieces from an animation spec (game, sets, frames).</li> </ul> <p>The wire formats are designed to remain simple, JSON-friendly, and compatible with the schema files shipped in <code>tucoopy.io.schemas</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.io.game_spec import spec_from_json\n&gt;&gt;&gt; spec = spec_from_json(\n...     '{\"n_players\": 2, \"characteristic_function\": [{\"coalition_mask\": 0, \"value\": 0.0}] }'\n... )\n&gt;&gt;&gt; isinstance(spec, dict)\nTrue\n</code></pre>"},{"location":"reference/io/game_spec/#tucoopy.io.game_spec.game_from_animation_spec","title":"game_from_animation_spec","text":"<pre><code>game_from_animation_spec(spec)\n</code></pre> <p>STRICT builder: construct a Game from an AnimationSpec-like object that uses the canonical CF shape:</p> <p>spec.game = {     \"n_players\": int,     \"player_labels\": [... optional ...],     \"characteristic_function\": [{\"coalition_mask\": int, \"value\": number}, ...]   }</p> <p>Inputs accepted:   - dict-like spec   - dataclass/attr-like spec   - JSON string/bytes/Path that parses to a dict</p>"},{"location":"reference/io/game_spec/#tucoopy.io.game_spec.game_from_wire_dict","title":"game_from_wire_dict","text":"<pre><code>game_from_wire_dict(data)\n</code></pre> <p>Deserialize a <code>Game</code> from wire format produced by <code>game_to_wire_dict</code>.</p>"},{"location":"reference/io/game_spec/#tucoopy.io.game_spec.game_to_wire_dict","title":"game_to_wire_dict","text":"<pre><code>game_to_wire_dict(game)\n</code></pre> <p>Serialize a <code>Game</code> into a JSONable dict (wire format).</p> <p>Stable format:   {     \"n_players\": int,     \"player_labels\": [str] | null,     \"values\": { \"\": float, ... }   }"},{"location":"reference/io/game_spec/#tucoopy.io.game_spec.get_field","title":"get_field","text":"<pre><code>get_field(obj, key, default=None)\n</code></pre> <p>Get key from mapping-like or attribute-like objects.</p>"},{"location":"reference/io/game_spec/#tucoopy.io.game_spec.spec_from_json","title":"spec_from_json","text":"<pre><code>spec_from_json(data)\n</code></pre> <p>Load a spec-like dict from JSON content.</p> <p>Accepts:   - JSON string   - JSON bytes   - Path to a JSON file   - str path to a .json file (if exists)</p>"},{"location":"reference/io/schema/","title":"<code>tucoopy.io.schema</code>","text":""},{"location":"reference/io/schema/#tucoopy.io.schema--bundled-json-schema-helpers","title":"Bundled JSON Schema helpers.","text":"<p>This module loads JSON Schemas bundled with the package under <code>tucoopy.io.schemas</code> and exposes small helpers to:</p> <ul> <li>return schema dicts (for validation tooling), and</li> <li>write schema files to disk (for editors/CI).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.io.schema import animation_spec_schema\n&gt;&gt;&gt; schema = animation_spec_schema()\n&gt;&gt;&gt; isinstance(schema, dict)\nTrue\n</code></pre>"},{"location":"reference/io/schema/#tucoopy.io.schema.animation_spec_schema","title":"animation_spec_schema","text":"<pre><code>animation_spec_schema()\n</code></pre> <p>Return the JSON Schema for the tucoopy animation spec.</p>"},{"location":"reference/io/schema/#tucoopy.io.schema.game_schema","title":"game_schema","text":"<pre><code>game_schema()\n</code></pre> <p>Return the JSON Schema for <code>tucoop.io.json.game_to_dict</code> output.</p>"},{"location":"reference/io/schema/#tucoopy.io.schema.write_schema","title":"write_schema","text":"<pre><code>write_schema(path, *, which='animation_spec', indent=2)\n</code></pre> <p>Write a bundled schema JSON file to disk.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>Output path for the schema JSON.</p> required <code>which</code> <code>str</code> <p>\"animation_spec\" or \"game\".</p> <code>'animation_spec'</code>"},{"location":"reference/power/banzhaf/","title":"<code>tucoopy.power.banzhaf</code>","text":""},{"location":"reference/power/banzhaf/#tucoopy.power.banzhaf--banzhaf-power-index","title":"Banzhaf power index.","text":"<p>This module provides the Banzhaf index for simple (0\u20131) games, as well as an efficient dynamic-programming variant for integer weighted voting games.</p>"},{"location":"reference/power/banzhaf/#tucoopy.power.banzhaf.banzhaf_index","title":"banzhaf_index","text":"<pre><code>banzhaf_index(game, *, normalized=True)\n</code></pre> <p>Compute the Banzhaf power index for a simple game.</p> <p>In a simple game (\\(v(S) \\in \\{0,1\\}\\)), a player \\(i\\) is critical (or a swing player) in a coalition \\(S\\) if:</p> \\[ v(S) = 1 \\quad \\text{and} \\quad v(S \\setminus \\{i\\}) = 0. \\] <p>The (raw) Banzhaf value of player \\(i\\) is the number of coalitions in which \\(i\\) is critical. The normalized Banzhaf index divides these counts by the total across all players so that the index sums to 1.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>A simple game.</p> required <code>normalized</code> <code>bool</code> <p>If True, return the normalized Banzhaf index. If False, return the raw Banzhaf value (number of swings scaled by \\(2^{-(n-1)}\\)).</p> <code>True</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Banzhaf index for each player.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the game is not a valid simple game.</p> Notes <ul> <li>The Banzhaf index measures criticality across all coalitions,   without weighting by coalition size or permutations.</li> <li>It differs from the Shapley\u2013Shubik index, which is based on pivotality   in permutations.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bi = banzhaf_index(g)\n&gt;&gt;&gt; len(bi) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/power/banzhaf/#tucoopy.power.banzhaf.banzhaf_index_weighted_voting","title":"banzhaf_index_weighted_voting","text":"<pre><code>banzhaf_index_weighted_voting(\n    weights, quota, *, normalized=True\n)\n</code></pre> <p>Compute the Banzhaf index for an integer weighted voting game using dynamic programming (without enumerating all \\(2^n\\) coalitions).</p> <p>A weighted voting game is defined by weights \\(w_1,\\ldots,w_n\\) and a quota \\(q\\). A coalition \\(S\\) is winning if:</p> \\[ \\sum_{i \\in S} w_i \\ge q. \\] <p>A player \\(i\\) is critical in a coalition if removing \\(i\\) changes the coalition from winning to losing. This implementation counts how many subsets of the other players have total weight in the pivotal interval \\([q-w_i,\\, q-1]\\).</p> <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>Sequence[int]</code> <p>Integer player weights.</p> required <code>quota</code> <code>int</code> <p>Decision quota.</p> required <code>normalized</code> <code>bool</code> <p>If True, normalize the index to sum to 1.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Banzhaf index for each player.</p> Notes <ul> <li>Complexity is pseudo-polynomial in the quota/weight scale.</li> <li>Much faster than full coalition enumeration for moderate weights.</li> <li>If \\(q = 0\\) or \\(q &gt; \\sum_{i=1}^n w_i\\), no player is critical   and all indices are zero.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; banzhaf_index_weighted_voting([2, 1, 1], quota=3)\n[0.5, 0.25, 0.25]\n</code></pre>"},{"location":"reference/power/coleman/","title":"<code>tucoopy.power.coleman</code>","text":""},{"location":"reference/power/coleman/#tucoopy.power.coleman--coleman-indices-for-complete-simple-games","title":"Coleman indices for complete simple games.","text":"<p>This module implements Coleman's system-level and player-level measures:</p> <ul> <li>collectivity power to act (fraction of winning coalitions),</li> <li>power to prevent action (criticality among winning coalitions),</li> <li>power to initiate action (pivotality among losing coalitions).</li> </ul>"},{"location":"reference/power/coleman/#tucoopy.power.coleman.coleman_collectivity_power_to_act","title":"coleman_collectivity_power_to_act","text":"<pre><code>coleman_collectivity_power_to_act(game)\n</code></pre> <p>Compute Coleman's collectivity power to act for a complete simple game.</p> <p>This quantity measures how often the group, as a whole, is able to take collective action. It is defined as the fraction of coalitions that are winning:</p> \\[ C = \\frac{\\#\\{ S \\subseteq N \\mid v(S) = 1 \\}}{2^n}. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A complete simple game.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The collectivity power to act.</p> Notes <ul> <li>This is not a player-level index, but a system-level measure of how   permissive the decision rule is.</li> <li>A high value means many coalitions can produce action; a low value means   the decision rule is restrictive.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coleman_collectivity_power_to_act(g)\n0.5\n</code></pre>"},{"location":"reference/power/coleman/#tucoopy.power.coleman.coleman_initiate_index","title":"coleman_initiate_index","text":"<pre><code>coleman_initiate_index(game)\n</code></pre> <p>Compute Coleman's power to initiate action for each player.</p> <p>For a losing coalition \\(S\\), a player \\(i \\notin S\\) is said to have initiating power if adding \\(i\\) makes the coalition winning:</p> \\[ v(S) = 0 \\quad \\text{and} \\quad v(S \\cup \\{i\\}) = 1. \\] <p>The index of player \\(i\\) is the fraction of losing coalitions in which \\(i\\) can turn the outcome into a winning one:</p> \\[ C_i^{\\text{initiate}} = \\frac{\\#\\{ S \\mid v(S)=0,\\ i \\text{ pivotal for } S \\}}      {\\#\\{ S \\mid v(S)=0 \\}}. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A complete simple game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Coleman initiating index for each player.</p> Notes <ul> <li>This measures how often a player can create collective action.</li> <li>Dual to the preventive index: one measures blocking power, the other   initiating power.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coleman_initiate_index(g)\n[0.6, 0.2, 0.2]\n</code></pre>"},{"location":"reference/power/coleman/#tucoopy.power.coleman.coleman_prevent_index","title":"coleman_prevent_index","text":"<pre><code>coleman_prevent_index(game)\n</code></pre> <p>Compute Coleman's power to prevent action for each player.</p> <p>For a winning coalition \\(S\\), a player \\(i \\in S\\) is said to have preventive power if removing \\(i\\) makes the coalition losing:</p> \\[ v(S) = 1 \\quad \\text{and} \\quad v(S \\setminus \\{i\\}) = 0. \\] <p>The index of player \\(i\\) is the fraction of winning coalitions in which \\(i\\) is critical:</p> \\[ C_i^{\\text{prevent}} = \\frac{\\#\\{ S \\mid v(S)=1,\\ i \\text{ critical in } S \\}}      {\\#\\{ S \\mid v(S)=1 \\}}. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A complete simple game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Coleman preventive index for each player.</p> Notes <ul> <li>This measures how often a player can block collective action.</li> <li>Closely related to the Banzhaf index, but normalized by the number of   winning coalitions instead of the number of all coalitions.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; coleman_prevent_index(g)\n[0.4, 0.3, 0.3]\n</code></pre>"},{"location":"reference/power/deegan_packel/","title":"<code>tucoopy.power.deegan_packel</code>","text":""},{"location":"reference/power/deegan_packel/#tucoopy.power.deegan_packel--deeganpackel-power-index","title":"Deegan\u2013Packel power index.","text":"<p>The Deegan\u2013Packel index is based on minimal winning coalitions and distributes a unit contribution across members inversely proportional to coalition size.</p>"},{"location":"reference/power/deegan_packel/#tucoopy.power.deegan_packel.deegan_packel_index","title":"deegan_packel_index","text":"<pre><code>deegan_packel_index(game)\n</code></pre> <p>Compute the Deegan\u2013Packel power index for a complete simple game.</p> <p>This index is based on the minimal winning coalitions of the game. A coalition \\(S\\) is minimal winning if:</p> <ul> <li>\\(v(S) = 1\\), and</li> <li>for every \\(i \\in S\\), \\(v(S \\setminus \\{i\\}) = 0\\).</li> </ul> <p>Each minimal winning coalition distributes one unit of power equally among its members. That is, for each minimal winning coalition \\(S\\), every player \\(i \\in S\\) receives:</p> \\[ \\frac{1}{|S|}. \\] <p>The resulting vector is then normalized to sum to \\(1\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A complete simple game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Deegan\u2013Packel index for each player (length <code>n_players</code>), normalized to sum to 1.</p> Notes <ul> <li>Like the Holler (Public Good) index, this index considers only minimal   winning coalitions.</li> <li>The key difference is that the Holler index counts how many minimal   winning coalitions contain a player, while the Deegan\u2013Packel index   weights each coalition by the inverse of its size.</li> <li>This reflects the idea that being essential in a small coalition   should count more than being essential in a large one.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; dpi = deegan_packel_index(g)\n&gt;&gt;&gt; sum(dpi)\n1.0\n</code></pre>"},{"location":"reference/power/egalitarian_shapley/","title":"<code>tucoopy.power.egalitarian_shapley</code>","text":""},{"location":"reference/power/egalitarian_shapley/#tucoopy.power.egalitarian_shapley--egalitarian-shapley-value","title":"Egalitarian Shapley value.","text":"<p>This value modifies the Shapley allocation by down-weighting each Harsanyi dividend by the square of the coalition size.</p>"},{"location":"reference/power/egalitarian_shapley/#tucoopy.power.egalitarian_shapley.egalitarian_shapley_value","title":"egalitarian_shapley_value","text":"<pre><code>egalitarian_shapley_value(game)\n</code></pre> <p>Egalitarian Shapley value.</p> <p>This value modifies the Shapley allocation by dividing each Harsanyi dividend by the square of the coalition size:</p> \\[\\phi_i = \\sum_{S \\ni i} \\frac{d(S)}{|S|^2}.\\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Egalitarian Shapley allocation.</p> Notes <ul> <li>Derived from the Shapley value but emphasizes equality inside coalitions.</li> <li>Implemented directly from Harsanyi dividends.</li> </ul>"},{"location":"reference/power/holler/","title":"<code>tucoopy.power.holler</code>","text":""},{"location":"reference/power/holler/#tucoopy.power.holler--holler-public-good-power-index","title":"Holler (Public Good) power index.","text":"<p>The Holler index counts how often a player appears in minimal winning coalitions, optionally normalized to sum to one.</p>"},{"location":"reference/power/holler/#tucoopy.power.holler.holler_index","title":"holler_index","text":"<pre><code>holler_index(game, *, normalized=True)\n</code></pre> <p>Compute the Holler index (also known as the Public Good index) for a simple game.</p> <p>The Holler index is based exclusively on the minimal winning coalitions of the game. A coalition \\(S\\) is minimal winning if:</p> <ul> <li>\\(v(S) = 1\\), and</li> <li>for every \\(i \\in S\\), \\(v(S \\setminus \\{i\\}) = 0\\).</li> </ul> <p>The Holler index of a player \\(i\\) is the number of minimal winning coalitions that contain \\(i\\):</p> \\[ H_i = \\#\\{ S \\text{ minimal winning} \\mid i \\in S \\}. \\] <p>Optionally, this vector can be normalized to sum to 1.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A simple game.</p> required <code>normalized</code> <code>bool</code> <p>If True, normalize the index to sum to 1.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Holler index for each player (length <code>n_players</code>).</p> Notes <ul> <li>This index focuses only on the essential winning structures of the game,   ignoring larger winning coalitions that contain redundant players.</li> <li>It is also called the Public Good index because it measures how often   a player is indispensable in producing the public good (a winning outcome).</li> <li>Unlike Shapley or Banzhaf, this index does not consider coalition sizes   or permutations\u2014only the structure of minimal winning coalitions.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hi = holler_index(g)\n&gt;&gt;&gt; len(hi) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/power/johnston/","title":"<code>tucoopy.power.johnston</code>","text":""},{"location":"reference/power/johnston/#tucoopy.power.johnston--johnston-power-index","title":"Johnston power index.","text":"<p>The Johnston index refines Banzhaf criticality by splitting each winning coalition's contribution equally among its critical players.</p>"},{"location":"reference/power/johnston/#tucoopy.power.johnston.johnston_index","title":"johnston_index","text":"<pre><code>johnston_index(game)\n</code></pre> <p>Compute the Johnston power index for a complete simple game.</p> <p>In a simple game (\\(v(S) \\in \\{0,1\\}\\)), a player \\(i\\) is critical in a winning coalition \\(S\\) if removing \\(i\\) makes the coalition losing:</p> \\[ C(S) = \\{ i \\in S \\mid v(S) = 1 \\text{ and } v(S \\setminus \\{i\\}) = 0 \\}. \\] <p>The Johnston index assigns to each critical player an equal share of the coalition's criticality. That is, each winning coalition \\(S\\) contributes:</p> \\[ \\frac{1}{|C(S)|} \\] <p>to each \\(i \\in C(S)\\).</p> <p>The resulting vector is then normalized to sum to 1.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A complete simple game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Johnston index for each player (length <code>n_players</code>), normalized to sum to 1.</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the game is not a complete simple game (checked by :func:<code>require_complete_simple_game</code>).</p> <code>NotSupportedError</code> <p>If <code>n_players</code> exceeds the supported limit for completeness checks.</p> Notes <ul> <li>The Johnston index refines the idea of criticality used in the   (unnormalized) Banzhaf index.</li> <li>In the Banzhaf index, each critical occurrence contributes equally (1).   In the Johnston index, the contribution of a coalition is divided equally   among its critical players.</li> <li>This index captures how often a player is decisive and how many other   players share that decisiveness.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ji = johnston_index(g)\n&gt;&gt;&gt; sum(ji)\n1.0\n</code></pre>"},{"location":"reference/power/koenig_brauninger/","title":"<code>tucoopy.power.koenig_brauninger</code>","text":""},{"location":"reference/power/koenig_brauninger/#tucoopy.power.koenig_brauninger--koenigbrauninger-power-index","title":"Koenig\u2013Br\u00e4uninger power index.","text":"<p>This index is based on minimal winning coalitions and assigns to each member of such a coalition a weight proportional to <code>1/(|S|-1)</code>.</p>"},{"location":"reference/power/koenig_brauninger/#tucoopy.power.koenig_brauninger.koenig_brauninger_index","title":"koenig_brauninger_index","text":"<pre><code>koenig_brauninger_index(game)\n</code></pre> <p>Koenig-Br\u00e4uninger power index for a simple game.</p> <p>For each minimal winning coalition S containing player \\(i\\):</p> \\[KB_i += \\frac{1}{|S| - 1}.\\] <p>The result is normalized to sum to \\(1\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Complete simple game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Koenig-Br\u00e4uninger index.</p> Notes <ul> <li>Based only on minimal winning coalitions.</li> <li>Gives more weight to players in smaller minimal winning coalitions.</li> <li>Implemented as in CoopGame.</li> </ul>"},{"location":"reference/power/rae/","title":"<code>tucoopy.power.rae</code>","text":""},{"location":"reference/power/rae/#tucoopy.power.rae--rae-satisfaction-index","title":"Rae satisfaction index.","text":"<p>The Rae index measures how often a player is \"satisfied\" by a coalition outcome: winning when included, or losing when excluded.</p>"},{"location":"reference/power/rae/#tucoopy.power.rae.rae_index","title":"rae_index","text":"<pre><code>rae_index(game)\n</code></pre> <p>Compute the Rae index (satisfaction index) for a complete simple game.</p> <p>In a simple game, coalitions are either winning or losing (\\(v(S) \\in \\{0,1\\}\\)). The Rae index measures how often a player is satisfied with the outcome of a coalition, assuming all coalitions are equally likely.</p> <p>A player \\(i\\) is considered satisfied with a coalition \\(S\\) if:</p> <ul> <li>\\(S\\) is winning and \\(i \\in S\\), or</li> <li>\\(S\\) is losing and \\(i \\notin S\\).</li> </ul> <p>The Rae index of player \\(i\\) is therefore:</p> \\[ R_i = \\frac{1}{2^n}       \\Big(         \\#\\{ S \\mid v(S)=1,\\ i \\in S \\}         +         \\#\\{ S \\mid v(S)=0,\\ i \\notin S \\}       \\Big). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>A complete simple game, i.e. a game where: - all \\(2^n\\) coalitions are explicitly defined, and - values are in {0,1}.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Rae index for each player (length <code>n_players</code>).</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the game is not a complete simple game (checked by :func:<code>require_complete_simple_game</code>).</p> <code>NotSupportedError</code> <p>If <code>n_players</code> exceeds the supported limit for completeness checks.</p> Notes <ul> <li>The Rae index can be interpreted as the probability that a randomly   selected coalition outcome agrees with player \\(i\\)'s participation   (winning with the coalition, or losing outside it).</li> <li>Unlike power indices such as Shapley\u2013Shubik or Banzhaf, the Rae index   measures satisfaction rather than pivotality.</li> <li>There is a known relationship between the Rae index and the Banzhaf index.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rae = rae_index(g)\n&gt;&gt;&gt; len(rae) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/power/shapley_shubik/","title":"<code>tucoopy.power.shapley_shubik</code>","text":""},{"location":"reference/power/shapley_shubik/#tucoopy.power.shapley_shubik--shapleyshubik-power-index","title":"Shapley\u2013Shubik power index.","text":"<p>For simple games, the Shapley\u2013Shubik index coincides with the Shapley value. This module exposes both a game-level wrapper and a dynamic-programming variant for integer weighted voting games.</p>"},{"location":"reference/power/shapley_shubik/#tucoopy.power.shapley_shubik.shapley_shubik_index","title":"shapley_shubik_index","text":"<pre><code>shapley_shubik_index(game)\n</code></pre> <p>Compute the Shapley\u2013Shubik power index for a simple (0\u20131) game.</p> <p>In a simple game, coalitions are either losing or winning: \\(v(S) \\in \\{0,1\\}\\). The Shapley\u2013Shubik index of a player is the probability (under a uniformly random permutation/order of players) that the player is pivotal, i.e. the player whose entry into the coalition turns it from losing to winning.</p> <p>Equivalently, for simple games the Shapley\u2013Shubik index coincides with the Shapley value of the game:</p> \\[ \\text{SSI}(v) = \\phi(v). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>TU game expected to be a simple game (0\u20131 valued).</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Shapley\u2013Shubik index for each player (length <code>n_players</code>).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>game</code> is not a valid simple game (checked by <code>tucoopy.properties.simple_games.validate_simple_game</code>).</p> Notes <p>This function is a thin wrapper around <code>tucoopy.solutions.shapley.shapley_value</code> after validating that the input is a simple game.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; validate_simple_game(g)\n&gt;&gt;&gt; ssi = shapley_shubik_index(g)\n&gt;&gt;&gt; len(ssi) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/power/shapley_shubik/#tucoopy.power.shapley_shubik.shapley_shubik_index_weighted_voting","title":"shapley_shubik_index_weighted_voting","text":"<pre><code>shapley_shubik_index_weighted_voting(weights, quota)\n</code></pre> <p>Compute the Shapley\u2013Shubik power index for an integer weighted voting game.</p> <p>A weighted voting game is defined by nonnegative integer weights \\(w_1,\\ldots,w_n\\) and a quota \\(q\\). A coalition \\(S\\) is winning if:</p> \\[ \\sum_{i \\in S} w_i \\ge q. \\] <p>The Shapley\u2013Shubik index of player \\(i\\) is the probability (under a uniformly random permutation of players) that player \\(i\\) is pivotal, meaning that the total weight of players before \\(i\\) in the permutation is strictly below the quota, but reaches/exceeds the quota when \\(i\\) is added.</p> <p>This implementation uses dynamic programming to count, for each player \\(i\\), how many coalitions of size \\(k\\) have total weight in the pivotal interval \\([q-w_i,\\, q-1]\\). Those counts are then weighted by the standard Shapley combinatorial coefficients:</p> \\[ \\frac{k!\\,(n-k-1)!}{n!}. \\] <p>Parameters:</p> Name Type Description Default <code>weights</code> <code>Sequence[int]</code> <p>Integer weights for the players.</p> required <code>quota</code> <code>int</code> <p>Decision quota (integer).</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Shapley\u2013Shubik indices for each player (length <code>len(weights)</code>).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If inputs are invalid (e.g., negative quota, invalid weights, etc.).</p> Notes <ul> <li>This routine is typically much faster than computing the Shapley value by   enumerating all \\(2^n\\) coalitions when the weights and quota are moderate.</li> <li>Complexity is pseudo-polynomial in the quota/weight scale: it depends on   the maximum tracked weight sum (effectively up to <code>quota-1</code> after validation).</li> <li>Corner cases:<ul> <li>If $ q = 0$, everyone is never pivotal (returns all zeros).</li> <li>If \\(quota &gt; \\sum_{i=1}^n w_i\\), no coalition can win (returns all zeros).</li> </ul> </li> </ul> <p>Examples:</p> <p>Majority game with weights [2,1,1] and quota 3:</p> <pre><code>&gt;&gt;&gt; shapley_shubik_index_weighted_voting([2, 1, 1], quota=3)\n[0.666..., 0.166..., 0.166...]\n</code></pre>"},{"location":"reference/power/solidarity/","title":"<code>tucoopy.power.solidarity</code>","text":""},{"location":"reference/power/solidarity/#tucoopy.power.solidarity--solidarity-value","title":"Solidarity value.","text":"<p>The solidarity value distributes each Harsanyi dividend equally among all members of the coalition.</p>"},{"location":"reference/power/solidarity/#tucoopy.power.solidarity.solidarity_value","title":"solidarity_value","text":"<pre><code>solidarity_value(game)\n</code></pre> <p>Solidarity value for a TU game.</p> <p>The solidarity value distributes each Harsanyi dividend equally among all members of the coalition:</p> \\[\\phi_i = \\sum_{S \\ni i} \\frac{d(S)}{|S|}.\\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Solidarity value allocation.</p> Notes <ul> <li>Uses Harsanyi dividends.</li> <li>Closely related to the Shapley value but conceptually emphasizes   coalition solidarity instead of marginal pivotality.</li> </ul>"},{"location":"reference/properties/balancedness/","title":"<code>tucoopy.properties.balancedness</code>","text":""},{"location":"reference/properties/balancedness/#tucoopy.properties.balancedness--balancedness-bondarevashapley-checks-via-linear-programming","title":"Balancedness (Bondareva\u2013Shapley) checks via linear programming.","text":"<p>This module implements an LP-based check of balancedness, which by the Bondareva\u2013Shapley theorem is equivalent to core non-emptiness for TU games.</p> Notes <p>The LP has one variable per non-empty, non-grand coalition, i.e. <code>2^n - 2</code>. This grows quickly with <code>n</code> and typically requires an LP backend (SciPy HiGHS).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.properties.balancedness import balancedness_check\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={(): 0.0, (0,): 0.0, (1,): 0.0, (0, 1): 1.0})\n&gt;&gt;&gt; result = balancedness_check(g)\n&gt;&gt;&gt; result.core_nonempty\nTrue\n</code></pre>"},{"location":"reference/properties/balancedness/#tucoopy.properties.balancedness.BalancednessResult","title":"BalancednessResult  <code>dataclass</code>","text":"<p>Result of a Bondareva\u2013Shapley balancedness check.</p>"},{"location":"reference/properties/balancedness/#tucoopy.properties.balancedness.balancedness_check","title":"balancedness_check","text":"<pre><code>balancedness_check(game, *, tol=DEFAULT_LP_TOL)\n</code></pre> <p>Bondareva\u2013Shapley theorem (LP check for core non-emptiness).</p> <p>Solve:    </p> \\[\\text{maximize } \\sum_{\\{S \\neq N, S \\neq \\varnothing\\}} \\lambda_S v(S)\\] <p>s.t.    </p> \\[ \\begin{cases} \\sum\\limits_{S \\ni i} \\lambda_S = 1 \\text{ for each player } i \\\\ \\lambda_S \\geq 0  \\end{cases} \\] <p>If \\(\\argmax &gt; v(N) + \\text{tol}\\), the core is empty and \\(\\lambda\\) is a certificate.</p> Warning <p>Requires: SciPy (<code>pip install \"tucoopy[lp]\"</code>)</p>"},{"location":"reference/properties/basic/","title":"<code>tucoopy.properties.basic</code>","text":""},{"location":"reference/properties/basic/#tucoopy.properties.basic--basic-property-checks-for-tu-cooperative-games","title":"Basic property checks for TU cooperative games.","text":"<p>This module provides quick recognizers for common properties of TU games:</p> <ul> <li>Normalized: \\(v(\\varnothing)=0\\),</li> <li>Monotone: if \\(S \\subseteq T\\) then \\(v(S) \\leq v(T)\\),</li> <li>Superadditive: if \\(S\\) and \\(T\\) are disjoint then \\(v(S)+v(T) \\leq v(S \\cup T)\\),</li> <li>Essential: $v(N) &gt; \\sum_{i=1}^{n} v({i})``.</li> </ul> Notes <p>Some checks are exponential in the number of players. Functions therefore accept <code>max_players</code> to fail fast for large games.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.properties.basic import is_normalized, is_monotone\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={(): 0.0, (0, 1): 1.0})\n&gt;&gt;&gt; is_normalized(g)\nTrue\n&gt;&gt;&gt; is_monotone(g)\nTrue\n</code></pre>"},{"location":"reference/properties/basic/#tucoopy.properties.basic.is_essential","title":"is_essential","text":"<pre><code>is_essential(game, *, eps=1e-12)\n</code></pre> <p>Check whether a TU game is essential.</p> <p>A game is essential if the grand coalition creates strictly more value than the sum of singleton coalitions:</p> \\[v(N) &gt; \\sum_i v(\\{i\\}).\\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>eps</code> <code>float</code> <p>Numerical tolerance.</p> <code>1e-12</code>"},{"location":"reference/properties/basic/#tucoopy.properties.basic.is_monotone","title":"is_monotone","text":"<pre><code>is_monotone(game, *, eps=1e-12, max_players=12)\n</code></pre> <p>Check whether a TU game is monotone.</p> <p>Monotonicity means that adding players to a coalition cannot decrease its worth:</p> \\[S \\subseteq T \\implies v(S) \\leq v(T).\\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>eps</code> <code>float</code> <p>Numerical tolerance.</p> <code>1e-12</code> <code>max_players</code> <code>int | None</code> <p>Fail fast if <code>game.n_players</code> exceeds this bound (check is exponential).</p> <code>12</code>"},{"location":"reference/properties/basic/#tucoopy.properties.basic.is_normalized","title":"is_normalized","text":"<pre><code>is_normalized(game, *, eps=0.0)\n</code></pre> <p>Normalized game: \\(v(\\varnothing) = 0\\).</p> Notes <p>:class:<code>~tucoopy.base.game.Game</code> enforces \\(v(\\varnothing)=0\\), so this is mostly provided for completeness and for defensive checks when ingesting external game specifications.</p>"},{"location":"reference/properties/basic/#tucoopy.properties.basic.is_superadditive","title":"is_superadditive","text":"<pre><code>is_superadditive(game, *, eps=1e-12, max_players=12)\n</code></pre> <p>Check whether a TU game is superadditive.</p> <p>Superadditivity requires that disjoint coalitions do not lose value by merging:</p> \\[S \\cap T = \\varnothing \\implies v(S) + v(T) \\leq v(S \\cup T).\\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>eps</code> <code>float</code> <p>Numerical tolerance.</p> <code>1e-12</code> <code>max_players</code> <code>int | None</code> <p>Fail fast if <code>game.n_players</code> exceeds this bound (check is exponential).</p> <code>12</code>"},{"location":"reference/properties/convexity/","title":"<code>tucoopy.properties.convexity</code>","text":""},{"location":"reference/properties/convexity/#tucoopy.properties.convexity--convexity-and-concavity-checks-for-tu-cooperative-games","title":"Convexity and concavity checks for TU cooperative games.","text":"<p>This module provides recognizers for:</p> <ul> <li>Convex (supermodular) games, and</li> <li>Concave (submodular) games.</li> </ul> Notes <p>Checking convexity/concavity is exponential, but can be done with a local condition on pairs of players, yielding an <code>O(n^2 2^n)</code> check.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.properties.convexity import is_convex, is_concave\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={(): 0.0, (0,): 1.0, (1,): 1.0, (0, 1): 3.0})\n&gt;&gt;&gt; is_convex(g)\nTrue\n&gt;&gt;&gt; is_concave(g)\nFalse\n</code></pre>"},{"location":"reference/properties/convexity/#tucoopy.properties.convexity.is_concave","title":"is_concave","text":"<pre><code>is_concave(game, *, eps=1e-12, max_players=12)\n</code></pre> <p>Concavity (submodularity): for all \\(S\\),\\(T\\),</p> \\[v(S) + v(T) \\geq v(S \\cup T) + v(S \\cap T)\\]"},{"location":"reference/properties/convexity/#tucoopy.properties.convexity.is_convex","title":"is_convex","text":"<pre><code>is_convex(game, *, eps=1e-12, max_players=12)\n</code></pre> <p>Convexity (supermodularity): for all \\(S\\),\\(T\\),</p> \\[v(S) + v(T) \\leq v(S \\cup T) + v(S \\cap T)\\]"},{"location":"reference/properties/cost_games/","title":"<code>tucoopy.properties.cost_games</code>","text":""},{"location":"reference/properties/cost_games/#tucoopy.properties.cost_games--cost-game-recognizers","title":"Cost game recognizers.","text":"<p>This module provides simple heuristics for recognizing and validating cost-style games, where costs are represented as negative worths (so \\(v(S) \\leq 0\\)).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.properties.cost_games import is_cost_game\n&gt;&gt;&gt; g = Game.from_coalitions(n_players=2, values={(): 0.0, (0,): -1.0, (1,): -2.0, (0, 1): -3.0})\n&gt;&gt;&gt; is_cost_game(g)\nTrue\n</code></pre>"},{"location":"reference/properties/cost_games/#tucoopy.properties.cost_games.is_cost_game","title":"is_cost_game","text":"<pre><code>is_cost_game(game, *, eps=1e-12, max_players=12)\n</code></pre> <p>Heuristic recognizer for \"cost games\" represented as negative values.</p> <p>Convention used in this library:</p> <ul> <li>TU games always have \\(v(\\varnothing)=0\\).</li> <li>Many cost-style models store costs as negative worths (\\(v(S) \\leq 0\\)).</li> </ul> <p>This recognizer checks:</p> <ul> <li>\\(v(S) \\leq \\epsilon\\) for all \\(S\\) (non-positive, up to tolerance)</li> <li>monotone non-increasing: if \\(S \\subseteq T\\) then \\(v(S) \\geq v(T) - \\epsilon\\)</li> </ul>"},{"location":"reference/properties/cost_games/#tucoopy.properties.cost_games.validate_cost_game","title":"validate_cost_game","text":"<pre><code>validate_cost_game(game, *, eps=1e-12, max_players=12)\n</code></pre> <p>Validate that a game matches the library's \"cost-game\" convention.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>eps</code> <code>float</code> <p>Numerical tolerance.</p> <code>1e-12</code> <code>max_players</code> <code>int | None</code> <p>Fail fast if <code>game.n_players</code> exceeds this bound (check is exponential).</p> <code>12</code> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the game fails :func:<code>is_cost_game</code>.</p>"},{"location":"reference/properties/simple_games/","title":"<code>tucoopy.properties.simple_games</code>","text":""},{"location":"reference/properties/simple_games/#tucoopy.properties.simple_games--recognizers-for-simple-games-and-weighted-voting-representations","title":"Recognizers for simple games and weighted voting representations.","text":"<p>A simple game is a TU game where every coalition is either losing or winning and the worth is binary:</p> <p>\\(v(S) \\in \\{0, 1\\}\\) for all coalitions \\(S\\).</p> <p>This module provides:</p> <ul> <li><code>is_simple_game</code> / <code>validate_simple_game</code> (binary-valued check),</li> <li><code>find_integer_weighted_voting_representation</code> (small-n brute force),</li> <li><code>is_weighted_voting_game</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.game import Game\n&gt;&gt;&gt; from tucoopy.properties.simple_games import is_simple_game\n&gt;&gt;&gt; # 3-player majority: any coalition of size &gt;= 2 is winning.\n&gt;&gt;&gt; values = {(): 0.0, (0, 1): 1.0, (0, 2): 1.0, (1, 2): 1.0, (0, 1, 2): 1.0}\n&gt;&gt;&gt; game = Game.from_coalitions(n_players=3, values=values)\n&gt;&gt;&gt; is_simple_game(game)\nTrue\n</code></pre>"},{"location":"reference/properties/simple_games/#tucoopy.properties.simple_games.find_integer_weighted_voting_representation","title":"find_integer_weighted_voting_representation","text":"<pre><code>find_integer_weighted_voting_representation(\n    game, *, max_weight=10, max_players=10\n)\n</code></pre> <p>Try to find an integer weighted voting representation \\((w, q)\\). This is an exact brute-force search intended for small \\(n\\). Returns (<code>weights</code>, <code>quota</code>) if successful, else <code>None</code>.</p>"},{"location":"reference/properties/simple_games/#tucoopy.properties.simple_games.is_simple_game","title":"is_simple_game","text":"<pre><code>is_simple_game(game, *, tol=0.0, max_players=20)\n</code></pre> <p>Return <code>True</code> iff \\(v(S)\\) is (approximately) in \\(\\{0, 1\\}\\) for all coalitions \\(S\\).</p>"},{"location":"reference/properties/simple_games/#tucoopy.properties.simple_games.is_weighted_voting_game","title":"is_weighted_voting_game","text":"<pre><code>is_weighted_voting_game(\n    game, *, max_weight=10, max_players=10\n)\n</code></pre> <p>Recognize whether a complete simple game can be represented as a weighted voting game. For now this is an exact brute-force test for small \\(n\\) only.</p>"},{"location":"reference/properties/simple_games/#tucoopy.properties.simple_games.validate_simple_game","title":"validate_simple_game","text":"<pre><code>validate_simple_game(game, *, tol=0.0, max_players=20)\n</code></pre> <p>Validate that game is a (TU) simple game: \\(v(S) \\in \\{0,1\\}\\) for all \\(S\\).</p>"},{"location":"reference/solutions/banzhaf/","title":"<code>tucoopy.solutions.banzhaf</code>","text":""},{"location":"reference/solutions/banzhaf/#tucoopy.solutions.banzhaf--banzhaf-values-for-tu-games","title":"Banzhaf values for TU games.","text":"<p>This module provides the (raw) Banzhaf value and common variants as semivalues.</p>"},{"location":"reference/solutions/banzhaf/#tucoopy.solutions.banzhaf.banzhaf_value","title":"banzhaf_value","text":"<pre><code>banzhaf_value(game)\n</code></pre> <p>Compute the (raw) Banzhaf value for a TU game.</p> <p>The Banzhaf value measures how often a player is critical across all coalitions, treating all coalitions of the other players as equally likely.</p> <p>For player \\(i\\):</p> \\[ \\beta_i = \\frac{1}{2^{n-1}} \\sum_{S \\subseteq N \\setminus \\{i\\}} \\big( v(S \\cup \\{i\\}) - v(S) \\big). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Banzhaf value vector of length <code>n_players</code>.</p> Notes <ul> <li>This is the raw Banzhaf value (not normalized across players).</li> <li>It is a semivalue corresponding to uniform weights over coalition sizes.</li> <li>Often used in voting power analysis and simple games.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; beta = banzhaf_value(g)\n&gt;&gt;&gt; len(beta) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/banzhaf/#tucoopy.solutions.banzhaf.normalized_banzhaf_value","title":"normalized_banzhaf_value","text":"<pre><code>normalized_banzhaf_value(game)\n</code></pre> <p>Compute the normalized Banzhaf value for a TU game.</p> <p>The raw Banzhaf values are rescaled so that the resulting allocation sums to the value of the grand coalition:</p> \\[ \\hat{\\beta}_i = \\frac{\\beta_i}{\\sum_j \\beta_j} \\, v(N). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Normalized Banzhaf allocation.</p> Notes <ul> <li>If all raw Banzhaf values are zero, the function returns a zero vector.</li> <li>This normalization makes the Banzhaf value comparable to other   allocation rules such as the Shapley value.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nb = normalized_banzhaf_value(g)\n&gt;&gt;&gt; sum(nb) == g.value(g.grand_coalition)\nTrue\n</code></pre>"},{"location":"reference/solutions/banzhaf/#tucoopy.solutions.banzhaf.weighted_banzhaf_value","title":"weighted_banzhaf_value","text":"<pre><code>weighted_banzhaf_value(game, *, p=0.5)\n</code></pre> <p>Weighted Banzhaf value (p-binomial semivalue).</p> <p>Interprets the marginal contribution as an expectation where each other player joins independently with probability p.</p> <p>For p=0.5 this equals the (raw) Banzhaf value.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>p</code> <code>float</code> <p>Inclusion probability in [0, 1].</p> <code>0.5</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Allocation vector of length n_players.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If p is outside [0, 1].</p>"},{"location":"reference/solutions/gately/","title":"<code>tucoopy.solutions.gately</code>","text":""},{"location":"reference/solutions/gately/#tucoopy.solutions.gately--gately-point","title":"Gately point.","text":"<p>The Gately point is an imputation based on a proportionality condition involving individual rationality and utopia payoffs.</p>"},{"location":"reference/solutions/gately/#tucoopy.solutions.gately.GatelyResult","title":"GatelyResult  <code>dataclass</code>","text":"<p>Result of the Gately point computation.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> <code>d</code> <code>float</code> <p>Common propensity-to-disrupt value.</p>"},{"location":"reference/solutions/gately/#tucoopy.solutions.gately.gately_point","title":"gately_point","text":"<pre><code>gately_point(game, *, tol=1e-12)\n</code></pre> <p>Compute the Gately point for an essential TU cooperative game.</p> <p>The Gately point is a single-valued imputation obtained by equalizing the propensity to disrupt across players. For an imputation \\(x\\), the propensity to disrupt of player \\(i\\) is defined as:</p> \\[ d_i(x) = \\frac{v(N) - x_i}{x_i - v(\\{i\\})}. \\] <p>The Gately point is the imputation \\(x\\) for which all players have the same propensity:</p> \\[ d_1(x) = d_2(x) = \\cdots = d_n(x). \\] <p>For essential games (where \\(v(N) &gt; \\sum_i v(\\{i\\})\\)), this condition yields a closed-form solution.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU cooperative game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for detecting non-essential games.</p> <code>1e-12</code> <p>Returns:</p> Type Description <code>GatelyResult</code> <p>Allocation and common propensity-to-disrupt value.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If: - <code>n_players &lt; 2</code>, or</p> <code>InvalidGameError</code> <p>If: - the game is non-essential, i.e.   \\(v(N) \\le \\sum_i v(\\{i\\})\\).</p> Notes <ul> <li>The Gately point lies in the imputation set.</li> <li>It balances the incentives of players to leave the grand coalition.</li> <li>The formula used here is valid precisely when the game is essential.</li> <li>The result is numerically adjusted to ensure efficiency   (sum of allocations equals \\(v(N)\\)).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; x = gately_point(g)\n&gt;&gt;&gt; sum(x) == g.value(g.grand_coalition)\nTrue\n</code></pre>"},{"location":"reference/solutions/modiclus/","title":"<code>tucoopy.solutions.modiclus</code>","text":""},{"location":"reference/solutions/modiclus/#tucoopy.solutions.modiclus--modiclus","title":"Modiclus.","text":"<p>The modiclus is a nucleolus-type solution concept defined by lexicographic minimization of pairwise excess differences.</p>"},{"location":"reference/solutions/modiclus/#tucoopy.solutions.modiclus.ModiclusResult","title":"ModiclusResult  <code>dataclass</code>","text":"<p>Result container for the modiclus computation.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> <code>levels</code> <code>list[float]</code> <p>Sequence of lexicographic levels fixed during refinement. Each level is the optimal value of the auxiliary variable <code>t</code> in that round, i.e. the minimized maximum envy.</p> <code>tight_pairs</code> <code>list[list[tuple[int, int]]] | None</code> <p>For each round, the list of ordered coalition pairs (S, T) that were tight at the optimum, meaning they achieved the maximum envy level (within tolerance).</p> <code>lp_rounds</code> <code>list[LinprogDiagnostics] | None</code> <p>Optional solver diagnostics captured after each LP solve.</p> Notes <p>The modiclus is a nucleolus-type selection concept defined on pairwise differences of excesses (often interpreted as \"maximum envy\" across coalitions). This implementation mirrors the standard lexicographic LP refinement approach used for the nucleolus, but the constraints are indexed by ordered pairs (S, T) rather than coalitions S.</p>"},{"location":"reference/solutions/modiclus/#tucoopy.solutions.modiclus.modiclus","title":"modiclus","text":"<pre><code>modiclus(\n    game,\n    *,\n    tol=1e-09,\n    max_rounds=200,\n    max_players=12,\n    require_complete=True,\n)\n</code></pre> <p>Compute the modiclus of a TU cooperative game.</p> Definition <p>Let the excess of a coalition S under an allocation x be</p> \\[ e(S, x) = v(S) - x(S), \\] <p>where \\(x(S) = \\sum_{i \\in S} x_i\\).</p> <p>The modiclus is defined via the envy (difference of excesses) between two coalitions S and T:</p> \\[ \\operatorname{envy}(S, T; x) = e(S, x) - e(T, x)                              = (v(S) - x(S)) - (v(T) - x(T)). \\] <p>The modiclus is the allocation x (typically over the pre-imputation set) that lexicographically minimizes the vector of envies over all ordered pairs \\((S, T)\\) with \\(S \\ne T\\), sorted from largest to smallest.</p> Algorithm <p>This implementation follows a nucleolus-style lexicographic LP refinement:</p> <ol> <li>Solve an LP minimizing the maximum envy over all remaining pairs (S, T).</li> <li>Identify tight pairs that achieve the maximum envy (within tolerance).</li> <li>Promote a subset of tight pairs to equality constraints (chosen so as to    increase the rank of the equality system over x).</li> <li>Repeat until x is uniquely determined or no pairs remain.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for tightness detection and for snapping tiny optimal levels to 0.</p> <code>1e-09</code> <code>max_rounds</code> <code>int</code> <p>Maximum number of lexicographic refinement rounds.</p> <code>200</code> <code>max_players</code> <code>int</code> <p>Safety cap. The number of envy constraints scales as \\(O((2^n)^2)\\), so the problem becomes large very quickly.</p> <code>12</code> <code>require_complete</code> <code>bool</code> <p>If True, require a complete characteristic function (all <code>2^n</code> coalition values explicitly present in <code>game.v</code>). If False, missing coalitions are treated as value 0 via <code>game.value</code>.</p> <code>True</code> <p>Returns:</p> Type Description <code>ModiclusResult</code> <p>Allocation, lexicographic envy levels, and optional diagnostics.</p> Notes <ul> <li>This implementation enforces efficiency only (pre-imputation set):   \\(\\sum_i x_i = v(N)\\). It does not enforce individual rationality.</li> <li>The modiclus is sensitive to the set of coalitions considered; here we   include all proper, non-empty coalitions and all ordered pairs (S, T),   S != T.</li> <li>Requires SciPy/HiGHS at runtime (<code>pip install \"tucoopy[lp]\"</code>).</li> </ul> References <p>The modiclus is introduced in the TU cooperative game theory literature as a nucleolus-type solution defined on pairwise differences of excesses. For a detailed treatment, see standard references on nucleolus-like solution concepts and their variants.</p>"},{"location":"reference/solutions/myerson/","title":"<code>tucoopy.solutions.myerson</code>","text":""},{"location":"reference/solutions/myerson/#tucoopy.solutions.myerson--myerson-value-communication-graph","title":"Myerson value (communication graph).","text":"<p>This module computes the Myerson value by applying the Myerson restriction induced by a communication graph and then computing the Shapley value of the restricted game.</p>"},{"location":"reference/solutions/myerson/#tucoopy.solutions.myerson.MyersonResult","title":"MyersonResult  <code>dataclass</code>","text":"<p>Result container for the Myerson value.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> <code>meta</code> <code>dict[str, object]</code> <p>Diagnostic metadata about the computation parameters.</p>"},{"location":"reference/solutions/myerson/#tucoopy.solutions.myerson.myerson_value","title":"myerson_value","text":"<pre><code>myerson_value(\n    game, *, edges, max_players=16, require_complete=True\n)\n</code></pre> <p>Compute the Myerson value for a TU game with communication constraints.</p> <p>In cooperative games with restricted communication, players can only cooperate effectively within connected components of a communication graph. Given an undirected graph \\(G\\), define the Myerson restricted game:</p> \\[ v_G(S) = \\sum_{C \\in \\mathrm{components}_G(S)} v(C). \\] <p>The Myerson value is then defined as the Shapley value of this restricted game:</p> \\[ \\phi^{\\text{Myerson}}(v, G) = \\phi(v_G). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>edges</code> <code>Iterable[tuple[int, int]]</code> <p>Undirected edges of the communication graph.</p> required <code>max_players</code> <code>int</code> <p>Safety bound. The computation is exponential in <code>n_players</code>.</p> <code>16</code> <code>require_complete</code> <code>bool</code> <p>If True, require the original game to be complete.</p> <code>True</code> <p>Returns:</p> Type Description <code>MyersonResult</code> <p>Allocation vector and metadata.</p> <p>Raises:</p> Type Description <code>NotSupportedError</code> <p>If the number of players exceeds <code>max_players</code>.</p> <code>InvalidGameError</code> <p>If <code>require_complete=True</code> and the game is incomplete.</p> <code>InvalidParameterError</code> <p>If the communication graph <code>edges</code> is invalid (e.g. out-of-range endpoints).</p> Notes <ul> <li>If the graph is complete (all players connected), the Myerson value   reduces to the Shapley value.</li> <li>If the graph has no edges, each player acts alone and the value reduces   to the singleton payoffs.</li> <li>The Myerson value models cooperation under communication constraints   and is a fundamental concept in network games.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; res = myerson_value(g, edges=[(0,1), (1,2)])\n&gt;&gt;&gt; res.x\n</code></pre>"},{"location":"reference/solutions/nucleolus/","title":"<code>tucoopy.solutions.nucleolus</code>","text":""},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus--nucleolus-and-pre-nucleolus","title":"Nucleolus and pre-nucleolus.","text":"<p>This module implements lexicographic LP refinement for the nucleolus (and pre-nucleolus).</p>"},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus.NucleolusResult","title":"NucleolusResult  <code>dataclass</code>","text":"<p>Result container for the nucleolus / pre-nucleolus computation.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> <code>levels</code> <code>list[float]</code> <p>Sequence of epsilon levels fixed during the lexicographic minimization. Each entry corresponds to the maximum excess minimized at that round.</p> <code>tight_sets</code> <code>list[list[int]] | None</code> <p>For each round, the list of coalitions that were tight (achieved the maximum excess) at that level.</p> <code>lp_rounds</code> <code>list[LinprogDiagnostics] | None</code> <p>Optional diagnostics from each LP solve (HiGHS / SciPy).</p>"},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus.disruption_nucleolus","title":"disruption_nucleolus","text":"<pre><code>disruption_nucleolus(game)\n</code></pre> <p>Disruption nucleolus.</p> <p>This variant minimizes the lexicographic vector of disruption ratios:</p> \\[ e_{dis}(S, x) = \\frac{v(S) - x(S)}{M(S)}, \\] <p>where \\(M\\) is the utopia payoff vector and</p> \\[ M(S) = \\sum_{i \\in S} M_i. \\] Interpretation <p>The excess of a coalition is scaled by its utopia potential. Coalitions that could potentially demand more (high utopia value) are weighted accordingly.</p> Notes <ul> <li>Closely related to the concept of propensity to disrupt.</li> <li>Used in bargaining and stability analyses.</li> <li>Reduces to the standard nucleolus when utopia payoffs are uniform.</li> </ul> <p>Returns:</p> Type Description <code>NucleolusResult</code> <p>Allocation and diagnostic information.</p>"},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus.nucleolus","title":"nucleolus","text":"<pre><code>nucleolus(game, *, tol=1e-09, max_rounds=200, excess=None)\n</code></pre> <p>Compute the nucleolus of a TU cooperative game.</p> <p>The nucleolus is the allocation in the imputation set that lexicographically minimizes coalition excesses:</p> \\[ e(S, x) = v(S) - x(S), \\] <p>from largest to smallest.</p> Generalized excess <p>As in <code>prenucleolus</code>, this implementation supports a generalized excess function through the <code>excess</code> parameter, allowing the computation of several nucleolus variants (per-capita, proportional, disruption-based, etc.) without modifying the core algorithm.</p> Individual rationality <p>In addition to efficiency, this version enforces</p> \\[ x_i \\ge v(\\{i\\}) \\quad \\text{for all players } i, \\] <p>restricting the solution to the imputation set.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for tightness detection.</p> <code>1e-9</code> <code>max_rounds</code> <code>int</code> <p>Maximum number of lexicographic refinement rounds.</p> <code>200</code> <code>excess</code> <code>callable</code> <p>Custom excess function <code>excess(S, xS, game)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>NucleolusResult</code> <p>Allocation, epsilon levels, and optional diagnostics.</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the imputation set is empty, i.e. \\(\\sum_i v(\\{i\\}) &gt; v(N)\\).</p> Notes <ul> <li>The nucleolus always lies in the imputation set.</li> <li>It is one of the most important solution concepts in cooperative   game theory due to its strong stability properties.</li> <li>Requires SciPy/HiGHS at runtime (<code>pip install \"tucoopy[lp]\"</code>).</li> <li>The algorithm terminates when enough tight coalitions determine   the allocation uniquely.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; nucleolus(g).x\n</code></pre>"},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus.per_capita_nucleolus","title":"per_capita_nucleolus","text":"<pre><code>per_capita_nucleolus(game)\n</code></pre> <p>Per-capita nucleolus.</p> <p>Minimizes the lexicographic vector of</p> \\[e_{pc}(S, x) = \\frac{v(S) - x(S)}{|S|}.\\]"},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus.prenucleolus","title":"prenucleolus","text":"<pre><code>prenucleolus(\n    game, *, tol=1e-09, max_rounds=200, excess=None\n)\n</code></pre> <p>Compute the pre-nucleolus of a TU cooperative game.</p> <p>The pre-nucleolus is defined as the allocation that lexicographically minimizes the vector of coalition excesses:</p> \\[ e(S, x) = v(S) - x(S), \\] <p>ordered from largest to smallest.</p> Generalized excess <p>This implementation supports a generalized notion of excess through the <code>excess</code> parameter. Instead of the classical excess, one may supply a custom function</p> <p><code>excess(S, xS, game)</code></p> <p>allowing the algorithm to minimize lexicographically any transformed excess such as:</p> <ul> <li>per-capita excess: \\(\\fra{v(S)-x(S)}{|S|}\\),</li> <li>proportional excess: \\(\\frac{v(S)-x(S)}{v(S)}\\),</li> <li>disruption-based excess, etc.</li> </ul> <p>This turns the routine into a generic lexicographic excess minimization engine.</p> Algorithm <p>The method follows the standard lexicographic LP refinement:</p> <ol> <li>Solve an LP minimizing the maximum excess over all coalitions.</li> <li>Identify coalitions that achieve this maximum excess (tight sets).</li> <li>Fix their excess as equality constraints.</li> <li>Repeat on the reduced problem.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for tightness detection.</p> <code>1e-9</code> <code>max_rounds</code> <code>int</code> <p>Maximum number of lexicographic refinement rounds.</p> <code>200</code> <code>excess</code> <code>callable</code> <p>Custom excess function <code>excess(S, xS, game)</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>NucleolusResult</code> <p>Allocation, epsilon levels, and optional diagnostics.</p> Notes <ul> <li>Only efficiency is enforced (no individual rationality).</li> <li>The result may lie outside the imputation set.</li> <li>Requires SciPy/HiGHS at runtime (<code>pip install \"tucoopy[lp]\"</code>).</li> <li>The algorithm terminates when the solution is uniquely determined   by the accumulated tight constraints.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; prenucleolus(g).x\n</code></pre>"},{"location":"reference/solutions/nucleolus/#tucoopy.solutions.nucleolus.proportional_nucleolus","title":"proportional_nucleolus","text":"<pre><code>proportional_nucleolus(game)\n</code></pre> <p>Proportional nucleolus.</p> <p>This solution minimizes the lexicographic vector of relative (proportional) excesses:</p> \\[ e_{prop}(S, x) = \\frac{v(S) - x(S)}{v(S)}. \\] <p>Coalitions are evaluated by how large their dissatisfaction is relative to their own worth.</p> Notes <ul> <li>Coalitions with larger worth are normalized accordingly.</li> <li>Common in bankruptcy and allocation problems where proportional   dissatisfaction is more meaningful than absolute dissatisfaction.</li> <li>Coalitions with \\(v(S)=0\\) are ignored (excess defined as 0).</li> </ul> <p>Returns:</p> Type Description <code>NucleolusResult</code> <p>Allocation and diagnostic information.</p>"},{"location":"reference/solutions/owen/","title":"<code>tucoopy.solutions.owen</code>","text":""},{"location":"reference/solutions/owen/#tucoopy.solutions.owen--owen-value-a-priori-unions","title":"Owen value (a priori unions).","text":"<p>The Owen value extends the Shapley value to settings where players are partitioned into unions (blocks) that act as a priori coalitions.</p>"},{"location":"reference/solutions/owen/#tucoopy.solutions.owen.OwenResult","title":"OwenResult  <code>dataclass</code>","text":"<p>Result container for the Owen value.</p> <p>Attributes:</p> Name Type Description <code>x</code> <code>list[float]</code> <p>Allocation vector (length <code>n_players</code>).</p> <code>meta</code> <code>dict[str, object]</code> <p>Diagnostic metadata about the computation, including: - number of unions, - configuration parameters.</p>"},{"location":"reference/solutions/owen/#tucoopy.solutions.owen.owen_value","title":"owen_value","text":"<pre><code>owen_value(\n    game, *, unions, max_players=16, require_complete=True\n)\n</code></pre> <p>Compute the Owen value for a TU game with a priori unions (coalition structure).</p> <p>The Owen value extends the Shapley value to games where players are partitioned into predefined groups (unions). It is defined by a two-level random process:</p> <ol> <li>The unions arrive in a random order (Shapley at the union level).</li> <li>Within each union, players arrive in a random order (Shapley inside the union).</li> </ol> <p>Formally, this results in a weighted sum of marginal contributions where the weights reflect both the order of unions and the order of players within each union.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>unions</code> <code>Sequence[Iterable[int] | int]</code> <p>Partition of players into disjoint non-empty unions. Each element may be either: - an iterable of player indices, or - a coalition mask. The unions must be disjoint and cover all players.</p> required <code>max_players</code> <code>int</code> <p>Safety bound. The algorithm is exponential in <code>n_players</code>.</p> <code>16</code> <code>require_complete</code> <code>bool</code> <p>If True, require the game to specify values for all \\(2^n\\) coalitions.</p> <code>True</code> <p>Returns:</p> Type Description <code>OwenResult</code> <p>Allocation vector and metadata.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If: - unions are invalid (not disjoint or not covering all players),</p> <code>NotSupportedError</code> <p>If <code>n_players &gt; max_players</code>.</p> <code>InvalidGameError</code> <p>If the game is incomplete when <code>require_complete=True</code>.</p> Notes <ul> <li>When there is a single union containing all players, the Owen value   reduces to the Shapley value.</li> <li>When each player is its own union, the Owen value also reduces to   the Shapley value.</li> <li>The Owen value is central in cooperative games with coalition structures   and models situations where cooperation is constrained by pre-existing groups.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Two unions: {0,1} and {2,3}\n&gt;&gt;&gt; res = owen_value(g, unions=[[0,1], [2,3]])\n&gt;&gt;&gt; res.x\n</code></pre>"},{"location":"reference/solutions/shapley/","title":"<code>tucoopy.solutions.shapley</code>","text":""},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley--shapley-value-and-semivalues","title":"Shapley value and semivalues.","text":"<p>This module implements the Shapley value, weighted Shapley variants, Monte Carlo approximation, and a generic semivalue helper.</p>"},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley.semivalue","title":"semivalue","text":"<pre><code>semivalue(game, *, weights_by_k, normalize=False)\n</code></pre> <p>Compute a semivalue for a TU cooperative game.</p> <p>A semivalue is defined by weights \\(p_k\\) for coalition sizes \\(k=0,\\ldots,n-1\\):</p> \\[ \\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}} p_{|S|} \\big( v(S \\cup \\{i\\}) - v(S) \\big). \\] <p>The standard semivalue normalization is:</p> \\[ \\sum_{k=0}^{n-1} \\binom{n-1}{k} \\, p_k = 1. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>weights_by_k</code> <code>Sequence[float]</code> <p>Sequence of length <code>n_players</code> where entry k is \\(p_k\\).</p> required <code>normalize</code> <code>bool</code> <p>If True, rescale \\(p_k\\) to satisfy the semivalue normalization.</p> <code>False</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Allocation vector of length <code>n_players</code>.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If <code>weights_by_k</code> has the wrong length, or normalization is requested with all-zero weights.</p> Notes <ul> <li>The Shapley value is a special case of a semivalue with   \\(p_k = \\frac{k!(n-k-1)!}{n!}\\).</li> <li>Complexity is \\(O(n 2^n)\\) due to coalition enumeration.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Example: choose p_k proportional to 1/(n * C(n-1,k)) and normalize\n&gt;&gt;&gt; phi = semivalue(g, weights_by_k=[1.0]*g.n_players, normalize=True)\n&gt;&gt;&gt; len(phi) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley.shapley_value","title":"shapley_value","text":"<pre><code>shapley_value(game)\n</code></pre> <p>Compute the Shapley value for a TU cooperative game.</p> <p>The Shapley value assigns to each player their expected marginal contribution under a uniformly random permutation of players.</p> <p>Formally:</p> \\[ \\phi_i = \\sum_{S \\subseteq N \\setminus \\{i\\}}     \\frac{|S|! (n-|S|-1)!}{n!}     \\bigl( v(S \\cup \\{i\\}) - v(S) \\bigr). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>TU cooperative game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Shapley value allocation (length <code>n_players</code>).</p> Notes <ul> <li>Complexity is \\(O(n 2^n)\\).</li> <li>Exact and deterministic; suitable for small to medium <code>n</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g = Game.from_value_function(n_players=3, value_fn=lambda S: float(len(S)))\n&gt;&gt;&gt; shapley_value(g)\n[1.0, 1.0, 1.0]\n</code></pre>"},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley.shapley_value_fast","title":"shapley_value_fast","text":"<pre><code>shapley_value_fast(game, *, backend='auto')\n</code></pre> <p>Fast exact Shapley value via Harsanyi dividends (M\u00f6bius transform).</p> <p>Using Harsanyi dividends d(S) (unanimity coordinates), the Shapley value admits the closed form:</p> \\[ \\phi_i(v) = \\sum_{S \\ni i} \\frac{d(S)}{|S|}. \\] <p>This implementation computes dividends via a fast M\u00f6bius transform and then aggregates contributions across coalitions.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>TU game.</p> required <code>backend</code> <code>('auto', 'numpy', 'python')</code> <p>Backend for the M\u00f6bius transform: - \"auto\": try NumPy, fall back to Python - \"numpy\": force NumPy (raises ImportError if unavailable) - \"python\": pure-Python</p> <code>\"auto\"</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>The Shapley value allocation (length <code>n_players</code>).</p> Notes <ul> <li>Complexity is \\(O(n 2^n)\\), like the classic formula, but with substantially   better constants when the M\u00f6bius transform uses NumPy.</li> <li>This is an exact method (not Monte Carlo).</li> <li>Conceptually, it decomposes the game into unanimity games and distributes   each dividend equally among players in the coalition.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi = shapley_value_fast(g, backend=\"auto\")\n&gt;&gt;&gt; len(phi) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley.shapley_value_sample","title":"shapley_value_sample","text":"<pre><code>shapley_value_sample(game, *, n_samples, seed=None)\n</code></pre> <p>Monte Carlo estimate of the Shapley value using random permutations.</p> <p>For each sampled permutation, the marginal contribution vector is computed. The estimator returns the sample mean and an estimated per-player standard error.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>TU cooperative game.</p> required <code>n_samples</code> <code>int</code> <p>Number of random permutations to sample.</p> required <code>seed</code> <code>int | None</code> <p>Random seed for reproducibility.</p> <code>None</code> <p>Returns:</p> Type Description <code>(phi_hat, stderr)</code> <p>Estimated Shapley value and per-player standard error.</p> Notes <ul> <li>Complexity is \\(O(n \\cdot n_{samples})\\).</li> <li>Suitable for large <code>n</code> when exact computation is infeasible.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi_hat, stderr = shapley_value_sample(g, n_samples=1000)\n</code></pre>"},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley.shapley_value_sample_stratified","title":"shapley_value_sample_stratified","text":"<pre><code>shapley_value_sample_stratified(\n    game, *, samples_per_k, seed=None\n)\n</code></pre> <p>Stratified Monte Carlo estimate of the Shapley value by coalition size.</p> <p>This estimator samples random coalitions \\(S\\) of each size \\(k = 0 \\ldots n-1\\) from \\(N \\setminus \\{i\\}\\) and averages the marginal contributions:</p> \\[\\Delta_i(S) = v(S \\cup \\{i\\}) - v(S)\\] <p>weighted by the Shapley coefficient:</p> \\[w_k = \\frac{k!(n-k-1)!}{n!}.\\] <p>Compared to permutation sampling, this can reduce variance in games where marginal contributions depend strongly on coalition size.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>TU game.</p> required <code>samples_per_k</code> <code>int</code> <p>Number of sampled coalitions per coalition size k, for each player. Must be &gt;= 1.</p> required <code>seed</code> <code>int | None</code> <p>RNG seed.</p> <code>None</code> <p>Returns:</p> Type Description <code>(phi_hat, stderr)</code> <p><code>phi_hat</code> is the estimated Shapley value and <code>stderr</code> is an estimated per-player standard error (based on sample variance across draws).</p> Notes <ul> <li>Total samples scale as O(n^2 * samples_per_k) because we sample for each player   and each k.</li> <li>This is still much cheaper than O(n 2^n) when n is moderate/large.</li> <li>stderr here is an empirical standard error from the stratified samples.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi_hat, se = shapley_value_sample_stratified(g, samples_per_k=200, seed=0)\n&gt;&gt;&gt; len(phi_hat) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/shapley/#tucoopy.solutions.shapley.weighted_shapley_value","title":"weighted_shapley_value","text":"<pre><code>weighted_shapley_value(game, *, weights)\n</code></pre> <p>Compute the weighted Shapley value (Shapley value with weighted symmetry).</p> <p>Using Harsanyi dividends \\(d(S)\\), the weighted Shapley value is:</p> \\[ \\phi_i = \\sum_{S \\ni i} d(S) \\frac{w_i}{\\sum_{j \\in S} w_j}. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>weights</code> <code>Sequence[float]</code> <p>Positive player weights (length <code>n_players</code>).</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Allocation vector of length <code>n_players</code>.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the weights are non-positive or have the wrong length.</p> Notes <ul> <li>This uses Harsanyi dividends internally, so the overall cost is dominated   by computing the M\u00f6bius transform (typically \\(O(n2^n)\\)).</li> <li>Setting all weights equal reduces to the standard Shapley value.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; phi_w = weighted_shapley_value(g, weights=[2.0, 1.0, 1.0])\n&gt;&gt;&gt; len(phi_w) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/solve/","title":"<code>tucoopy.solutions.solve</code>","text":""},{"location":"reference/solutions/solve/#tucoopy.solutions.solve--solution-dispatcher","title":"Solution dispatcher.","text":"<p>This module provides <code>solve</code>, a single entry point that dispatches to the individual solution concept implementations under <code>tucoopy.solutions</code>.</p>"},{"location":"reference/solutions/solve/#tucoopy.solutions.solve.SolveResult","title":"SolveResult  <code>dataclass</code>","text":"<p>Result container for solution methods.</p> <p>Attributes:</p> Name Type Description <code>method</code> <code>str</code> <p>Name of the solution method used.</p> <code>x</code> <code>list[float]</code> <p>Payoff vector (allocation/imputation) returned by the method.</p> <code>meta</code> <code>dict[str, object] | None</code> <p>Optional metadata returned by the solver, such as: - LP iterations, - epsilon values, - solver diagnostics, - structural information.</p> Notes <p>This lightweight container standardizes the output of all solution methods exposed through <code>solve</code>, enabling uniform downstream processing, logging, or visualization.</p>"},{"location":"reference/solutions/solve/#tucoopy.solutions.solve.solve","title":"solve","text":"<pre><code>solve(game, *, method='shapley', **kwargs)\n</code></pre> <p>Unified dispatcher for cooperative game solution concepts.</p> <p>This function provides a single entry point to compute a wide range of point solutions (allocations/imputations) for TU cooperative games.</p> <p>The desired method is selected by name, and any additional keyword arguments required by the method can be passed through <code>**kwargs</code>.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU cooperative game.</p> required <code>method</code> <code>Method</code> <p>Name of the solution concept to compute. Supported values include:</p> <ul> <li>\"shapley\", \"shapley_sample\"</li> <li>\"banzhaf\", \"normalized_banzhaf\"</li> <li>\"nucleolus\", \"prenucleolus\"</li> <li>\"modiclus\"</li> <li>\"tau\"</li> <li>\"gately\"</li> <li>\"myerson\"</li> <li>\"owen\"</li> </ul> <code>\"shapley\"</code> <code>**kwargs</code> <code>Any</code> <p>Additional arguments forwarded to the specific solver. Examples:</p> <ul> <li><code>myerson</code>: <code>edges=[(u,v), ...]</code>, <code>max_players</code>, <code>require_complete</code></li> <li><code>owen</code>: <code>unions=[[...], ...]</code>, <code>max_players</code>, <code>require_complete</code></li> </ul> <code>{}</code> <p>Returns:</p> Type Description <code>SolveResult</code> <p>Container with the solution vector and optional metadata.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the method name is unknown or required parameters are missing/invalid.</p> Notes <ul> <li>This function does not implement the algorithms itself; it dispatches   to the appropriate module under <code>tucoopy.solutions</code>.</li> <li>The goal is to offer a stable, high-level API for experimentation,   scripting, and integration with analysis/visualization tools.</li> <li>Metadata returned in <code>SolveResult.meta</code> may include solver diagnostics,   LP iteration counts, or epsilon values for geometric methods.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; res = solve(g, method=\"shapley\")\n&gt;&gt;&gt; res.x\n</code></pre> <pre><code>&gt;&gt;&gt; res = solve(g, method=\"nucleolus\")\n&gt;&gt;&gt; res.meta[\"lp_rounds\"]\n</code></pre> <pre><code>&gt;&gt;&gt; res = solve(g, method=\"myerson\", edges=[(0,1), (1,2)])\n&gt;&gt;&gt; res.x\n</code></pre>"},{"location":"reference/solutions/tau/","title":"<code>tucoopy.solutions.tau</code>","text":""},{"location":"reference/solutions/tau/#tucoopy.solutions.tau--tau-value-helpers","title":"Tau value helpers.","text":"<p>This module provides the utopia payoff and minimal rights vectors, and a tau value implementation.</p>"},{"location":"reference/solutions/tau/#tucoopy.solutions.tau.minimal_rights","title":"minimal_rights","text":"<pre><code>minimal_rights(game, M=None)\n</code></pre> <p>Compute the minimal rights vector \\(m\\) of a TU game.</p> <p>Given the utopia payoff vector \\(M\\), the minimal right of player \\(i\\) is:</p> \\[ m_i = \\max_{S \\ni i}       \\left[ v(S) - \\sum_{j \\in S \\setminus \\{i\\}} M_j \\right]. \\] <p>Intuitively, this represents the minimum payoff player \\(i\\) can claim without being blocked by any coalition.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>M</code> <code>list[float] | None</code> <p>Precomputed utopia payoff vector. If None, it is computed internally.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Minimal rights vector of length <code>n_players</code>.</p> Notes <ul> <li>The minimal rights vector depends on the utopia payoff.</li> <li>Together, \\((m, M)\\) define a line segment used to construct the   tau value.</li> <li>This vector provides a lower bound for reasonable imputations.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; m = minimal_rights(g)\n&gt;&gt;&gt; len(m) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/tau/#tucoopy.solutions.tau.tau_value","title":"tau_value","text":"<pre><code>tau_value(game, *, tol=1e-09)\n</code></pre> <p>Compute the tau value of a TU game.</p> <p>The tau value is defined (when applicable) as the intersection of the imputation hyperplane with the line segment connecting the minimal rights vector \\(m\\) and the utopia payoff vector \\(M\\):</p> \\[ \\tau = m + \\alpha (M - m), \\] <p>where the scalar \\(\\alpha\\) is chosen such that:</p> \\[ \\sum_i \\tau_i = v(N). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <code>tol</code> <code>float</code> <p>Numerical tolerance for detecting degeneracy.</p> <code>1e-9</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>Tau value allocation.</p> <p>Raises:</p> Type Description <code>InvalidGameError</code> <p>If the interpolation between \\(m\\) and \\(M\\) is ill-defined (degenerate case where the line cannot intersect the imputation plane).</p> Notes <ul> <li>The tau value is particularly well-behaved for quasi-balanced games.</li> <li>It lies on the line segment between minimal rights and utopia payoff,   balancing lower and upper bounds on player claims.</li> <li>If \\(\\sum M_i = \\sum m_i = v(N)\\), the tau value coincides with \\(m\\).</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tau = tau_value(g)\n&gt;&gt;&gt; len(tau) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/solutions/tau/#tucoopy.solutions.tau.utopia_payoff","title":"utopia_payoff","text":"<pre><code>utopia_payoff(game)\n</code></pre> <p>Compute the utopia payoff vector \\(M\\) of a TU game.</p> <p>The utopia payoff of player \\(i\\) is defined as:</p> \\[ M_i = v(N) - v(N \\setminus \\{i\\}), \\] <p>i.e. the maximum amount player \\(i\\) could hope to obtain if the rest of the players formed the grand coalition without them.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game.</p> required <p>Returns:</p> Type Description <code>list[float]</code> <p>Utopia payoff vector of length <code>n_players</code>.</p> Notes <ul> <li>\\(M\\) is sometimes called the marginal vector at the grand coalition.</li> <li>It provides an upper bound for reasonable imputations.</li> <li>The utopia payoff plays a central role in the definition of the   minimal rights and the tau value.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; M = utopia_payoff(g)\n&gt;&gt;&gt; len(M) == g.n_players\nTrue\n</code></pre>"},{"location":"reference/transforms/algebra/","title":"<code>tucoopy.transforms.algebra</code>","text":""},{"location":"reference/transforms/algebra/#tucoopy.transforms.algebra--algebraic-transformations-of-tu-games","title":"Algebraic transformations of TU games.","text":"<p>The functions in this module build new games from an existing one by applying simple algebraic operations to the characteristic function:</p> <ul> <li><code>scale_game</code>: multiply all coalition values by a scalar.</li> <li><code>shift_game</code>: add a constant (with TU conventions preserved).</li> <li><code>affine_game</code>: combine scale and shift.</li> </ul> <p>These are useful for normalization, unit changes, and testing linearity / scale-equivariance properties of solution concepts.</p>"},{"location":"reference/transforms/algebra/#tucoopy.transforms.algebra.affine_game","title":"affine_game","text":"<pre><code>affine_game(game, factor, constant)\n</code></pre> <p>Apply an affine transformation to the characteristic function of a TU game.</p> <p>The new game is defined by</p> \\[ (a v + b)(S) =     \\begin{cases}         0, &amp; S = \\varnothing \\\\         a \\, v(S) + b, &amp; S \\neq \\varnothing     \\end{cases} \\] <p>which combines scaling and translation while preserving the TU convention.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game.</p> required <code>factor</code> <code>float</code> <p>Multiplicative factor \\(a\\).</p> required <code>constant</code> <code>float</code> <p>Additive constant \\(b\\).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>New affine-transformed game.</p> Notes <p>Affine transformations define an equivalence class of TU games that share the same strategic structure.</p> <p>Most central solution concepts are invariant (up to scaling) under affine transformations. Studying games up to affine equivalence is standard in cooperative game theory, particularly in:</p> <ul> <li>normalization procedures,</li> <li>theoretical characterizations of values,</li> <li>geometric analysis of the core and related sets.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g2 = affine_game(g, 2.0, 3.0)\n&gt;&gt;&gt; g2.value(0)\n0.0\n</code></pre>"},{"location":"reference/transforms/algebra/#tucoopy.transforms.algebra.scale_game","title":"scale_game","text":"<pre><code>scale_game(game, factor)\n</code></pre> <p>Scale a TU game by a multiplicative factor.</p> <p>This transformation defines a new game whose characteristic function is</p> \\[ (a v)(S) = a \\, v(S), \\] <p>for every coalition \\(S\\), with the TU convention preserved:</p> \\[ (a v)(\\varnothing) = 0. \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game.</p> required <code>factor</code> <code>float</code> <p>Scaling factor \\(a\\).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>New scaled game.</p> Notes <p>Many solution concepts are scale-equivariant. For example,</p> <ul> <li>Shapley value</li> <li>Nucleolus</li> <li>Kernel</li> <li>Core</li> </ul> <p>all scale proportionally when the game is scaled.</p> <p>This operation is useful for normalization and for comparing games under different units (e.g., cost vs revenue).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g2 = scale_game(g, 2.0)\n&gt;&gt;&gt; g2.value(g2.grand_coalition) == 2 * g.value(g.grand_coalition)\nTrue\n</code></pre>"},{"location":"reference/transforms/algebra/#tucoopy.transforms.algebra.shift_game","title":"shift_game","text":"<pre><code>shift_game(game, constant)\n</code></pre> <p>Add a constant to all non-empty coalitions of a TU game.</p> <p>This transformation defines a new game</p> \\[ (v + c)(S) =     \\begin{cases}         0, &amp; S = \\varnothing \\\\         v(S) + c, &amp; S \\neq \\varnothing     \\end{cases} \\] <p>preserving the TU requirement \\(v(\\varnothing)=0\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game.</p> required <code>constant</code> <code>float</code> <p>Additive constant \\(c\\).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>New shifted game.</p> Notes <p>This is an affine translation of the game.</p> <p>Many solution concepts are translation-invariant, meaning their payoff allocations do not change under this transformation. This includes:</p> <ul> <li>Shapley value</li> <li>Nucleolus</li> <li>Kernel</li> <li>Core membership</li> </ul> <p>This transformation is central when studying equivalent games and normalizations such as zero-normalized games.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g2 = shift_game(g, 5.0)\n&gt;&gt;&gt; g2.value(0)  # empty coalition remains 0\n0.0\n&gt;&gt;&gt; g2.value(g2.grand_coalition) == g.value(g.grand_coalition) + 5\nTrue\n</code></pre>"},{"location":"reference/transforms/combine/","title":"<code>tucoopy.transforms.combine</code>","text":""},{"location":"reference/transforms/combine/#tucoopy.transforms.combine--combining-games-sumdifference","title":"Combining games (sum/difference).","text":"<p>TU games on a fixed player set form a vector space under pointwise addition and scalar multiplication. This module implements the basic binary operations used in examples and tests.</p>"},{"location":"reference/transforms/combine/#tucoopy.transforms.combine.add_games","title":"add_games","text":"<pre><code>add_games(left, right)\n</code></pre> <p>Add (sum) two TU cooperative games defined on the same player set.</p> <p>The sum game is defined pointwise on coalitions:</p> \\[ (v + w)(S) = v(S) + w(S), \\quad \\forall S \\subseteq N, \\] <p>with the TU convention preserved:</p> \\[ (v+w)(\\varnothing) = 0. \\] <p>Parameters:</p> Name Type Description Default <code>left</code> <code>Game</code> <p>First game (characteristic function \\(v\\)).</p> required <code>right</code> <code>Game</code> <p>Second game (characteristic function \\(w\\)).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>The sum game \\(v+w\\).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the two games do not have the same number of players.</p> Notes <ul> <li>TU games on a fixed player set form a vector space under pointwise   addition and scalar multiplication. This function implements the   addition operation.</li> <li>Many solution concepts are additive (linearity). For example, the   Shapley value satisfies:</li> </ul> <p>$$   \\phi(v+w) = \\phi(v) + \\phi(w).   $$</p> <p>Additivity is one of the classic axioms characterizing the Shapley value. - Player labels: if <code>left.player_labels</code> is available it is used;   otherwise <code>right.player_labels</code> is used.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g_sum = add_games(g1, g2)\n&gt;&gt;&gt; g_sum.value(g_sum.grand_coalition) == g1.value(g1.grand_coalition) + g2.value(g2.grand_coalition)\nTrue\n</code></pre>"},{"location":"reference/transforms/combine/#tucoopy.transforms.combine.sub_games","title":"sub_games","text":"<pre><code>sub_games(left, right)\n</code></pre> <p>Subtract two TU cooperative games defined on the same player set.</p> <p>The difference game is defined pointwise on coalitions:</p> \\[ (v - w)(S) = v(S) - w(S), \\quad \\forall S \\subseteq N, \\] <p>with the TU convention preserved:</p> \\[ (v-w)(\\varnothing) = 0. \\] <p>Parameters:</p> Name Type Description Default <code>left</code> <code>Game</code> <p>Minuend game (characteristic function \\(v\\)).</p> required <code>right</code> <code>Game</code> <p>Subtrahend game (characteristic function \\(w\\)).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>The difference game \\(v-w\\).</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the two games do not have the same number of players.</p> Notes <ul> <li>Subtraction is addition with a negative scalar multiple:   \\(v - w = v + (-1) w\\).</li> <li>This operation is useful for:<ul> <li>comparing games (e.g., incremental contribution of a feature),</li> <li>defining derived games (e.g., \\(v - u\\) where \\(u\\) is an additive/inessential part),</li> <li>diagnostics (checking how far a game is from a reference class).</li> </ul> </li> <li>Player labels: if <code>left.player_labels</code> is available it is used;   otherwise <code>right.player_labels</code> is used.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g_diff = sub_games(g1, g2)\n&gt;&gt;&gt; g_diff.value(0)  # empty coalition remains 0\n0.0\n</code></pre>"},{"location":"reference/transforms/communication/","title":"<code>tucoopy.transforms.communication</code>","text":""},{"location":"reference/transforms/communication/#tucoopy.transforms.communication--communication-constraints-and-restricted-games","title":"Communication constraints and restricted games.","text":"<p>This module currently provides the Myerson restriction induced by a communication graph. It constructs a new TU game where a coalition's worth is the sum of the worths of its connected components in the communication graph.</p>"},{"location":"reference/transforms/communication/#tucoopy.transforms.communication.myerson_restriction","title":"myerson_restriction","text":"<pre><code>myerson_restriction(\n    game, *, edges, require_complete=True, max_players=16\n)\n</code></pre> <p>Compute the Myerson restriction of a TU game induced by a communication graph.</p> <p>In cooperative games with communication constraints, players can only cooperate effectively within connected components of the communication graph. Given an undirected graph \\(G=(N,E)\\) and a coalition \\(S \\subseteq N\\), let \\(\\{C_1, \\dots, C_k\\}\\) be the connected components of the subgraph induced by \\(S\\). The Myerson restricted game \\(v_G\\) is defined by:</p> \\[ v_G(S) = \\sum_{C \\in \\mathrm{components}_G(S)} v(C), \\] <p>with the TU convention \\(v_G(\\varnothing)=0\\).</p> <p>Intuition:     A coalition \\(S\\) can only realize the value of the groups that can actually     communicate (the connected components). The total value is the sum of the     values generated by each communicating group.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game \\(v\\) on the player set \\(N\\).</p> required <code>edges</code> <code>Iterable[tuple[int, int]]</code> <p>Undirected edges of the communication graph \\(G\\) as pairs of player indices. Self-loops are ignored. Duplicate edges are allowed.</p> required <code>require_complete</code> <code>bool</code> <p>If True, require <code>game</code> to specify a complete characteristic function, i.e. values for all \\(2^n\\) coalitions. This restriction is useful to avoid silently treating missing coalitions as 0 when <code>Game.value()</code> is used.</p> <code>True</code> <code>max_players</code> <code>int</code> <p>Safety limit for the number of players. This routine enumerates all coalitions and is therefore exponential in <code>n_players</code>.</p> <code>16</code> <p>Returns:</p> Type Description <code>Game</code> <p>A new complete TU game with characteristic function \\(v_G\\).</p> <p>Raises:</p> Type Description <code>NotSupportedError</code> <p>If <code>n_players &gt; max_players</code>.</p> <code>InvalidGameError</code> <p>If <code>require_complete=True</code> and the game does not specify all \\(2^n\\) coalition values.</p> <code>InvalidParameterError</code> <p>If any edge endpoint is out of range.</p> Notes <ul> <li>Complexity: This function enumerates all coalitions, so its runtime and   memory scale as \\(\\Theta(2^n)\\). Use <code>max_players</code> as a guardrail.</li> <li>The resulting game is complete: it explicitly stores values for every coalition.</li> <li>This function implements the restricted game used to define the Myerson value   (the Shapley value of \\(v_G\\)) in communication situations.</li> </ul> <p>Examples:</p> <p>Restrict a 3-player game with a path graph 0--1--2:</p> <pre><code>&gt;&gt;&gt; gG = myerson_restriction(g, edges=[(0, 1), (1, 2)])\n&gt;&gt;&gt; gG.value(0)  # empty coalition\n0.0\n</code></pre> <p>If players 0 and 2 cannot communicate directly (only through 1), then coalition {0,2} has two singleton components:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.coalition import mask_from_players\n&gt;&gt;&gt; S = mask_from_players([0, 2])\n&gt;&gt;&gt; gG.value(S) == g.value(mask_from_players([0])) + g.value(mask_from_players([2]))\nTrue\n</code></pre>"},{"location":"reference/transforms/derived/","title":"<code>tucoopy.transforms.derived</code>","text":"<p>Derived games.</p>"},{"location":"reference/transforms/derived/#tucoopy.transforms.derived--this-module-implements-standard-operators-that-derive-a-new-game-from-an","title":"This module implements standard operators that derive a new game from an","text":"<p>existing one, such as:</p> <ul> <li>Dual game,</li> <li>Subgames and restrictions to subsets of players.</li> </ul>"},{"location":"reference/transforms/derived/#tucoopy.transforms.derived.dual_game","title":"dual_game","text":"<pre><code>dual_game(game)\n</code></pre> <p>Compute the dual game (sometimes called the complement game) of a TU game.</p> <p>Given a TU game \\(v\\) on the player set \\(N\\), its dual game \\(v^*\\) is defined by:</p> \\[ v^*(S) =   \\begin{cases}     0, &amp; S = \\varnothing \\\\     v(N) - v(N \\setminus S), &amp; S \\neq \\varnothing   \\end{cases} \\] <p>where \\(N \\setminus S\\) denotes the complement coalition.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game \\(v\\).</p> required <p>Returns:</p> Type Description <code>Game</code> <p>The dual game \\(v^*\\), defined on the same player set.</p> Notes <ul> <li>Intuition: \\(v^*(S)\\) measures the marginal loss incurred by excluding \\(S\\)   from the grand coalition, i.e., how much value disappears when only the complement   coalition is allowed to form.</li> <li>The dual operation is an involution for TU games (up to the empty coalition convention):   applying it twice returns the original game: \\((v^*)^* = v\\).</li> <li>Duality is useful in studying correspondences between classes of games   (e.g., cost vs benefit formulations) and for theoretical results involving the core.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v_star = dual_game(g)\n&gt;&gt;&gt; N = g.grand_coalition\n&gt;&gt;&gt; # For a coalition S, v*(S) = v(N) - v(N \\ S)\n&gt;&gt;&gt; S = 0b011\n&gt;&gt;&gt; v_star.value(S) == g.value(N) - g.value(N &amp; ~S)\nTrue\n</code></pre>"},{"location":"reference/transforms/derived/#tucoopy.transforms.derived.restrict_to_players","title":"restrict_to_players","text":"<pre><code>restrict_to_players(game, ps)\n</code></pre> <p>Restrict a TU game to an explicit list of player indices.</p> <p>This is a convenience wrapper around :func:<code>subgame</code> that first converts the player list to a coalition mask.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game.</p> required <code>ps</code> <code>list[int]</code> <p>Player indices to keep. Must be non-empty and within range.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>Subgame induced by the specified players, with players renumbered to <code>0..k-1</code> in the order given by <code>players(mask_from_players(ps))</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; gT = restrict_to_players(g, [1, 3])\n&gt;&gt;&gt; gT.n_players\n2\n</code></pre>"},{"location":"reference/transforms/derived/#tucoopy.transforms.derived.subgame","title":"subgame","text":"<pre><code>subgame(game, coalition_mask)\n</code></pre> <p>Restrict a TU game to a coalition, producing the subgame on that coalition.</p> <p>Given a coalition \\(T \\subseteq N\\), the subgame \\(v_T\\) is defined on subsets of \\(T\\) by:</p> \\[ v_T(S) = v(S), \\quad \\forall S \\subseteq T. \\] <p>Since :class:<code>~tucoopy.base.game.Game</code> encodes coalitions as bitmasks over players \\(0,\\ldots,n-1\\), the returned subgame renumbers the players of \\(T\\) to a new index set \\(0,\\ldots,k-1\\) (where \\(k = |T|\\)) using the induced order of <code>players(T)</code>.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>Game</code> <p>Original TU game on player set \\(N\\).</p> required <code>coalition_mask</code> <code>int</code> <p>Coalition mask \\(T\\) defining the restriction. Must be non-empty.</p> required <p>Returns:</p> Type Description <code>Game</code> <p>A new TU game with <code>n_players = |T|</code> representing the restriction of <code>game</code> to coalition \\(T\\).</p> <p>Raises:</p> Type Description <code>InvalidCoalitionError</code> <p>If <code>coalition_mask</code> is empty or out of range.</p> Notes <ul> <li>Player renumbering: if \\(T\\) corresponds to original players   <code>(p0, p1, ..., p_{k-1})</code>, then in the returned game these players become   indices <code>0..k-1</code> in that order.</li> <li>Player labels are preserved by projection: if <code>game.player_labels</code> is set,   the returned game uses the corresponding subset of labels in the new order.</li> <li>This is a fundamental operation for recursive definitions and solution concepts   that consider restricted games.</li> </ul> <p>Examples:</p> <p>Restrict a 4-player game to coalition T = {1, 3}:</p> <pre><code>&gt;&gt;&gt; from tucoopy.base.coalition import mask_from_players\n&gt;&gt;&gt; T = mask_from_players([1, 3])\n&gt;&gt;&gt; gT = subgame(g, T)\n&gt;&gt;&gt; gT.n_players\n2\n</code></pre> <p>The new player 0 corresponds to original player 1, and new player 1 corresponds to original player 3, so:</p> <pre><code>&gt;&gt;&gt; # In the subgame, coalition {new 0} corresponds to {old 1}\n&gt;&gt;&gt; gT.value(0b01) == g.value(mask_from_players([1]))\nTrue\n</code></pre>"},{"location":"reference/transforms/harsanyi/","title":"<code>tucoopy.transforms.harsanyi</code>","text":""},{"location":"reference/transforms/harsanyi/#tucoopy.transforms.harsanyi--harsanyi-dividends-unanimity-coordinates","title":"Harsanyi dividends (unanimity coordinates).","text":"<p>The Harsanyi dividends provide a basis decomposition of a TU game into unanimity games. This module exposes a game-level wrapper around the M\u00f6bius transform.</p>"},{"location":"reference/transforms/harsanyi/#tucoopy.transforms.harsanyi.harsanyi_dividends","title":"harsanyi_dividends","text":"<pre><code>harsanyi_dividends(game)\n</code></pre> <p>Compute the Harsanyi dividends (unanimity coordinates) of a TU game.</p> <p>The Harsanyi dividends provide a unique decomposition of a cooperative game in the basis of unanimity games. They are given by the M\u00f6bius transform of the characteristic function over the subset lattice:</p> \\[ d(S) = \\sum_{T \\subseteq S} (-1)^{|S|-|T|} \\, v(T). \\] <p>Conversely, the original game can be reconstructed from the dividends via:</p> \\[ v(S) = \\sum_{T \\subseteq S} d(T). \\] <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU cooperative game.</p> required <p>Returns:</p> Type Description <code>dict[int, float]</code> <p>Dictionary mapping coalition masks to their Harsanyi dividend \\(d(S)\\).</p> Notes <ul> <li>The Harsanyi dividends express the game as a linear combination of   unanimity games \\(u_T\\), i.e.</li> </ul> <p>$$   v = \\sum_{T \\subseteq N} d(T) \\, u_T.   $$</p> <ul> <li>Many solution concepts admit elegant expressions in terms of these dividends.   For example, the Shapley value can be written directly as a weighted sum of   Harsanyi dividends.</li> <li>This implementation uses the standard in-place fast M\u00f6bius transform,   running in \\(O(n 2^n)\\) time.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = harsanyi_dividends(g)\n&gt;&gt;&gt; # The dividend of the empty coalition is always zero\n&gt;&gt;&gt; d[0]\n0.0\n</code></pre>"},{"location":"reference/transforms/mobius/","title":"<code>tucoopy.transforms.mobius</code>","text":""},{"location":"reference/transforms/mobius/#tucoopy.transforms.mobius--mobius-transform-over-the-subset-lattice","title":"M\u00f6bius transform over the subset lattice.","text":"<p>This module provides a fast M\u00f6bius transform (and its inverse) for dense functions defined on all coalitions. In cooperative game theory, applying the transform to a characteristic function yields Harsanyi dividends.</p>"},{"location":"reference/transforms/mobius/#tucoopy.transforms.mobius.inverse_mobius_transform","title":"inverse_mobius_transform","text":"<pre><code>inverse_mobius_transform(\n    values, *, n_players=None, backend=\"auto\"\n)\n</code></pre> <p>Compute the inverse M\u00f6bius transform (zeta transform over subsets).</p> <p>If \\(g\\) is the M\u00f6bius transform of \\(f\\), then the original function can be recovered by:</p> \\[ f(S) = \\sum_{T \\subseteq S} g(T). \\] <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[float]</code> <p>Dense sequence of length \\(2^n\\), indexed by coalition bitmask.</p> required <code>n_players</code> <code>int | None</code> <p>Number of players \\(n\\). If omitted, inferred from <code>len(values)</code>.</p> <code>None</code> <code>backend</code> <code>('auto', 'numpy', 'python')</code> <p>Backend used for the computation (same semantics as :func:<code>mobius_transform</code>).</p> <code>\"auto\"</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>A new list of length \\(2^n\\) containing the reconstructed values.</p> Notes <ul> <li>Complexity is \\(O(n \\cdot 2^n)\\).</li> <li>This operation is also known as the subset zeta transform.</li> <li>Applying this to Harsanyi dividends reconstructs the original   characteristic function.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; g = mobius_transform(f, n_players=2)\n&gt;&gt;&gt; f_rec = inverse_mobius_transform(g, n_players=2)\n&gt;&gt;&gt; f_rec == f\nTrue\n</code></pre>"},{"location":"reference/transforms/mobius/#tucoopy.transforms.mobius.mobius_transform","title":"mobius_transform","text":"<pre><code>mobius_transform(values, *, n_players=None, backend='auto')\n</code></pre> <p>Compute the M\u00f6bius transform over the subset lattice (bitmask coalitions).</p> <p>Given a function \\(f(S)\\) defined for all \\(S \\subseteq N\\), its M\u00f6bius transform \\(g\\) is defined by:</p> \\[ g(S) = \\sum_{T \\subseteq S} (-1)^{|S|-|T|} f(T). \\] <p>In cooperative game theory, applying this transform to the characteristic function \\(v(S)\\) yields the Harsanyi dividends \\(d(S)\\).</p> <p>Parameters:</p> Name Type Description Default <code>values</code> <code>Sequence[float]</code> <p>Dense sequence of length \\(2^n\\), indexed by coalition bitmask. The entry at index <code>mask</code> must correspond to \\(f(S)\\) for that coalition.</p> required <code>n_players</code> <code>int | None</code> <p>Number of players \\(n\\). If omitted, it is inferred from <code>len(values)</code>.</p> <code>None</code> <code>backend</code> <code>('auto', 'numpy', 'python')</code> <p>Backend used for the computation: - <code>\"auto\"</code>: try NumPy implementation, fall back to pure Python, - <code>\"numpy\"</code>: force NumPy (raises ImportError if unavailable), - <code>\"python\"</code>: use the pure-Python implementation.</p> <code>\"auto\"</code> <p>Returns:</p> Type Description <code>list[float]</code> <p>A new list of length \\(2^n\\) containing the M\u00f6bius-transformed values.</p> Notes <ul> <li>Complexity is \\(O(n \\cdot 2^n)\\) using the standard in-place fast transform.</li> <li>This function operates purely on dense numeric sequences and is agnostic   to the :class:<code>~tucoopy.base.game.Game</code> abstraction.</li> <li>The M\u00f6bius transform is the algebraic foundation for:<ul> <li>Harsanyi dividends,</li> <li>unanimity game decomposition,</li> <li>several fast algorithms for solution concepts.</li> </ul> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # values indexed by bitmask for n=2 players\n&gt;&gt;&gt; f = [0.0, 1.0, 2.0, 4.0]\n&gt;&gt;&gt; g = mobius_transform(f, n_players=2)\n</code></pre>"},{"location":"reference/viz/mpl2/","title":"<code>tucoopy.viz.mpl2</code>","text":""},{"location":"reference/viz/mpl2/#tucoopy.viz.mpl2--matplotlib-helpers-for-2-player-games-2d-segment-plots","title":"Matplotlib helpers for 2-player games (2D segment plots).","text":"<p>This module provides a small, static visualization for \\(n=2\\) TU games in the allocation plane \\((x_1, x_2)\\):</p> <ul> <li>draws the imputation set and the core as line segments,</li> <li>overlays point solutions (e.g. Shapley, Banzhaf, tau) and custom points,</li> <li>can read either a <code>tucoopy.base.game.Game</code> directly or a spec-like dict   (compatible with the JSON contract used by the JS demo).</li> </ul> Warnings <ul> <li>This module depends on Matplotlib at runtime.   Install it with <code>pip install \"tucoopy[viz]\"</code>.</li> <li>If Matplotlib is not installed, calling any plotting function will raise a   <code>MissingOptionalDependencyError</code>.</li> </ul>"},{"location":"reference/viz/mpl2/#tucoopy.viz.mpl2.plot_segment","title":"plot_segment","text":"<pre><code>plot_segment(\n    game,\n    *,\n    points=None,\n    points_by_label=None,\n    point_sets=None,\n    sets_vertices=None,\n    show_imputation=True,\n    show_core=True,\n    ax=None,\n)\n</code></pre> <p>Plot the 2-player (\\(n=2\\)) imputation set and core as line segments in \\((x_1,x_2)\\).</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game with n_players=2.</p> required <code>points</code> <code>Sequence[Sequence[float]] | None</code> <p>Optional list of allocations to plot on top.</p> <code>None</code> <code>points_by_label</code> <code>Mapping[str, Sequence[float]] | None</code> <p>Optional mapping {label: allocation}.</p> <code>None</code> <code>point_sets</code> <code>Mapping[str, Sequence[Sequence[float]]] | None</code> <p>Optional mapping {label: allocations} to plot as point clouds.</p> <code>None</code> <code>sets_vertices</code> <code>Mapping[str, Sequence[Sequence[float]]] | None</code> <p>Optional mapping {label: vertices} for sets drawn as segments.</p> <code>None</code> <code>show_imputation</code> <code>bool</code> <p>If True, draw the imputation segment.</p> <code>True</code> <code>show_core</code> <code>bool</code> <p>If True, draw the core segment (if non-empty).</p> <code>True</code> <code>ax</code> <p>Optional Matplotlib Axes; if omitted, a new figure/axes is created.</p> <code>None</code> Warnings <p>This function requires Matplotlib at runtime (install with <code>pip install \"tucoopy[viz]\"</code>).</p>"},{"location":"reference/viz/mpl2/#tucoopy.viz.mpl2.plot_spec_segment","title":"plot_spec_segment","text":"<pre><code>plot_spec_segment(\n    spec,\n    *,\n    sets=(\"imputation\", \"core\"),\n    solutions=(\"shapley\",),\n    series_id=None,\n    frame_index=0,\n    t=None,\n    use_analysis=True,\n    compute_missing=True,\n    epsilon=None,\n    n_samples=200,\n    seed=None,\n    ax=None,\n)\n</code></pre> <p>Plot an AnimationSpec-like object for \\(n=2\\) as a static segment plot.</p> <p>This is a convenience wrapper that:</p> <ol> <li>builds a <code>Game</code> from <code>spec.game</code>,</li> <li>reads precomputed sets/solutions from <code>spec.analysis</code> (if enabled), and </li> <li>optionally computes missing objects for small \\(n\\).</li> </ol> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>Any</code> <p>A spec object (dict-like or attribute-like) with fields: <code>game</code> and optionally <code>analysis</code> and <code>series</code>.</p> required <code>sets</code> <code>Sequence[str]</code> <p>Set labels to plot (e.g. <code>(\"imputation\", \"core\", \"epsilon_core\")</code>). Some sets may be drawn from vertices; others may be drawn as point clouds.</p> <code>('imputation', 'core')</code> <code>solutions</code> <code>Sequence[str]</code> <p>Solution labels to plot as points (e.g. <code>(\"shapley\", \"tau\")</code>).</p> <code>('shapley',)</code> <code>series_id</code> <code>str | None</code> <p>Frame selection parameters for plotting a highlighted \"frame\" allocation from <code>spec.series</code> (if present).</p> <code>None</code> <code>frame_index</code> <code>str | None</code> <p>Frame selection parameters for plotting a highlighted \"frame\" allocation from <code>spec.series</code> (if present).</p> <code>None</code> <code>t</code> <code>str | None</code> <p>Frame selection parameters for plotting a highlighted \"frame\" allocation from <code>spec.series</code> (if present).</p> <code>None</code> <code>use_analysis</code> <code>bool</code> <p>If True, try using <code>spec.analysis.sets</code> and <code>spec.analysis.solutions</code>.</p> <code>True</code> <code>compute_missing</code> <code>bool</code> <p>If True, compute sets/solutions that are not present in analysis.</p> <code>True</code> <code>epsilon</code> <code>float | None</code> <p>Epsilon value used when computing <code>epsilon_core</code> (if needed). If omitted, tries to read it from analysis when available.</p> <code>None</code> <code>n_samples</code> <code>int</code> <p>Sample size for sampling-based sets (kernel/prekernel/bargaining).</p> <code>200</code> <code>seed</code> <code>int | None</code> <p>Random seed for sampling-based sets.</p> <code>None</code> <code>ax</code> <p>Optional Matplotlib Axes.</p> <code>None</code> <p>Returns:</p> Type Description <code>(fig, ax)</code> <p>The Matplotlib Figure and Axes used for the plot.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the game in <code>spec</code> does not have <code>n_players=2</code>.</p> Warnings <p>This function requires Matplotlib at runtime (install with <code>pip install \"tucoopy[viz]\"</code>).</p>"},{"location":"reference/viz/mpl3/","title":"<code>tucoopy.viz.mpl3</code>","text":""},{"location":"reference/viz/mpl3/#tucoopy.viz.mpl3--matplotlib-helpers-for-3-player-games-ternary-plots","title":"Matplotlib helpers for 3-player games (ternary plots).","text":"<p>This module provides a static ternary (simplex) plot for \\(n=3\\) TU games:</p> <ul> <li>draws the imputation simplex as the background triangle,</li> <li>overlays core and other set-valued objects as polygons/segments,</li> <li>overlays point solutions and custom points.</li> </ul> Warnings <ul> <li>This module depends on Matplotlib at runtime.   Install it with <code>pip install \"tucoopy[viz]\"</code>.</li> <li>If Matplotlib is not installed, calling any plotting function will raise a   <code>MissingOptionalDependencyError</code>.</li> </ul>"},{"location":"reference/viz/mpl3/#tucoopy.viz.mpl3.plot_spec_ternary","title":"plot_spec_ternary","text":"<pre><code>plot_spec_ternary(\n    spec,\n    *,\n    sets=(\"imputation\", \"core\"),\n    solutions=(\"shapley\",),\n    series_id=None,\n    frame_index=0,\n    t=None,\n    use_analysis=True,\n    compute_missing=True,\n    epsilon=None,\n    n_samples=200,\n    seed=None,\n    ax=None,\n)\n</code></pre> <p>Plot an AnimationSpec-like object for \\(n=3\\) as a static ternary (simplex) plot.</p> <p>Reads sets/solutions from <code>spec.analysis</code> when available and enabled, and can compute missing objects for small \\(n\\). The imputation simplex is rendered as the background triangle.</p> <p>Parameters:</p> Name Type Description Default <code>spec</code> <code>Any</code> <p>A spec object (dict-like or attribute-like) with fields: <code>game</code> and optionally <code>analysis</code> and <code>series</code>.</p> required <code>sets</code> <code>Sequence[str]</code> <p>Set labels to plot. <code>\"imputation\"</code> controls whether the background simplex is drawn.</p> <code>('imputation', 'core')</code> <code>solutions</code> <code>Sequence[str]</code> <p>Solution labels to plot as points.</p> <code>('shapley',)</code> <code>series_id</code> <code>str | None</code> <p>Frame selection parameters for plotting a highlighted \"frame\" allocation.</p> <code>None</code> <code>frame_index</code> <code>str | None</code> <p>Frame selection parameters for plotting a highlighted \"frame\" allocation.</p> <code>None</code> <code>t</code> <code>str | None</code> <p>Frame selection parameters for plotting a highlighted \"frame\" allocation.</p> <code>None</code> <code>use_analysis</code> <code>bool</code> <p>If True, try using <code>spec.analysis</code> entries for sets/solutions.</p> <code>True</code> <code>compute_missing</code> <code>bool</code> <p>If True, compute sets/solutions that are not present in analysis.</p> <code>True</code> <code>epsilon</code> <code>float | None</code> <p>Epsilon value used when computing <code>epsilon_core</code> (if needed).</p> <code>None</code> <code>n_samples</code> <code>int</code> <p>Sample size for sampling-based sets (kernel/prekernel/bargaining).</p> <code>200</code> <code>seed</code> <code>int | None</code> <p>Random seed for sampling-based sets.</p> <code>None</code> <code>ax</code> <p>Optional Matplotlib Axes.</p> <code>None</code> <p>Returns:</p> Type Description <code>(fig, ax)</code> <p>The Matplotlib Figure and Axes used for the plot.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If the game in <code>spec</code> does not have <code>n_players=3</code>.</p> Warnings <p>This function requires Matplotlib at runtime (install with <code>pip install \"tucoopy[viz]\"</code>).</p>"},{"location":"reference/viz/mpl3/#tucoopy.viz.mpl3.plot_ternary","title":"plot_ternary","text":"<pre><code>plot_ternary(\n    game,\n    *,\n    points=None,\n    points_by_label=None,\n    point_sets=None,\n    sets_vertices=None,\n    show_imputation=True,\n    show_core=True,\n    ax=None,\n)\n</code></pre> <p>Plot a 3-player TU game on a ternary (simplex) diagram.</p> <p>The imputation set is drawn as the background triangle (after the standard affine normalization using individual lower bounds). Other sets are drawn either as polygons (&gt;=3 vertices), segments (2 vertices), or points.</p> <p>Parameters:</p> Name Type Description Default <code>game</code> <code>GameProtocol</code> <p>TU game with n_players=3.</p> required <code>points</code> <code>Sequence[Sequence[float]] | None</code> <p>Optional allocations to overlay as points.</p> <code>None</code> <code>points_by_label</code> <code>Mapping[str, Sequence[float]] | None</code> <p>Optional mapping {label: allocation} to overlay labeled points.</p> <code>None</code> <code>point_sets</code> <code>Mapping[str, Sequence[Sequence[float]]] | None</code> <p>Optional mapping {label: allocations} to overlay point clouds.</p> <code>None</code> <code>sets_vertices</code> <code>Mapping[str, Sequence[Sequence[float]]] | None</code> <p>Optional mapping {label: vertices} for set polygons/segments in R^3.</p> <code>None</code> <code>show_imputation</code> <code>bool</code> <p>If True, draw the imputation triangle (when feasible).</p> <code>True</code> <code>show_core</code> <code>bool</code> <p>If True, compute and draw the core polygon (if non-empty).</p> <code>True</code> <code>ax</code> <p>Optional Matplotlib Axes; if omitted, a new figure/axes is created.</p> <code>None</code> <p>Returns:</p> Type Description <code>(fig, ax)</code> <p>The Matplotlib Figure and Axes used for the plot.</p> <p>Raises:</p> Type Description <code>InvalidParameterError</code> <p>If game.n_players != 3.</p> Warnings <p>This function requires Matplotlib at runtime (install with <code>pip install \"tucoopy[viz]\"</code>).</p>"},{"location":"theory/","title":"An introduction to cooperative game theory","text":"<p>Game theory studies situations where our outcomes depend not only on our own decisions, but also on the choices of others.</p> <p>This happens all the time: in negotiations, markets, collaborative projects, shared infrastructure, political coalitions -- and even in the everyday choice between cooperating or acting alone.</p> <p>In cooperative game theory, however, the focus shifts.</p> <p>Instead of asking:</p> <p>\"What move should I make now?\"</p> <p>we ask a different question. Simpler. And often more practical:</p> <p>What do we gain by cooperating -- and how should we split that gain?</p> <p>Imagine a group of agents who can form alliances. Alone, each agent can generate some value. Together, they can often generate much more.</p> <p>But the truly interesting point is not just that cooperation creates value.</p> <p>It is that different groups create different amounts of value.</p> <p>Some coalitions are strong. Others are weak. Certain participants are decisive in some combinations and almost irrelevant in others.</p> <p>Cooperative game theory exists precisely to describe and analyze this structure of cooperation.</p> <p>Here, we do not focus on step-by-step decisions or individual strategies. We assume something else: that participants can make binding agreements<sup>1</sup>.</p> <p>The central object is no longer strategy, but the value structure of coalitions -- that is, how much each possible group can generate when it cooperates.</p> <p>From there, we begin to ask questions such as:</p> <ul> <li>Who is essential for cooperation to work?</li> <li>Which agreements are stable, in the sense that no group has an incentive to leave them?</li> <li>What does a \"fair\" split mean in practice?</li> <li>To what extent does the outcome depend on bargaining power or voting rules?</li> </ul> <p>Different questions lead to different solution concepts.</p> <p>Some prioritize fairness and symmetry. Others emphasize stability and resistance to deviations. Others still capture influence or power within the group.</p> <p>None of them is universally \"correct\". Each reflects a particular way of looking at cooperation.</p> <p>An example helps make this concrete.</p> <p>Imagine that building a gas pipeline could benefit several interested companies. Building it is too expensive for a single company. But when several companies join forces, the project becomes viable.</p> <p>Different groups of companies can make the project viable in different ways and therefore generate different construction costs (or different net benefits).</p> <p>So a natural question arises:</p> <p>How should we reasonably split the cost -- or the benefit -- of that cooperation?</p> <p>Cooperative game theory provides the tools to describe situations like this and to compare different ways of sharing the value created when agents decide to cooperate.</p> <p>The next sections are not meant to overwhelm you with formal definitions or technical proofs.</p> <p>The goal here is different.</p> <p>It is to build intuition.</p> <p>To understand what each concept is trying to capture, why it works the way it does, and how to interpret its results in practice.</p> <p>If, by the end, you can look at an allocation and think:</p> <p>\"This makes sense, given what we value here: fairness, stability, or power.\"</p> <p>then you will already have grasped the essence of cooperative game theory.</p> <ol> <li> <p>An agreement is binding when there is no room for bluffing. If agents make an agreement, it is not possible for any of them to fail to carry it out.\u00a0\u21a9</p> </li> </ol>"},{"location":"theory/allocations/","title":"Sharing the value: allocations and imputations","text":"<p>Now that we understand that a cooperative game is described by a function \\(v(S)\\), a natural question arises:</p> <p>How should we split the value generated by the grand coalition \\(N\\)?</p> <p>We know how much each group can generate. But we have not yet said how that value is distributed among players.</p> <p>This is where a new central object of the theory appears.</p>"},{"location":"theory/allocations/#allocations","title":"Allocations","text":"<p>One way to split value among players is via a vector</p> \\[ x = (x_1, x_2, \\dots, x_n) \\in \\mathbb{R}^n, \\] <p>where \\(x_i\\) represents what player \\(i\\) receives.</p> <p>This vector is called an allocation.</p> <p>It no longer depends on coalitions. It describes only the final outcome of cooperation.</p>"},{"location":"theory/allocations/#a-first-natural-requirement-distribute-all-available-value","title":"A first natural requirement: distribute all available value","text":"<p>If the players together can generate \\(v(N)\\), it is reasonable to require that all of it is distributed:</p> \\[ \\sum_{i \\in N} x_i = v(N). \\] <p>If the sum is smaller, we are \"throwing away\" value. If it is larger, we are distributing something that does not exist.</p> <p>This condition is called efficiency.</p>"},{"location":"theory/allocations/#a-second-natural-requirement-no-one-accepts-less-than-acting-alone","title":"A second natural requirement: no one accepts less than acting alone","text":"<p>Each player knows what they can generate on their own: \\(v(\\{i\\})\\).</p> <p>So a division only makes sense if</p> \\[ x_i \\ge v(\\{i\\}), \\quad \\text{for all } i \\in N. \\] <p>Otherwise, the player would prefer to leave the cooperation.</p> <p>This condition is called individual rationality.</p>"},{"location":"theory/allocations/#imputations","title":"Imputations","text":"<p>When an allocation satisfies these two properties -- efficiency and individual rationality -- it gets a special name.</p> <p>We call such an allocation an imputation.</p> <p>Mathematically, the set of all imputations is</p> \\[ \\left\\{ x \\in \\mathbb{R}^n \\,:\\, \\sum_{i \\in N} x_i = v(N) \\text{ and } x_i \\ge v(\\{i\\}) \\ \\forall i \\right\\}. \\] <p>This set is called the imputation set.</p>"},{"location":"theory/allocations/#what-does-this-mean-intuitively","title":"What does this mean intuitively?","text":"<p>An imputation is simply a way to split the total value that:</p> <ul> <li>uses exactly everything that was generated, and</li> <li>ensures nobody is worse off compared to acting alone.</li> </ul> <p>We have not said anything about fairness yet. We have not said anything about stability yet. We have not said anything about power yet.</p> <p>We are only describing the divisions that make sense to consider.</p>"},{"location":"theory/allocations/#visualizing-it","title":"Visualizing it","text":"<p>Geometrically, imputations form a subset of a hyperplane in \\(\\mathbb{R}^n\\): all possible divisions of the total value, constrained by the requirement that each player must receive at least what they could get alone.</p> <p>This is the \"space\" where all classic solutions will live.</p> P1 P2 P3      Imputation set for the pipeline example:     $ \\{(x_1,x_2,x_3) \\, : \\, x_1+x_2+x_3 = 100,\\; x_i \\ge 0\\} $"},{"location":"theory/allocations/#why-is-this-such-an-important-step","title":"Why is this such an important step?","text":"<p>Because now we can restate all the theory's questions very clearly:</p> <ul> <li>Among all imputations, which are stable?</li> <li>Among all imputations, which are fair?</li> <li>Among all imputations, which best reflect each player's power?</li> </ul> <p>The concepts that come next -- core, Shapley value, least-core, kernel, power indices -- are nothing more than different ways of selecting points inside this set.</p> <p>From here on, cooperative game theory becomes the art of selecting good imputations.</p>"},{"location":"theory/notation/","title":"Notation and conventions","text":"<p>This section summarizes the notation used in the theory pages and in the library. We follow standard notation for transferable-utility (TU) cooperative game theory, with a few small conventions chosen for clarity and ease of implementation.</p> <p>The goal is not to introduce new concepts, but to establish a common language so that definitions, algorithms, and outputs can be interpreted consistently.</p>"},{"location":"theory/notation/#players-and-coalitions","title":"Players and coalitions","text":"<ul> <li>Players are indexed by the finite set \\(N = \\{1, \\ldots, n\\}\\).</li> <li>A coalition is any subset \\(S \\subseteq N\\).</li> <li>The grand coalition is the set of all players, denoted by \\(N\\) itself.</li> </ul> <p>In the code, players are indexed from <code>0</code> to <code>n-1</code>, following standard Python conventions. Coalitions are represented internally as bitmasks, but most user-facing functions accept Python iterables (lists, tuples, or sets of player indices).</p> <p>Intuition</p> <p>A coalition is simply a group of players acting together. The grand coalition represents full cooperation among all players.</p>"},{"location":"theory/notation/#characteristic-function","title":"Characteristic function","text":"<p>A TU cooperative game is described by a characteristic function</p> \\[ v : 2^N \\to \\mathbb{R}, \\] <p>which assigns a real value to each coalition, with the normalization</p> \\[ v(\\emptyset) = 0. \\] <p>The value \\(v(S)\\) represents the total value that coalition \\(S\\) can generate on its own, assuming its members cooperate fully and can transfer utility freely among themselves.</p> <p>Intuition</p> <p>Think of \\(v(S)\\) as the \"size of the pie\" available to coalition \\(S\\). How that pie is divided comes later.</p>"},{"location":"theory/notation/#allocations-and-efficiency","title":"Allocations and efficiency","text":"<p>Definition</p> <p>An allocation is a vector</p> \\[ x = (x_1, \\dots, x_n) \\in \\mathbb{R}^n, \\] <p>where \\(x_i\\) denotes the payoff assigned to player \\(i\\).</p> <p>An allocation is efficient if</p> \\[ \\sum_{i \\in N} x_i = v(N). \\] <p>Intuition</p> <p>Efficiency means that all value created by full cooperation is distributed among the players. Nothing is lost and nothing is left undistributed.</p> Example <p>For an additive game defined by \\(v(S) = |S|\\) with \\(n=3\\), the grand coalition has value</p> \\[ v(N) = 3. \\] <p>A natural efficient allocation is</p> \\[ x = (1, 1, 1), \\] <p>where each player receives exactly their standalone contribution.</p>"},{"location":"theory/notation/#coalition-sums-and-excess","title":"Coalition sums and excess","text":"<p>Definition</p> <p>Given an allocation \\(x\\) and a coalition \\(S \\subseteq N\\), the coalition sum is</p> \\[ x(S) = \\sum_{i \\in S} x_i. \\] <p>The excess of coalition \\(S\\) at allocation \\(x\\) is defined as</p> \\[ e(S, x) = v(S) - x(S). \\] <p>Intuition</p> <p>The excess measures how dissatisfied a coalition is.</p> <ul> <li>If \\(e(S, x) &gt; 0\\), coalition \\(S\\) can do better on its own than under allocation \\(x\\).</li> <li>If \\(e(S, x) = 0\\), the coalition is exactly satisfied.</li> <li>If \\(e(S, x) &lt; 0\\), the coalition receives more than its standalone value.</li> </ul> <p>The concept of excess is central in many solution concepts, especially those related to stability, such as the core, the \\(\\epsilon\\)-core, and the nucleolus.</p>"},{"location":"theory/set_solutions/","title":"The core and related polyhedra","text":"<p>Many solution objects are defined as polyhedra.</p>"},{"location":"theory/set_solutions/#core","title":"Core","text":"<p>Allocations in the core satisfy:</p> <ul> <li>Efficiency: \\(\\sum_i x_i = v(N)\\)</li> <li>Coalitional rationality: \\(x(S) \\ge v(S)\\) for every non-empty proper coalition \\(S\\)</li> </ul> <p>Definition (core)</p> <p>The core of a TU game \\((N,v)\\) is the set of allocations \\(x \\in \\mathbb{R}^n\\) such that:</p> \\[\\sum_{i \\in N} x_i = v(N),$$ and for every non-empty proper coalition $S$, $$x(S) = \\sum_{i \\in S} x_i \\ge v(S).\\] <p>Intuition</p> <p>No coalition can profitably deviate: every coalition receives at least what it can guarantee on its own.</p>"},{"location":"theory/set_solutions/#epsilon-core-least-core","title":"\\(\\epsilon\\)-core / least-core","text":"<p>The \\(\\epsilon\\)-core relaxes coalitional rationality by \\(\\epsilon \\ge 0\\):</p> <ul> <li>\\(x(S) \\ge v(S) - \\epsilon\\)</li> </ul> <p>The least-core chooses the smallest possible \\(\\epsilon\\) (computed via LP when SciPy is available).</p>"},{"location":"theory/set_solutions/#imputation-set","title":"Imputation set","text":"<ul> <li>Efficiency + individual rationality (\\(x_i \\ge v(\\{i\\})\\))</li> </ul> <p>Definition (imputation set)</p> <p>The imputation set is:</p> \\[I(v) = \\left\\{x \\in \\mathbb{R}^n : \\sum_{i \\in N} x_i = v(N),\\; x_i \\ge v(\\{i\\})\\;\\forall i\\right\\}.\\] <p>For implementation-oriented details, see <code>../library/geometry.md</code>.</p>"},{"location":"theory/simple_games/","title":"Simple games and weighted voting","text":"<p>A simple game typically has \\(v(S) \\in \\{0,1\\}\\) for every coalition \\(S\\).</p> <p>Weighted voting games are a common subclass:</p> <ul> <li>Given weights \\(w_i\\) and a quota \\(q\\), coalition \\(S\\) is winning if \\(\\sum_{i \\in S} w_i \\ge q\\).</li> </ul> <p>Power indices:</p> <ul> <li>Shapley-Shubik index</li> <li>(Normalized) Banzhaf index</li> </ul> <p>In the code, we validate the \"simple game\" assumption before computing these indices.</p>"},{"location":"theory/simple_games/#definition-simple-game","title":"Definition (simple game)","text":"<p>Definition</p> <p>A simple game satisfies \\(v(S) \\in \\{0,1\\}\\) for every coalition \\(S\\). In general, \\(v(S)=1\\) means \"winning\" and \\(v(S)=0\\) means \"losing\".</p> <p>Intuition</p> <p>Only the yes/no outcome matters; utilities are not cardinal beyond that.</p>"},{"location":"theory/solution_concepts/","title":"Solution concepts (overview)","text":"<p>This library implements several classic solution concepts. At a high level:</p> <ul> <li>Values (single-point selections): Shapley value, Banzhaf value, \\(\\tau\\) value.</li> <li>LP-based selections (SciPy optional): least-core, nucleolus, pre-nucleolus.</li> <li>Complementarity-based selections (NumPy optional): kernel, prekernel.</li> </ul>"},{"location":"theory/solution_concepts/#shapley-value","title":"Shapley value","text":"<p>Definition</p> <p>The Shapley value assigns to each player \\(i\\) the average marginal contribution over all permutations:</p> \\[\\varphi_i(v) = \\sum_{S \\subseteq N\\setminus\\{i\\}} \\frac{|S|!(n-|S|-1)!}{n!}\\,\\bigl(v(S\\cup\\{i\\})-v(S)\\bigr).\\] <p>Intuition</p> <p>Each arrival order is equally likely; a player's payoff is their expected marginal contribution.</p>"},{"location":"theory/stability/","title":"Stability: blocking and the core","text":"<p>So far, we described the imputation set: divisions that use all the value and guarantee that nobody is worse off than acting alone.</p> <p>But one essential question remains.</p> <p>Even if a division looks reasonable, is it sustainable?</p> <p>That is:</p> <p>Is there some group of players that would prefer to leave the grand coalition and make a deal on its own?</p> <p>This is the central idea behind stability in cooperative games.</p>"},{"location":"theory/stability/#the-idea-of-deviation-in-cooperative-games","title":"The idea of \"deviation\" in cooperative games","text":"<p>Consider an imputation \\(x \\in \\mathbb{R}^n\\). It says how much each player receives when everyone cooperates.</p> <p>Now take a coalition \\(S \\subseteq N\\). This group knows that, if it breaks away, it can generate \\(v(S)\\).</p> <p>The question is: can they split \\(v(S)\\) among themselves in a way that makes everyone in \\(S\\) strictly better than under \\(x\\)?</p> <p>If yes, then \\(x\\) is not sustainable: that group has an incentive to break the agreement.</p>"},{"location":"theory/stability/#total-payoff-of-a-coalition","title":"Total payoff of a coalition","text":"<p>Given a vector \\(x\\), we write the total payoff that \\(x\\) gives to a coalition \\(S\\) as</p> \\[ x(S) := \\sum_{i\\in S} x_i. \\] <p>This notation is useful because the coalition compares \"what it gets under the current agreement\" with \"what it can guarantee on its own\".</p>"},{"location":"theory/stability/#blocking","title":"Blocking","text":"<p>We say a coalition \\(S\\) can block an imputation \\(x\\) if it can secure enough value to improve the situation of everyone within \\(S\\).</p> <p>A simple (and widely used) sufficient condition for that is:</p> \\[ v(S) &gt; x(S). \\] <p>Interpretation</p> <p>Group \\(S\\) can generate more than it is receiving under the current agreement, so it has \"slack\" to propose an alternative deal that benefits its members.</p> <p>If there exists some \\(S\\) that blocks \\(x\\), then \\(x\\) is not stable: a coalitional deviation is plausible.</p>"},{"location":"theory/stability/#the-core","title":"The core","text":"<p>The core is the set of imputations that cannot be blocked by any coalition.</p> <p>In practical terms: these are divisions where no one, in any group, has an incentive to abandon the agreement.</p> <p>Mathematically, the core is the set of allocations \\(x\\) such that:</p> \\[ \\sum_{i \\in N} x_i = v(N) \\quad\\text{and}\\quad x(S) \\ge v(S)\\; \\text{for all } S \\subseteq N. \\] <p>The condition \\(x(S) \\ge v(S)\\) says:</p> <p>\"any coalition \\(S\\) already receives at least what it could guarantee on its own\".</p>"},{"location":"theory/stability/#a-geometric-view-the-3-player-case","title":"A geometric view (the 3-player case)","text":"<p>When \\(n=3\\), the imputation set is a triangle (as you saw earlier). Each constraint of the form</p> \\[ x(S) \\ge v(S) \\] <p>becomes a half-plane cutting that triangle.</p> <p>The core is simply the intersection of all those cuts.</p> <p>That is why it is often a smaller polygon<sup>1</sup> inside the triangle -- and sometimes... it may not exist at all.</p>"},{"location":"theory/stability/#an-important-fact-the-core-can-be-empty","title":"An important fact: the core can be empty","text":"<p>Even when the grand coalition generates a lot of value, it can happen that there is no imputation that simultaneously satisfies all constraints \\(x(S) \\ge v(S)\\).</p> <p>Intuitively, this happens when \"partial\" coalitions are too strong: there is always some group that can demand more than the current agreement can offer without violating another constraint.</p> <p>When the core is empty, we need other, more flexible notions of stability -- such as the least-core and the nucleolus.</p> <p>(And this is where the theory starts getting really interesting.)</p> <ol> <li> <p>In higher dimensions we call it a polytope: an intersection of half-spaces.\u00a0\u21a9</p> </li> </ol>"},{"location":"theory/tu_games/","title":"The cooperative game as a coalition value function","text":"<p>After the initial intuition about cooperation, we now need to take an important step: describe the situation precisely.</p> <p>The central idea of cooperative games is surprisingly simple.</p> <p>We do not model strategies. We do not model step-by-step decisions. We do not model sequences of moves.</p> <p>We model only this:</p> <p>how much value each possible group of players can generate when it cooperates.</p>"},{"location":"theory/tu_games/#players-and-coalitions","title":"Players and coalitions","text":"<p>Consider a finite set of players</p> \\[ N = \\\\{1,2,\\\\dots,n\\\\}. \\] <p>Any subset \\(S \\\\subseteq N\\) is called a coalition.</p> <p>This includes:</p> <ul> <li>players alone, like \\(\\\\{i\\\\}\\),</li> <li>intermediate groups, like \\(\\\\{1,3,4\\\\}\\),</li> <li>and the grand coalition \\(N\\), containing everyone.</li> </ul> <p>The central question becomes:</p> <p>If exactly the players in \\(S\\) cooperate with each other, how much can they generate?</p>"},{"location":"theory/tu_games/#the-characteristic-function","title":"The characteristic function","text":"<p>That question is answered by a function</p> \\[ v : 2^N \\\\longrightarrow \\\\mathbb{R}, \\] <p>where \\(2^N\\) is the set of all possible coalitions.</p> <p>For each \\(S \\\\subseteq N\\), the number \\(v(S)\\) represents the total value the players in \\(S\\) can generate by cooperating.</p> <p>We can now write this precisely.</p> <p>A (transferable-utility) cooperative game is described by a pair \\((N,v)\\), where</p> \\[ v:2^N \\\\to \\\\mathbb{R}, \\\\qquad v(\\\\emptyset)=0. \\] <p>This function is called the characteristic function (or coalition function) of the game.</p>"},{"location":"theory/tu_games/#what-does-this-function-really-mean","title":"What does this function really mean?","text":"<p>Depending on the context, \\(v(S)\\) may represent:</p> <ul> <li>profit generated by a consortium of companies,</li> <li>cost savings from sharing infrastructure,</li> <li>votes obtained by a political coalition,</li> <li>joint production capacity,</li> <li>risk reduction from acting as a group.</li> </ul> <p>The essential point is that \\(v(S)\\) measures the total value available to that group.</p> <p>Think of \\(v(S)\\) as the size of the pie available to coalition \\(S\\). How that pie is divided comes later.</p>"},{"location":"theory/tu_games/#a-concrete-example","title":"A concrete example","text":"<p>Consider three companies interested in building a gas pipeline:</p> \\[ N = \\\\{1,2,3\\\\}. \\] <p>Alone, none of them can make the project viable:</p> \\[ v(\\\\{1\\\\}) = v(\\\\{2\\\\}) = v(\\\\{3\\\\}) = 0. \\] <p>But in pairs, they can already extract some value:</p> \\[ v(\\\\{1,2\\\\}) = 80, \\\\quad v(\\\\{1,3\\\\}) = 60, \\\\quad v(\\\\{2,3\\\\}) = 70. \\] <p>And all three together achieve an even better outcome:</p> \\[ v(\\\\{1,2,3\\\\}) = 100. \\] <p>That table is the entire game. Nothing else is needed.</p>"},{"location":"theory/tu_games/#what-we-are-not-modeling","title":"What we are not modeling","text":"<p>Notice what we left out:</p> <ul> <li>who proposed the alliance,</li> <li>who negotiated with whom,</li> <li>what the order of decisions was,</li> <li>what strategies were used.</li> </ul> <p>All of that disappears.</p> <p>What remains is only the value structure of cooperation.</p>"},{"location":"theory/tu_games/#why-is-this-powerful","title":"Why is this powerful?","text":"<p>Because from this function \\(v\\) alone, we can start asking deep questions:</p> <ul> <li>How should we split \\(v(N)\\) among the players?</li> <li>Who is essential for generating value?</li> <li>Do stable divisions exist?</li> <li>What is a fair division?</li> <li>Who has more power within the coalition structure?</li> </ul> <p>All classic concepts in cooperative game theory arise exclusively from this function.</p>"},{"location":"theory/tu_games/#an-important-change-in-perspective","title":"An important change in perspective","text":"<p>In non-cooperative games, the focus is on players' behavior.</p> <p>Here, the focus is on the mathematical structure of cooperation.</p> <p>The game is not a sequence of actions.</p> <p>The game is a table of coalition values.</p> <p>And it is from that table that the whole theory is built.</p> <p>A strong (and maybe invisible) assumption</p> <p>At this point, we are assuming something very strong.</p> <p>We are assuming that if a coalition generates value \\(v(S)\\), then that value can be divided among its members in any way they want.</p> <p>We are assuming that value is perfectly transferable.</p> <p>This is natural when we talk about money, profit, costs, or energy.</p> <p>But not every kind of cooperation produces something that can be redistributed this way.</p> <p>Sometimes cooperating does not produce \"a pie to divide\", but rather a set of feasible outcomes -- and some outcomes cannot be converted into others through side payments.</p> <p>When that happens, the model we are using is no longer appropriate.</p> <p>We then enter the world of non-transferable utility games.</p> <p>They exist. They matter. And they are mathematically more subtle.</p> <p>But for almost everything we want to study here -- fairness, stability, and power when value can be redistributed -- the model we are using, called transferable utility (TU), is not only sufficient, but extraordinarily expressive.</p>"}]}